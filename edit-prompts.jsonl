[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a XYZZ smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: You are tasked with generating an Ethereum smart contract for a token named XYZZ. This token is an ERC20 compliant digital asset with added functionalities to support initial coin offering (ICO) stages, including bonus periods, a soft cap, and account freezing capabilities for security.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nContract Structure Overview:\n- Token Information: Your contract should declare basic token attributes such as symbol, name, description, and decimals.\n- ICO Stages: Include variables to manage ICO stages, like `_startDate`, `_bonusEnds`, `_endDate`, `_internalCap`, and `_softCap`.\n- State Variables: Define mappings for storing balances (`_balances`), allowances (`_allowed`), and account freeze states (`_freezeState`).\n\nFunctionality Requirements:\n1. Constructor: Initialize the contract with token information, ICO parameters, and allocate initial tokens to the minter's account.\n2. ICO Constraints: Implement a modifier IcoSuccessful to check conditions for certain functions (e.g., token transfers post-ICO completion and achieving the soft cap).\n3. Balance and Transfers: Include functions for querying balances (balanceOf), transferring tokens (transfer, transferFrom), and managing allowances (approve, allowance).\n4. Freezing Accounts: Provide functionality to freeze and unfreeze accounts to prevent transfers during the ICO or due to security reasons.\n5. Token Minting and Burning: Allow the contract owner to mint new tokens or burn existing tokens from their balance or specified accounts.\n6. Bonus Mechanism: During the ICO, implement a method for purchasing tokens that awards bonus tokens if purchased during the bonus period.\n7. ERC20 Compliance: Ensure the contract adheres to the ERC20 standard for token contracts.\n\nSafety Considerations:\n- Use SafeMath for all arithmetic operations to protect against overflow and underflow.\n- Ensure only the contract owner can mint, burn, freeze, or unfreeze tokens.\n- Validate all user inputs and enforce checks on token transfers, especially when modifying allowances or executing transfers from and to accounts.\n\nImplementation Details:\n- Token Initialization: Start with defining the contract's metadata and ICO parameters within the constructor.\n- Function Implementations: Carefully implement each function, adhering to the ERC20 standard and custom business logic as outlined. Pay attention to security checks, such as verifying ICO success or account freeze status before proceeding with certain operations.\n- Event Logging: Emit appropriate events for token transfers, approval changes, and other significant actions for transparency and traceability.\n\nExamples and Resources:\n- Refer to OpenZeppelin contracts for secure implementation examples, especially for ERC20 functionality and SafeMath operations.\n- Consult the Ethereum EIP-20 token standard documentation for compliance requirements and function specifications.\n"}, {"role": "assistant", "content": "\ncontract XYZZ is ERC20Interface, Owned, SafeMath {\n    string public symbol;\n    string public name;\n    string public description;\n    uint8 public decimals;    \n    uint private _startDate;\n    uint private _bonusEnds;\n    uint private _endDate;\n    \n    uint256 private _internalCap;\n    uint256 private _softCap;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) _balances;\n    mapping(address => mapping(address => uint256)) _allowed;\n    mapping(address => bool) _freezeState;\n\n\n    // Constructor\n    constructor(\n        address payable minter) public {\n        \n        name   = \"VGNA Token\";\n        description = \"Virtual Geospatial Networking Asset\";\n        symbol = \"VGNA\";\n        decimals = 18;\n        _internalCap = 25000000;\n        _softCap     = 50000000;\n        \n        _bonusEnds = now + 3 days;\n        _endDate = now + 1 weeks;\n            \n        _owner = minter;\n        _balances[_owner] = _internalCap;  \n        _totalSupply = _internalCap;\n        emit Transfer(address(0), _owner, _internalCap);\n    }\n\n    modifier IcoSuccessful {\n        require(now >= _endDate);\n        require(_totalSupply >= _softCap);\n        _;\n    }\n\n\n    // Total supply\n    function totalSupply() public view returns (uint) {\n        return _totalSupply - _balances[address(0)];\n    }\n\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return _balances[tokenOwner];\n    }\n    \n    function isFreezed(address tokenOwner) public view returns (bool freezed) {\n        return _freezeState[tokenOwner];\n    }\n\n\n    // Transfer the balance from token owner's account to `to` account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    function transfer(address to, uint256 tokens) public IcoSuccessful returns (bool success) {\n        require(_freezeState[msg.sender] == false);\n        \n        _balances[msg.sender] = safeSub(_balances[msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    \n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account\n    function approve(address spender, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    //\n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the `from` account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    function transferFrom(address from, address to, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[from] == false && _freezeState[to] == false);\n        \n        _balances[from] = safeSub(_balances[from], tokens);\n        _allowed[from][msg.sender] = safeSub(_allowed[from][msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        require(_freezeState[spender] == false);\n        return _allowed[tokenOwner][spender];\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account. The `spender` contract function\n    // `receiveApproval(...)` is then executed\n    function approveAndCall(address spender, uint tokens, bytes memory data) public IcoSuccessful returns (bool success) {\n        require(_freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, _owner, data);\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // 1 VGNA Tokens per 1 Wei\n    function buy() public payable {\n    \n        require(msg.value >= 1 finney);\n        require(now >= _startDate && now <= _endDate);\n\n        uint256 weiValue = msg.value;\n        uint256 tokens = 0;\n        \n        if (now <= _bonusEnds) {\n            tokens = safeMul(weiValue, 2);\n        } else {\n            tokens = safeMul(weiValue, 1);\n        }\n        \n        _freezeState[msg.sender] = true;\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        _owner.transfer(msg.value);\n    }\n    \n    function () payable external {\n        buy();\n    }\n\n    function burn(uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[msg.sender] >= tokens);   // Check if the sender has enough\n        address burner = msg.sender;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function burnFrom(address account, uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[account] >= tokens);   // Check if the sender has enough\n        address burner = account;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function freeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = true;\n        return true;\n    }\n    \n    function unfreeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = false;\n        return true;\n    }\n    \n    function mint(uint256 tokens) public onlyOwner returns (bool success)\n    {\n        require(now >= _startDate && now <= _endDate);\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        return true;\n    }\n\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(_owner, tokens);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a AquaTools smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: This smart contract, named AquaTools, is an ERC1155 token with integrated ownership and supply tracking features, designed for both presale and public sale phases of unique digital assets with a capped quantity. It initializes with a predefined price, maximum supply, and a reserved quantity for the contract's owner, allowing adjustments to sale statuses, price, and token metadata via owner-exclusive functions. Additionally, it supports secure presale participation through a Merkle proof verification mechanism for whitelisted addresses, and governs the minting process with constraints on the number of tokens mintable per transaction, ensuring adherence to the overall supply limit.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nContract Structure Overview:\n- Token Attributes: Include ERC1155 token metadata and define attributes such as price, maxSupply, supplyLeft, reservedSupply, presaleActive, saleActive, presaleMaxMintsPerTrans, and publicMaxMintsPerTrans.\n- Merkle Whitelisting: Incorporate a merkleRoot for validating presale eligibility through Merkle proofs, ensuring a secure and transparent whitelist mechanism.\n- Whitelist Tracking: Use a mapping (whitelistClaimed) to track addresses that have claimed their presale tokens.\n\nFunctionality Requirements:\n1. Initialization: Initialize the contract by minting reserved tokens to the owner and updating the supply accordingly.\n2. Presale and Sale Management: Methods to toggle the status of the presale and the public sale, allowing the contract owner to start or stop token sales.\n3. Pricing and Metadata: Functions for the owner to update the token price, the URI for token metadata, and the Merkle root for presale eligibility verification.\n4. Withdrawal: Enable the contract owner to withdraw the contract's balance, ensuring secure handling of funds collected from token sales.\n5. Token Queries: Include view functions to retrieve the contract's balance, token price, remaining supply, and the total supply of tokens.\n\nSafety Considerations:\n- Implement access control for administrative functions (onlyOwner) to prevent unauthorized modifications.\n- Validate sale states (presaleActive, saleActive) and enforce minting limits (presaleMaxMintsPerTrans, publicMaxMintsPerTrans) during token purchase to uphold sale rules.\n- Use require statements to check for correct ETH amounts sent, presale whitelist eligibility, and supply constraints to ensure transactions meet all conditions for minting.\n\nImplementation Details:\n- Presale Minting: Detail the process for presale minting, including verifying the Merkle proof against the merkleRoot, ensuring the account hasn't already claimed, and enforcing the presale minting limit.\n- Public Minting: Describe the minting function accessible during the public sale phase, checking for active sale status, positive minting amounts, and compliance with the public minting limit.\n- Token Transfer Hooks: Incorporate necessary overrides for ERC1155's _beforeTokenTransfer to accommodate supply tracking and any additional token transfer logic.\n- ERC1155 Compatibility: Ensure the contract properly implements required ERC1155 and ERC1155Supply functions for compatibility with ERC1155 token standards and utilities.\n\nExamples and Resources:\n- Suggest referencing OpenZeppelin's ERC1155 and ERC1155Supply contracts for secure and standard-compliant implementations.\n- Recommend tools and platforms like Hardhat or Truffle for development, testing, and deployment, facilitating a smooth workflow for contract creation and management.\n"}, {"role": "assistant", "content": "contract AquaTools is ERC1155, Ownable, ERC1155Supply {\n    uint256 public price = 0.1 ether;\n    uint16 public maxSupply = 3000;\n    uint16 public supplyLeft = maxSupply;\n    uint8 public reservedSupply = 200;\n    bool public presaleActive;\n    bool public saleActive;\n    uint8 public presaleMaxMintsPerTrans = 1;\n    uint8 public publicMaxMintsPerTrans = 3;\n    uint8 public passIndex = 0;\n    bytes32 public merkleRoot =\n        0x9492a15aa69d55a18e1181ac3b84b971ef9799e23b284f144961474af08621d9;\n\n    mapping(address => bool) public whitelistClaimed;\n\n    constructor()\n        ERC1155(\"ipfs://QmTF8cSSv5Ewexo4TMU8Wg1MqEwXHfLVxYkuhy7GzwSU6U\")\n    {\n        _mint(msg.sender, passIndex, reservedSupply, \"\");\n\n        supplyLeft -= reservedSupply;\n    }\n\n    // Write functions\n\n    function setPresaleStatus(bool _presaleActive) public onlyOwner {\n        presaleActive = _presaleActive;\n    }\n\n    function setSaleStatus(bool _saleActive) public onlyOwner {\n        saleActive = _saleActive;\n    }\n\n    function setPrice(uint256 _price) public onlyOwner {\n        price = _price;\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    function setURI(string memory newuri) public onlyOwner {\n        _setURI(newuri);\n    }\n\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    // Read functions\n\n    function hasToken(address account) public view returns (bool) {\n        return balanceOf(account, passIndex) > 0;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return price;\n    }\n\n    function getSupplyLeft() public view returns (uint16) {\n        return supplyLeft;\n    }\n\n    function getMaxSupply() public view returns (uint16) {\n        return maxSupply;\n    }\n\n    function getMerkleRoot() public view returns (bytes32) {\n        return merkleRoot;\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // Mint\n\n    function mintPresale(\n        address account,\n        uint8 amount,\n        bytes32[] calldata _merkleProof\n    ) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(presaleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(!whitelistClaimed[msg.sender], \"Address has already claimed\");\n        require(amount <= presaleMaxMintsPerTrans, \"Only 1 mint allowed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(account));\n        require(\n            MerkleProof.verify(_merkleProof, merkleRoot, leaf),\n            \"Invalid proof\"\n        );\n\n        _mint(account, passIndex, amount, \"\");\n        whitelistClaimed[msg.sender] = true;\n\n        supplyLeft -= amount;\n    }\n\n    function mint(address account, uint8 amount) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(saleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(amount <= publicMaxMintsPerTrans, \"Only 3 mints allowed\");\n\n        _mint(account, passIndex, amount, \"\");\n\n        supplyLeft -= amount;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155, ERC1155Supply) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a KOK_Contract smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The KOK_Contract is an Ethereum-based ERC20 token with a predefined total supply of 5 billion units (accounting for 18 decimal places), named \"KOK Coin,\" featuring mechanisms for owner-driven airdrops, contract operational control, and blacklist management. It allows the contract owner to initiate or halt token transfers, manage a blacklist to prevent certain addresses from participating in transactions, and distribute tokens via airdrop to a specified list of recipients under operational conditions. Essential ERC20 functions are implemented with added checks against a blacklist for both senders and receivers, and operations can be paused or resumed by the owner, underlining a layer of administrative control over the contract's functionality.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nContract Structure Overview:\n- Token Information: Define immutable properties like symbol, name, decimals, and totalSupply.\n- Operational Control: Implement a boolean stopped to manage the contract's operational state (e.g., paused or active).\n- Blacklisting Mechanism: Introduce a mapping (blackList) to track blacklisted addresses, which are restricted from participating in transactions.\n- Balance and Allowances: Utilize mappings for tracking balances (balances) and allowances (allowed).\n\nFunctionality Requirements:\n1. Initialization: Initialize the contract by assigning the total supply to the deployer's balance.\n2. Airdrop Functionality: Develop an airdrop function to distribute tokens to multiple addresses, ensuring no address receives tokens more than once.\n3. Blacklist Management: Provide functions to add or remove addresses from the blacklist (blacklisting, deleteFromBlacklist), emitting corresponding events.\n4. Operational Control: Implement methods to stop (stop) and start (start) contract operations, affecting all transactional functions.\n5. Transaction Restrictions: Modify standard ERC20 transfer and transferFrom functions to reject transactions involving blacklisted addresses, with appropriate event logging.\n6. ERC20 Compliance: Ensure full compliance with the ERC20 standard, implementing balanceOf, transfer, approve, allowance, and their corresponding events.\n\nSafety Considerations:\n- Use require statements to enforce function preconditions like sufficient balances, non-blacklisted addresses, and operational status.\n- Protect critical functions (airdrop, blacklisting, deleteFromBlacklist, stop, start) with the onlyOwner modifier to restrict access to the contract owner.\n- Validate array lengths and ensure consistency in the airdrop function to prevent indexing errors.\n\nImplementation Details:\n- Airdrop Implementation: Iterate through recipient addresses, checking for prior token receipt before transferring the specified amounts.\n- Blacklist Checks: In transfer and transferFrom, add checks against blackList to either proceed with the transaction or reject and emit an appropriate event.\n- Operational Pause/Resume: Use the notStopped modifier for transactional functions to check the stopped state, allowing actions only when the contract is active.\n- Event Logging: Define and emit events (Blacklisted, DeleteFromBlacklist, RejectedPaymentToBlacklistedAddr, RejectedPaymentFromBlacklistedAddr) to provide transparency and traceability for blacklist-related actions and rejected transactions.\n\nExamples and Resources:\n- Consult OpenZeppelin's libraries for secure and tested implementations of ERC20 functions and access control patterns.\n- Reference Ethereum's ERC20 token standard documentation for details on function specifications and event definitions.\n"}, {"role": "assistant", "content": "contract KOK_Contract is ERC20Interface, Owned {\r\n\tstring public constant symbol = \"KOK\";\r\n\tstring public constant name = \"KOK Coin\";\r\n\tuint8 public constant decimals = 18;\r\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\r\n\r\n\tbool public stopped;\r\n\r\n\tmapping (address => int8) public blackList;\r\n\r\n\tmapping (address => uint256) public balances;\r\n\tmapping (address => mapping (address => uint256)) public allowed;\r\n\r\n\r\n    event Blacklisted(address indexed target);\r\n    event DeleteFromBlacklist(address indexed target);\r\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\r\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\r\n\r\n\r\n\tmodifier notStopped {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n\r\n// constructor\r\n\tfunction KOKContract() public {\r\n\t\tbalances[msg.sender] = totalSupply;\r\n\t}\r\n\t\r\n// function made for airdrop\r\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\r\n\t    for(uint256 i = 0; i < _to.length; i++){\r\n\t        if(balances[_to[i]] > 0){\r\n\t            continue;\r\n\t        }\r\n\t        transfer(_to[i], _value[i]);\r\n\t    }\r\n\t}\r\n\r\n// blacklist management\r\n    function blacklisting(address _addr) onlyOwner public {\r\n        blackList[_addr] = 1;\r\n        emit Blacklisted(_addr);\r\n    }\r\n    function deleteFromBlacklist(address _addr) onlyOwner public {\r\n        blackList[_addr] = -1;\r\n        emit DeleteFromBlacklist(_addr);\r\n    }\r\n\r\n// stop the contract\r\n\tfunction stop() onlyOwner {\r\n        stopped = true;\r\n    }\r\n    function start() onlyOwner {\r\n        stopped = false;\r\n    }\r\n\t\r\n// ERC20 functions\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\r\n\t\treturn balances[_owner];\r\n\t}\r\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\r\n\t\trequire(balances[msg.sender] >= _value);\r\n\r\n\t\tif(blackList[msg.sender] > 0){\r\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(blackList[_to] > 0){\r\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[msg.sender] -= _value;\r\n\t\tbalances[_to] += _value;\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\r\n\t\trequire(balances[_from] >= _value\r\n\t\t\t&& allowed[_from][msg.sender] >= _value);\r\n\r\n\t\tif(blackList[_from] > 0){\r\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(blackList[_to] > 0){\r\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[_from] -= _value;\r\n\t\tallowed[_from][msg.sender] -= _value;\r\n\t\tbalances[_to] += _value;\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Minttk smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The Minttk contract is an ERC20 token named \"Minttk\" with a symbol \"MNT,\" total supply of 500 million tokens, and subdivides its allocation across different sectors such as crowd sale, POS mining, corporate reserve, promotion, and bounty, leaving a specific amount for remaining tokens. It includes functionalities for minting additional tokens to users' balances based on predefined criteria, such as holding period, and incorporates standard ERC20 functions with an added layer of conditions to ensure the minting process adheres to the contract's rules. Ownership controls are in place for administrative actions, including token minting and emergency contract drainage, emphasizing a centralized control mechanism over the contract's critical operations.\n\nContract Structure Overview:\n- Token Properties: Define constants for name, symbol, decimals, _totalsupply, along with variable allocations for different purposes such as crowdSale, posMining, corporateReserve, promotionBounty, and remainingToken.\n- Ownership: Utilize an owner variable to identify the contract owner.\n- Minting Mechanism: Introduce a mapping (mintingDate) to track the last minting date for each address.\n- Balance Management: Implement mappings for storing balances and allowed allowances between addresses.\n- Operational Control: Implement a stopped boolean flag to enable or disable minting.\n\nFunctionality Requirements:\n1. Initialization: Allocate the remainingToken amount to the contract deployer and establish the contract's owner.\n2. Minting Bonus: Create a mint function that allows token holders to receive a bonus percentage of their holdings if they have not minted in the last 7 days.\n3. ERC20 Standard Compliance: Ensure the contract includes standard ERC20 functions such as transfer, transferFrom, approve, and allowance, with modifications to support the minting mechanism.\n4. Blacklist Prevention: Incorporate checks in token transfer functions to prevent transactions to blacklisted addresses (0x0 address in this case).\n5. Withdrawal Mechanism: Enable the contract owner to withdraw Ethereum stored in the contract.\n\nSafety Considerations:\n- Protect sensitive functions with onlyOwner modifier to restrict access to the contract's owner.\n- Utilize SafeMath for all arithmetic operations to prevent overflow and underflow vulnerabilities.\n- Implement input validation in functions (e.g., non-zero addresses, sufficient balances) to prevent erroneous transactions and enforce minting rules.\n"}, {"role": "assistant", "content": "\ncontract Minttk is ERC20 { \n    using SafeMath for uint256;\n    string public constant name     = \"Minttk\";                    // Name of the token\n    string public constant symbol   = \"MNT\";                       // Symbol of token\n    uint8 public constant decimals  = 18;                           // Decimal of token\n    uint public _totalsupply        = 500000000 * 10 ** 18;         // 500 million total supply // muliplies dues to decimal precision\n    uint public crowdSale           = 60000000 * 10 ** 18;          // 60 million in Crowd Sale\n    uint public posMining           = 350000000 * 10 ** 18;         // 350 million in POS Mining\n    uint public corporateReserve    = 80000000 * 10 ** 18;          // 80 million in Corporate Reserve\n    uint public promotionBounty     = 10000000 * 10 ** 18;          // 10 million in Promotion & Bounty\n    uint public remainingToken      = 150000000 * 10 ** 18;         // 150 million in Remaining Token | Total Supply - POS\n    address public owner;                                           // Owner of this contract\n    mapping(address => uint256) internal mintingDate;\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    \n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    function Minttk() public {\n        balances[msg.sender] = remainingToken;\n        Transfer(0, msg.sender, remainingToken);\n    }\n    \n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalsupply;\n    }\n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    \n    // Token minting function\n    function mint() public {\n        address _customerAddress = msg.sender;\n        uint256 userBalance = balances[_customerAddress];\n        uint256 currentTs = now;\n        uint256 userMintingDate = mintingDate[_customerAddress] + 7 days;\n        require (userBalance > 0);\n        require (currentTs > userMintingDate);\n        mintingDate[_customerAddress] = currentTs;\n        uint256 _bonusAmount = SafeMath.percent(userBalance,2,100,18);\n        balances[_customerAddress] = (uint256)(balances[_customerAddress]).add(_bonusAmount);\n    }\n    \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount ) public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n  \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        \n        address _customerAddress = msg.sender;\n        uint256 currentTs = now;\n        uint256 userMintingDate = mintingDate[_customerAddress] + 7 days;\n        require (currentTs > userMintingDate);\n        \n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    // Transfer the balance from owner's account to another account\n    function transferTokens(address _to, uint256 _amount) private returns (bool success) {\n        require( _to != 0x0);       \n        require(balances[address(this)] >= _amount && _amount > 0);\n        balances[address(this)] = (balances[address(this)]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(address(this), _to, _amount);\n        return true;\n    }\n \n    function drain() external onlyOwner {\n        owner.transfer(this.balance);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a TattooSkullzSociety smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The TattooSkullzSociety smart contract is an NFT collection based on the Ethereum blockchain, adhering to ERC721 standards for unique digital assets, with a capped supply of 5000 tokens and a provision for special allowances through an allowlist mechanism. It features mechanisms to activate or deactivate public sales and allowlist sales, set prices, reserve tokens for specific purposes, and manage NFT metadata, ensuring a controlled distribution process and customizable ownership experience. Additionally, it includes administrative functions to adjust sale states, withdraw contract balances, and set provenance and base URI data, highlighting owner-exclusive controls over the contract's operational aspects.\n\nContract Structure Overview:\n- Core Properties: Implement ERC721 and ERC721Enumerable for NFT standards, along with Ownable for ownership management.\n- Sale Mechanics: Define booleans isAllowListActive and saleIsActive to manage presale and public sale states.\n- Token Limits and Pricing: Set constants for MAX_SUPPLY, MAX_PUBLIC_MINT, RESERVE_MINT, and PRICE_PER_TOKEN to control minting limits and pricing.\n- Allowlist Mechanism: Utilize a mapping (_allowList) to manage the number of tokens addresses on the allowlist can mint.\n\nFunctionality Requirements:\n1. Initialization: Initialize the NFT collection with a name and symbol upon deployment.\n2. Allowlist Management:\n    - Enable the contract owner to activate/deactivate the allowlist and set allowed mint amounts per address.\n    - Provide a function to check the number of tokens an address is eligible to mint from the allowlist.\n3. Minting Functions:\n    - Implement mintAllowList for allowlisted addresses to mint a specified number of tokens, adhering to allowlist and public minting restrictions.\n    - Create a mint function for the public sale, allowing any user to mint tokens within defined limits during the active sale period.\n4. Reserved Tokens and Withdrawal:\n    - Offer a reserve function for the owner to mint reserved tokens to the owner's address.\n    - Include a withdraw function for the owner to transfer the contract's balance (Ether) to their personal address.\n\nSafety Considerations:\n- Apply onlyOwner modifier to protect administrative functions like toggling sale states, modifying allowlist, and withdrawing funds.\n- Use require statements for validation checks in minting functions to enforce rules about sale state, mint limits, and Ether sent.\n- Ensure ERC721 and ERC721Enumerable compatibility in token transfers and interface support functions.\n\nImplementation Details:\n- Provenance Record: Incorporate a PROVENANCE variable to store a provenance hash, representing the authenticity and origin of the art collection.\n- Base URI Management: Allow the owner to update _baseURIextended for dynamic metadata storage locations, overriding the _baseURI function for token URI computations.\n- Overriding Functions:\n    - Override _beforeTokenTransfer from ERC721 and ERC721Enumerable to maintain token enumeration during transfers.\n    - Ensure supportsInterface accurately reports contract capabilities, considering both ERC721 and ERC721Enumerable.\n\nExamples and Resources:\n- Reference OpenZeppelin's contracts for ERC721, ERC721Enumerable, and Ownable to ensure secure and standard-compliant implementation.\n- Utilize development frameworks like Hardhat or Truffle for testing, deploying, and verifying the smart contract.\n"}, {"role": "assistant", "content": "\ncontract TattooSkullzSociety is ERC721, ERC721Enumerable, Ownable {\n    string public PROVENANCE;\n    string private _baseURIextended;\n\n    bool public isAllowListActive = false;\n    bool public saleIsActive = false;\n    \n    uint256 public constant MAX_SUPPLY = 5000;\n    uint256 public constant MAX_PUBLIC_MINT = 22;\n    uint256 public constant RESERVE_MINT = 222;\n    uint256 public constant PRICE_PER_TOKEN = 0.08 ether;\n\n    mapping(address => uint8) private _allowList;\n\n    constructor() ERC721(\"TattooSkullzSociety\", \"SKULLZ\") {\n    }\n\n    // Whitelist\n    function setIsAllowListActive(bool _isAllowListActive) external onlyOwner {\n        isAllowListActive = _isAllowListActive;\n    }\n\n    function setAllowList(address[] calldata addresses, uint8 numAllowedToMint) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            _allowList[addresses[i]] = numAllowedToMint;\n        }\n    }\n\n    function numAvailableToMint(address addr) external view returns (uint8) {\n        return _allowList[addr];\n    }\n\n    function mintAllowList(uint8 numberOfTokens) external payable {\n        uint256 ts = totalSupply();\n        require(isAllowListActive, \"Allow list is not active\");\n        require(numberOfTokens <= _allowList[msg.sender], \"Exceeded max available to purchase\");\n        require(numberOfTokens <= MAX_PUBLIC_MINT, \"Exceeded max token purchase\");\n        require(ts + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max tokens\");\n        require(PRICE_PER_TOKEN * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n\n        _allowList[msg.sender] -= numberOfTokens;\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, ts + i);\n        }\n    }\n\n    // Mint\n    function setSaleState(bool newState) public onlyOwner {\n        saleIsActive = newState;\n    }\n\n    function mint(uint numberOfTokens) public payable {\n        uint256 ts = totalSupply();\n        require(saleIsActive, \"Sale must be active to mint tokens\");\n        require(numberOfTokens <= MAX_PUBLIC_MINT, \"Exceeded max token purchase\");\n        require(ts + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max tokens\");\n        require(PRICE_PER_TOKEN * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, ts + i);\n        }\n    }\n\n    // Utils\n    function reserve(uint numberOfTokens) public onlyOwner {\n      uint supply = totalSupply();\n      uint i;\n      for (i = 0; i < numberOfTokens; i++) {\n          _safeMint(msg.sender, supply + i);\n      }\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function setProvenance(string memory provenance) public onlyOwner {\n        PROVENANCE = provenance;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\n        _baseURIextended = baseURI_;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a TomoeGozen smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The TomoeGozen contract, built on Ethereum, integrates ERC721A for efficient batch minting, allowing for a maximum supply of 8000 unique tokens with specific minting limits set for public and presale phases. It employs a Merkle proof verification system to securely manage whitelist access during the presale phase, ensuring only eligible addresses can mint up to a predetermined limit, and it facilitates public minting with a separate limit, alongside owner-specific minting without restrictions. Additionally, the contract features a withdraw function that divides the contract's balance among predefined roles including community multisig, owners, marketing, developers, and artists, highlighting a structured revenue distribution model.\n\nContract Structure Overview:\n- Inheritance and Utilities: Implement Ownable for ownership management, ERC721A for NFT functionalities, and ReentrancyGuard for security against re-entrancy attacks.\n- Sale Phases and Limits: Define constants for MAX_SUPPLY, PUBLIC_MINT_LIMIT, PRESALE_MINT_LIMIT, and MINT_PRICE to manage minting conditions and pricing.\n- Merkle Proof Allowlist: Utilize a merkleRoot for validating presale participants and a mapping (whitelistMints) to track individual presale mintings.\n- Sale State: Employ a saleFlag variable to toggle between inactive, presale, and public sale states.\n\nFunctionality Requirements:\n1. Base URI Management: Allow the owner to set a baseURI for metadata resolution.\n2. Sale Phase Control: Provide functions for the owner to switch between different sale phases (inactive, presale, public) using the saleFlag.\n3. Merkle Root Configuration: Enable the owner to update the merkleRoot for the presale allowlist.\n4. Public and Presale Minting:\n    - Implement a mint function for public sale phase, enforcing public mint limits and sale activation.\n    - Create a mintWhitelist function for the presale phase, requiring valid Merkle proof for participation and adhering to presale mint limits.\n5. Owner Minting: Facilitate minting directly to any address by the owner, bypassing sale phase checks and mint limits.\n6. Funds Withdrawal and Allocation:\n    - Design a withdraw function to distribute contract Ether balance among predefined addresses according to specific percentages for different roles (e.g., community, owners, marketing).\n\nSafety Considerations:\n- Protect sensitive functions with onlyOwner and nonReentrant modifiers to ensure that only the contract owner can execute them and guard against re-entrancy attacks.\n- Use require statements for validations, such as sale state, mint quantity limits, Ether sent for minting, and total supply constraints.\n\nImplementation Details:\n- Merkle Proof Verification: Utilize MerkleProof library for verifying allowlist eligibility during the presale mint phase.\n- Dynamic Sale Management: Use the saleFlag to dynamically manage which minting functions are available, depending on the sale phase.\n- Efficient Batch Minting: Leverage ERC721A's batch minting capabilities for efficient gas usage during mint operations.\n- Precise Funds Allocation: Calculate and execute Ether transfers to designated roles based on the contract's balance, ensuring accurate distribution according to the specified percentages.\n\nExamples and Resources:\n- Suggest consulting OpenZeppelin's contracts for Ownable, ReentrancyGuard, and other secure base contract implementations.\n- Recommend using tools like Hardhat for development, testing, and deployment, ensuring a robust and secure deployment process.\n"}, {"role": "assistant", "content": "\ncontract TomoeGozen is Ownable, ERC721A, ReentrancyGuard {\n    using MerkleProof for bytes32[];\n\n    uint256 public constant MAX_SUPPLY = 8000;\n    uint256 public constant PUBLIC_MINT_LIMIT = 3;\n    uint256 public constant PRESALE_MINT_LIMIT = 2;\n\n    uint256 public constant MINT_PRICE = 0.08 ether;\n\n    /// Inactive = 0; Presale = 1; Public = 2\n    uint256 public saleFlag;\n\n    bytes32 public merkleRoot;\n    string public baseURI;\n    \n    mapping(address => uint256) private whitelistMints;\n\n    constructor() ERC721A(\"Tomoe Gozen\", \"TOMOE_GOZEN\", 50, MAX_SUPPLY) {}\n\n    function verifyProof(bytes32[] calldata _proof) internal view returns (bool) {\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        return _proof.verify(merkleRoot, leaf);\n    }\n\n    function setBaseURI(string calldata _base) external onlyOwner {\n        baseURI = _base;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    function setSaleFlag(uint256 _flag) external onlyOwner {\n        saleFlag = _flag;\n    }\n\n    function setMerkleRoot(bytes32 _new) external onlyOwner {\n        merkleRoot = _new;\n    }\n\n    function mint(uint256 _quantity) external payable {\n        require(totalSupply() + _quantity <= MAX_SUPPLY, \"MINT_EXCEEDS_TOTAL_SUPPLY\");\n\n        require(saleFlag == 2, \"MINTING_PAUSED\");\n        require(_quantity > 0 && _quantity <= PUBLIC_MINT_LIMIT, \"MINT_EXCEEDS_LIMIT_ALLOWED_PER_TRANSACTION\");\n        require(MINT_PRICE * _quantity <= msg.value, \"AMOUNT_TOO_LOW\");\n        require(tx.origin == msg.sender, \"SENDER_IS_NOT_AN_EOA\");\n\n        _safeMint(msg.sender, _quantity);\n    }\n\n    function mintWhitelist(uint256 _quantity, bytes32[] calldata _proof) external payable {\n        require(totalSupply() + _quantity <= MAX_SUPPLY, \"MINT_EXCEEDS_TOTAL_SUPPLY\");\n\n        require(saleFlag == 1, \"MINTING_PAUSED\");\n        require(verifyProof(_proof), \"INVALID_MERKLE_PROOF\");\n        require(whitelistMints[msg.sender] + _quantity <= PRESALE_MINT_LIMIT, \"MINT_EXCEEDS_LIMIT_ALLOWED_FOR_WHITELIST\");\n        require(_quantity > 0 && _quantity <= PRESALE_MINT_LIMIT, \"MINT_EXCEEDS_LIMIT_ALLOWED_PER_TRANSACTION\");\n        require(MINT_PRICE * _quantity <= msg.value, \"AMOUNT_TOO_LOW\");\n\n        whitelistMints[msg.sender] += _quantity;\n\n        _safeMint(msg.sender, _quantity);\n    }\n\n    function mintOwner(uint256 _quantity, address _to) external onlyOwner {\n        require(totalSupply() + _quantity <= MAX_SUPPLY, \"MINT_EXCEEDS_TOTAL_SUPPLY\");\n\n        _safeMint(_to, _quantity);\n    }\n\n    /** ALLOCATIONS:\n     *  - Community Multisig: 30% (Signers: Bitquence, sOwner1, sOwner2 / 2 of 2 signatures)\n     *  - Owners: 33.75%\n     *  - Marketing: 11.25%\n     *  - Developpers: 22.50%\n     *  - Artist: 2.5%\n     */\n    function withdraw() external onlyOwner nonReentrant {\n        uint256 balanceDividend = address(this).balance / 100000;\n\n        (bool sComm,) = address(0x18B94d7dac879511B0f2Ee2947073b57fa11Fb08).call{value: balanceDividend * 30000}(\"\");\n        (bool sOwner1,) = address(0xEC4f373A70d5Bb5371df8A33951B898B7219f82C).call{value: balanceDividend * 16875}(\"\");\n        (bool sOwner2,) = address(0x4494949245C3C432177C66adf32e272477D6aaFc).call{value: balanceDividend * 16875}(\"\");\n        (bool sMark,) = address(0x39680E7090002731b306A8EE8Fae28072b84E586).call{value: balanceDividend * 11250}(\"\");\n        (bool sDev1,) = address(0x6e1af0E043C18eAd53A5B9886D4901Dd6B67a22f).call{value: balanceDividend * 11250}(\"\");\n        (bool sDev2,) = address(0xe0C5123B0FD1A7D94bB8D84bBAF1026B699C6dC6).call{value: balanceDividend * 11250}(\"\");\n        (bool sArt,) = address(0x62A6958E4FBff46C0ECc64E2eFDE83F75D609DD2).call{value: balanceDividend * 2500}(\"\");\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a EDE smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract for \"EDE,\" utilizing ERC20 standards with additional features supporting a token sale event, including presale and public sale phases with a hard and soft cap. The contract incorporates whitelist functionality, a time-based sale phase system, and unique token distribution mechanisms. The EDE contract is an ERC20 token with a unique ICO phase structure, designed to raise funds through a presale and two subsequent public sales, featuring a built-in whitelist mechanism for eligible participants. It includes a comprehensive fundraising mechanism that adjusts token pricing and bonuses dynamically based on the sale phase, with hard and soft cap targets predefined to guide the overall funding strategy. Additionally, the contract allocates tokens for different purposes such as ICO, team reserves, and airdrops, and implements functions for purchasing tokens, transferring ownership, and redistributing unsold tokens if the hard cap is not reached, ensuring a structured and conditional token distribution process.\n\nContract Structure Overview:\n- Core Token Attributes: Leverage ERC20Interface for token functionalities, setting symbol, name, decimals, and managing _totalSupply.\n- Sale Configuration: Define variables to manage sale phases (presaleopeningtime, firstsaleopeningtime, etc.), caps (HardCap, SoftCap, maximumCap), and track fundsRaised.\n- Access Control and Utilities: Use Owned for ownership management and SafeMath for safe arithmetic operations.\n- Whitelist and Holder Tracking: Implement mappings for whitelist eligibility and dynamically track holders for future distributions.\n\nFunctionality Requirements:\n1. Initialization: Initialize token properties, allocate initial token distributions (ICO, reserve, team, airdrop), and set the sale timeline.\n2. Whitelist Management: Enable the owner to add addresses to the whitelist, allowing them to participate in the token sale.\n3. Sale Phases and Conditions: Control token purchasing through different sale phases, with checks for opening times, funding caps, and whitelist status.\n4. Token Purchasing:\n    - Implement a function (buyTokens) to handle ETH contributions in exchange for tokens, considering the current sale phase and individual contribution limits.\n    - Utilize onlyWhileOpen modifier to restrict purchases to active sale periods and within the maximum cap.\n5. Fund Withdrawal: Create a mechanism for the owner to withdraw collected funds post-sale.\n6. Post-Sale Token Distribution: Facilitate a function to distribute remaining tokens if the hard cap is not reached, proportionally to holders or specific allocations.\n\nSafety Considerations:\n- Enforce contribution minimums and maximums to ensure fair participation and avoid spamming the sale.\n- Use require statements extensively to validate conditions like sale phase, whitelist status, contribution amounts, and total supply limits.\n- Protect sensitive functions with onlyOwner to restrict execution to the contract owner.\n\nImplementation Details:\n- Dynamic Sale Phases: Dynamically manage the sale's active phase based on the current timestamp and predefined phase start and end times.\n- Contribution Tracking: Accurately track contributions in ETH, converting them to token amounts based on the current rate and applying any applicable bonuses.\n- Token Delivery: Ensure tokens are correctly minted or transferred to contributors immediately upon purchase validation.\n- Hard and Soft Cap Logic: Implement logic to handle scenarios where the sale does not meet the hard cap, including redistributing remaining tokens.\n\nExamples and Resources:\n- Suggest referencing OpenZeppelin's contracts for secure and standard-compliant implementations of ERC20 functionalities and ownership management.\n- Highlight the importance of testing with frameworks like Hardhat or Truffle, especially for complex functionalities such as sale phase management and token distribution algorithms.\n"}, {"role": "assistant", "content": "\ncontract EDE is ERC20Interface, Owned {\n    using SafeMath for uint;\n\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n    uint private _teamsTokens;\n    uint private _reserveTokens;\n    uint256 public fundsRaised;\n    uint private maximumCap;\n    address payable wallet;\n    address [] holders;\n\n    uint256 private presaleopeningtime;\n    uint256 private firstsaleopeningtime;\n    uint256 private secondsaleopeningtime;\n    uint256 private secondsaleclosingtime;\n\n\tstring public HardCap;\n\tstring public SoftCap;\n\n\n    mapping(address => uint) balances;\n    mapping(address => bool) whitelist;\n    mapping(address => mapping(address => uint)) allowed;\n\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    modifier onlyWhileOpen {\n        require((now >= presaleopeningtime && now <= secondsaleclosingtime) && fundsRaised != maximumCap); // should be open\n        _;\n    }\n\n    // Constructor\n    constructor() public {\n        symbol = \"EDE\";\n        name = \"eden.best\";\n        decimals = 0;\n        _totalSupply = 45e7;\n        balances[address(this)] = 3375e5 * 10**uint(decimals); // 75% to ICO\n        emit Transfer(address(0),address(this), 3375e5 * 10**uint(decimals));\n        balances[address(0x687abe81c44c982394EED1b0Fc6911e5338A6421)] = 66150000 * 10**uint(decimals); // 14,7% to reserve\n        emit Transfer(address(0),address(0x687abe81c44c982394EED1b0Fc6911e5338A6421), 66150000 * 10**uint(decimals));\n        balances[address(0xd903846cF43aC9046CAE50C36ac1Aa18e630A1bB)] = 45000000 * 10**uint(decimals); // 10% to Team\n        emit Transfer(address(0),address(0xd903846cF43aC9046CAE50C36ac1Aa18e630A1bB), 45000000 * 10**uint(decimals));\n        balances[address(0x7341459eCdABC42C7493D923F5bb0992616d30A7)] = 1350000 * 10**uint(decimals); // 0,3% to airdrop\n        emit Transfer(address(0),address(0x7341459eCdABC42C7493D923F5bb0992616d30A7), 1350000 * 10**uint(decimals));\n        owner = address(0xEfA2CcE041aEB143678F8f310F3977F3EB61251E);\n        wallet = address(0xEfA2CcE041aEB143678F8f310F3977F3EB61251E);\n\t\t    HardCap = \"16875 ETH\";\n        SoftCap = \"300 ETH\";\n        maximumCap = 16875000000000000000000; // 16875 eth, written in wei here\n        presaleopeningtime = 1554120000; // 1st april 2019, 12pm\n        firstsaleopeningtime = 1555329601; // 15 april 2019, 12:00:01pm\n        secondsaleopeningtime = 1559304001; // 31 may 2019, 12:00:01pm\n        secondsaleclosingtime = 1561896001; // 30 june 2019, 12:00:01pm\n    }\n\n    // Accepts ETH\n    function () external payable {\n        buyTokens(msg.sender);\n    }\n\n    function buyTokens(address _beneficiary) public payable onlyWhileOpen {\n        _preValidatePurchase(_beneficiary, msg.value);\n        _continueTokenPurchase(_beneficiary, msg.value);\n    }\n\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view{\n        require(_beneficiary != address(0));\n        require(_weiAmount != 0);\n        require(_weiAmount >= 50000000000000000 && _weiAmount <= 1000000000000000000000); // min 0.05 ETH, max 1000 ETH\n        require(whitelist[_beneficiary]);\n    }\n\n    function _insertWhitelist(address[] memory _beneficiary) public onlyOwner{\n        for(uint256 i = 0; i< _beneficiary.length; i++)\n        {\n            if(whitelist[_beneficiary[i]] == false)\n                whitelist[_beneficiary[i]] = true;\n        }\n    }\n\n    function _continueTokenPurchase(address _beneficiary, uint256 _weiAmount) internal{\n        uint256 _tokens = _getTokenAmount(_weiAmount).div(1e18);\n        uint256 bonus = _calculateBonus();\n        _tokens = _tokens.add((_tokens.mul(bonus.mul(100))).div(10000));\n\n        fundsRaised = fundsRaised.add(_weiAmount);\n\n        _processPurchase(_beneficiary, _tokens);\n\n        wallet.transfer(_weiAmount);\n        emit TokenPurchase(address(this), _beneficiary, _weiAmount, _tokens);\n    }\n\n    function _getTokenAmount(uint256 _weiAmount) internal pure returns (uint256) {\n        uint256 rate = 2e4; // 1 eth = 20,000T\n        return _weiAmount.mul(rate);\n    }\n\n    function _calculateBonus() internal view returns (uint256){\n        if(now >= presaleopeningtime && now < firstsaleopeningtime){\n            return 30;\n        } else if(now >=firstsaleopeningtime && now <secondsaleopeningtime){\n            return 20;\n        } else if(now >= secondsaleopeningtime && now <secondsaleclosingtime){\n            return 0;\n        }\n    }\n\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n        _deliverTokens(_beneficiary, _tokenAmount);\n    }\n\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n        _transfer(_beneficiary, _tokenAmount);\n    }\n\n    function totalSupply() public view returns (uint){\n       return _totalSupply* 10**uint(decimals);\n    }\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    // Transfer the balance from token owner's account to `to` account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    function transfer(address to, uint tokens) public returns (bool success) {\n        // prevent transfer to 0x0, use burn instead\n        require(to != address(0));\n        require(whitelist[to]);\n        require(balances[msg.sender] >= tokens );\n        require(balances[to] + tokens >= balances[to]);\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        if(balances[to] == 0)\n            holders.push(to);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(msg.sender,to,tokens);\n        return true;\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account\n    function approve(address spender, uint tokens) public returns (bool success){\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender,spender,tokens);\n        return true;\n    }\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    function transferFrom(address from, address to, uint tokens) public returns (bool success){\n        require(tokens <= allowed[from][msg.sender]); //check allowance\n        require(balances[from] >= tokens);\n        require(whitelist[to]);\n        balances[from] = balances[from].sub(tokens);\n        if(balances[to] == 0)\n            holders.push(to);\n        balances[to] = balances[to].add(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        emit Transfer(from,to,tokens);\n        return true;\n    }\n    // Returns the amount of tokens approved by the owner that can be transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n    function _transfer(address to, uint tokens) internal returns (bool success) {\n        // prevent transfer to 0x0, use burn instead\n        require(to != address(0));\n        require(balances[address(this)] >= tokens );\n        require(balances[to] + tokens >= balances[to]);\n        balances[address(this)] = balances[address(this)].sub(tokens);\n        if(balances[to] == 0)\n            holders.push(to);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(address(this),to,tokens);\n        return true;\n    }\n\n    function _hardCapNotReached() external onlyOwner {\n        uint eightyPercent = (balances[address(this)].mul(80)).div(100); // 80% of remaining tokens\n        uint twentyPercent = balances[address(this)].sub(eightyPercent); // 20% of remaining tokens\n        uint share = eightyPercent.div(holders.length);\n\n        for(uint i = 0; i<holders.length; i++ ){\n            address holder = holders[i];\n            balances[holder] = balances[holder].add(share);\n            emit Transfer(address(this),holder,share);\n        }\n\n        balances[address(0x687abe81c44c982394EED1b0Fc6911e5338A6421)] = twentyPercent;\n        emit Transfer(address(this),address(0x687abe81c44c982394EED1b0Fc6911e5338A6421),twentyPercent);\n\n        balances[address(this)] = 0;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ERC721PresetMinterPauserAutoId smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create an Ethereum smart contract named \"ERC721PresetMinterPauserAutoId\" that extends ERC721 token functionality. This contract includes role-based permissions for minting and pausing token transfers, an automatic ID assignment for tokens, and a mechanism to limit and track base URI changes.\n\nContract Structure Overview:\n- Inheritance and Functionality: Leverage AccessControlEnumerable for role-based access control, ERC721Enumerable for token enumeration, ERC721Burnable for token burning, and ERC721Pausable for pausing token transfers.\n- Role Management: Define roles MINTER_ROLE and PAUSER_ROLE for minting and pausing functionalities, respectively.\n- Token ID Management: Utilize Counters.Counter for automatic token ID tracking.\n- Base URI Management: Implement logic to set and manage a base token URI with a limit on the number of times it can be reset.\n\nFunctionality Requirements:\n1. Role-Based Access Control:\n    - Grant DEFAULT_ADMIN_ROLE, MINTER_ROLE, and PAUSER_ROLE to the deployer.\n    - Ensure only accounts with MINTER_ROLE can mint new tokens and those with PAUSER_ROLE can pause or unpause the contract.\n2. Automatic Token ID Assignment:\n    - Automatically assign token IDs using a counter to maintain uniqueness, even in cases of token burning.\n3. Base URI Management:\n    - Provide a function setBaseURI to set the base URI for token metadata, restrictable to a predefined number of resets and only by those with MINTER_ROLE.\n4. Minting Functionality:\n    - Implement a mint function allowing users with MINTER_ROLE to mint new tokens to a specified address.\n5. Pause Functionality:\n    - Enable pausing and unpausing of all token transfers through pause and unpause functions, accessible only by users with PAUSER_ROLE.\n\nSafety Considerations:\n- Use require statements to enforce role permissions and operational conditions, such as base URI reset limitations.\n- Incorporate checks to ensure the contract is not paused during token transfers, minting, or other sensitive operations.\n\nImplementation Details:\n- Role-Based Permission Checks: Utilize AccessControl's role checking functions (hasRole) to guard against unauthorized actions.\n- Token ID Incrementation: Ensure token IDs are incremented correctly upon each mint to maintain sequential order and uniqueness.\n- Base URI Resets: Track the number of times the base URI has been reset and enforce a cap on this action to prevent abuse or accidental changes.\n- Overriding ERC721 Functions: Properly override functions from ERC721, ERC721Enumerable, and ERC721Pausable to integrate the contract's custom logic with inherited functionalities.\n\nExamples and Resources:\n- Reference OpenZeppelin's contracts and documentation for secure and efficient implementations of ERC721 standards and role-based access control.\n- Highlight the importance of thorough testing, especially for functions involving role permissions and token ID management, to ensure contract security and integrity.\n"}, {"role": "assistant", "content": "\ncontract ERC721PresetMinterPauserAutoId is\n    Context,\n    AccessControlEnumerable,\n    ERC721Enumerable,\n    ERC721Burnable,\n    ERC721Pausable\n{\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    Counters.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n    \n    uint8 private constant MAX_URI_RESETS_ALLOWED = 1;\n    uint8 public uriResetCount = 0;\n\n    // Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the account that deploys the contract.\n    constructor(\n        string memory name,\n        string memory symbol\n    ) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n    \n    \n    // Sets `_baseTokenURI`. Resets allowed only `MAX_URI_RESETS_ALLOWED` no of times\n    function setBaseURI(string memory baseTokenURI) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"You don't have permission to do this.\");\n        require(uriResetCount <= MAX_URI_RESETS_ALLOWED, \"Max resets allowed is breached now\");\n        _baseTokenURI = baseTokenURI;\n        uriResetCount++;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    // Creates a new token for `to`. Its token ID will be automatically assigned (and available on the emitted {IERC721-Transfer} event), and the token URI autogenerated based on the base URI passed at construction.\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    // Pauses all token transfers.\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    //  Unpauses all token transfers.\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Wallstreetbets smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The Wallstreetbets contract is an ERC20 token named \"Wallstreetbets stocks and Options trading,\" with a total supply of 65 million tokens, including 18 decimal places for fractional values. It incorporates basic ERC20 functions such as token transfers, allowances, and balance checks, alongside owner-specific functions like the ability to burn tokens to reduce the total supply and transfer contract ownership. The contract uses SafeMath for mathematical operations to prevent overflow errors, emphasizing security in token transactions and ownership management within the Ethereum blockchain ecosystem.\n\nContract Structure Overview:\n- Core Attributes: Utilize ERC20 for token functionality, setting properties like symbol, name, decimals, and _totalSupply.\n- Ownership Management: Introduce an owner address to identify the contract's owner and provide mechanisms to transfer ownership.\n- Token Balances and Allowances: Implement mappings for balances and allowed to track token distribution and delegated transfer permissions.\n\nFunctionality Requirements:\n1. Initialization:\n    - Set the contract's creator as the initial owner and allocate the entire token supply to their balance.\n    - Emit a transfer event from address 0 to the owner upon contract creation.\n2. Owner-Only Functions:\n    - Include a burntokens function to reduce the total supply, accessible only by the contract owner.\n    - Provide a transferOwnership function allowing the current owner to transfer their role and token balance to a new address.\n3. ERC20 Standard Operations:\n    - Implement totalSupply, balanceOf, transfer, transferFrom, approve, and allowance functions according to the ERC20 standard.\n    - Ensure all transfers and approvals check for valid addresses (non-zero) and sufficient balances or allowances.\n\nSafety Considerations:\n- Use SafeMath library to prevent integer overflows and underflows across all arithmetic operations.\n- Apply a onlyOwner modifier to restrict sensitive actions like burning tokens and transferring ownership to the current owner only.\n- Validate input parameters for functions, especially for address parameters, to avoid transfers to the zero address (0x0).\n\nImplementation Details:\n- Token Burning: Allow the owner to permanently remove a specified amount of tokens from the total supply, decreasing the circulating amount.\n- Ownership Transfer: Safely transfer the entire token balance of the current owner to the new owner and update the owner state variable.\n- ERC20 Compliance: Ensure the contract fully adheres to the ERC20 token standard, facilitating interoperability with wallets, exchanges, and other contracts.\n"}, {"role": "assistant", "content": "\ncontract Wallstreetbets is ERC20 {\n    using SafeMath for uint256;\n    string public constant symbol = \"Wallstreetbets\";\n    string public constant name = \"Wallstreetbets stocks and Options trading\";\n    uint public constant decimals = 18;\n    uint256 _totalSupply = 65999999 * 10 ** 18; // 65 million Total Supply including 18 decimal\n\n    // Owner of this contract\n    address public owner;\n     \n    // Balances for each account\n    mapping(address => uint256) balances;\n\n    // Owner of account approves the transfer of an amount to another account\n    mapping(address => mapping (address => uint256)) allowed;\n\n    // Functions with this modifier can only be executed by the owner\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    // Constructor\n    constructor () public {\n        owner = msg.sender;\n        balances[owner] = _totalSupply;\n        emit Transfer(0, owner, _totalSupply);\n    }\n    \n    function burntokens(uint256 tokens) public onlyOwner {\n        _totalSupply = (_totalSupply).sub(tokens);\n    }\n\n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalSupply;\n    }\n    function balanceOf(address _owner)public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount)public returns (bool ok) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n         \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount )public returns (bool ok) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    // If this function is called again it overwrites the current allowance with _value.\n    function approve(address _spender, uint256 _amount)public returns (bool ok) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n     }\n  \n    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n        \n     // In case the ownership needs to be transferred\n\tfunction transferOwnership(address newOwner) external onlyOwner\t{\n\t    uint256 x = balances[owner];\n\t    require( newOwner != 0x0);\n\t    balances[newOwner] = (balances[newOwner]).add(balances[owner]);\n\t    balances[owner] = 0;\n\t    owner = newOwner;\n\t    emit Transfer(msg.sender, newOwner, x);\n\t}\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ChubbyCherubs smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The ChubbyCherubs contract is an ERC721 token with a maximum supply limit of 1111 tokens, designed for minting and managing digital collectibles named \"Chubby Cherubs\". It features mechanisms for setting the minting price, toggling the sale state, conducting airdrops to specific addresses, and withdrawing all collected Ether to the owner's address, with price adjustments and sale status changes restricted to the contract owner. The contract includes public functions for minting tokens up to a set maximum per transaction, with safeguards to prevent exceeding the total supply and ensuring the sale is open, alongside an airdrop function for the owner to distribute tokens without payment.\n\nContract Structure Overview:\n- Inheritance and Key Properties: Utilize ERC721 for NFT functionality and Ownable for ownership management. Define constants and variables for maximum supply (MAX_CHUB), minting price, base URI, and sale state.\n- Minting and Supply Tracking: Implement a counter (mintCount) to track the number of tokens minted and enforce the collection's maximum supply limit.\n\nFunctionality Requirements:\n1. Initialization and Base URI Management:\n    - Initialize the contract with a base token URI.\n    - Provide an onlyOwner function to update the base URI as needed.\n2. Minting Price and Sale State:\n    - Allow the contract owner to set and adjust the minting price.\n    - Implement a function to toggle the sale's open/closed state, enabling or disabling public minting.\n3. Public Minting Functionality:\n    - Enable users to mint a specified number of tokens within set limits per transaction, provided the sale is open and the maximum supply has not been reached.\n    - Charge the correct amount of Ether for the number of tokens minted and enforce a maximum mint limit per transaction for non-owner minters.\n4. Airdrop Functionality:\n    - Offer an onlyOwner function to airdrop tokens to a list of addresses, ensuring the operation does not exceed the maximum supply or mint tokens to the null address.\n5. Withdrawal of Contract Funds:\n    - Implement an onlyOwner function to withdraw all Ether collected by the contract through minting operations.\n\nSafety Considerations:\n- Apply require statements to validate function inputs, such as ensuring non-zero recipient addresses, adherence to minting limits, and sufficient payment for minted tokens.\n- Prevent minting beyond the maximum supply to maintain the collection's exclusivity.\n\nImplementation Details:\n- Supply and Minting Limit Checks: Incorporate checks to ensure minting operations do not exceed MAX_CHUB and comply with per-transaction mint limits.\n- Base URI for Metadata: Override the _baseURI function to return the set base URI for token metadata resolution.\n- Event Emission: Emit an event (ChubMinted) upon successful minting of each token to facilitate tracking and verification of mint operations.\n\nExamples and Resources:\n- Reference OpenZeppelin's implementations of ERC721 and Ownable for secure and standard-compliant contract development.\n- Emphasize the importance of testing, especially for functions that handle Ether transactions and modify contract state, to ensure the contract operates securely and as intended under various scenarios.\n"}, {"role": "assistant", "content": "\ncontract ChubbyCherubs is ERC721, Ownable {\n    uint256 private mintCount = 0;\n\n    uint256 public constant MAX_CHUB = 1111;\n    uint256 public price = 70000000000000000; //0.07 Ether\n    string baseTokenURI;\n    bool public saleOpen;\n\n    event ChubMinted(uint256 totalMinted);\n\n    constructor(string memory baseURI) ERC721(\"Chubby Cherubs\", \"CHUB\") {\n        setBaseURI(baseURI);\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        baseTokenURI = baseURI;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return mintCount;\n    }\n\n    function setPrice(uint256 _newPrice) external onlyOwner {\n        price = _newPrice;\n    }\n\n    // Close sale if open, open sale if closed\n    function flipSaleState() external onlyOwner {\n        saleOpen = !saleOpen;\n    }\n\n    function withdrawAll() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function airdrop(address[] calldata _recipients) external onlyOwner {\n        uint256 supply = totalSupply();\n        require(\n            supply + _recipients.length <= MAX_CHUB,\n            \"Airdrop will exceed maximum supply of CHUB\"\n        );\n        require(_recipients.length != 0, \"Address not found\");\n        mintCount += _recipients.length;\n        for (uint256 i = 0; i < _recipients.length; i++) {\n            require(_recipients[i] != address(0), \"Airdrop to Null address\");\n            handleMint(_recipients[i], ++supply);\n        }\n    }\n\n    // mint CHUB\n    function mint(uint256 _count) external payable {\n        uint256 supply = totalSupply();\n        require(supply + _count <= MAX_CHUB, \"Exceeds maximum supply of CHUB\");\n        require(_count > 0, \"Minimum 1 CHUB has to be minted per transaction\");\n\n        if (msg.sender != owner()) {\n            require(saleOpen, \"Sale is not open yet\");\n            require(\n                _count <= 10,\n                \"Maximum 10 Chubby Cherubs can be minted per transaction\"\n            );\n            require(\n                msg.value >= price * _count,\n                \"Ether sent with this transaction is not correct\"\n            );\n        }\n\n        mintCount += _count;\n\n        for (uint256 i = 0; i < _count; i++) {\n            handleMint(msg.sender, ++supply);\n        }\n    }\n\n    function handleMint(address _to, uint256 tokenId) private {\n        _safeMint(_to, tokenId);\n        emit ChubMinted(tokenId);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a LionGame smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract for \"LionGame,\" an NFT collection based on the ERC721 standard, featuring mechanisms for free and public minting, owner-exclusive giveaways, and sale state management. This contract should allow for setting dynamic pricing, minting limits, and supply caps, alongside ensuring secure interactions through reentrancy guards.\n\nContract Structure Overview:\n- Inheritance and Key Features: Utilize ERC721Enum for token enumeration, Ownable for ownership privileges, and ReentrancyGuard for preventing reentrant calls.\n- Sale Configuration: Implement variables to manage the minting cost (cost), maximum supply (maxSupply), maximum mint amount per transaction (maxMint), and the sale status (status).\n\nFunctionality Requirements:\n1. Initialization and Metadata Management:\n    - Initialize the contract with collection name, symbol, and base URI for token metadata.\n    - Provide a function to set or update the base URI.\n2. Minting Functionality:\n    - Implement a freeMint function for minting without cost under certain conditions, like before sale activation.\n    - Create a mint function for public minting that charges Ether based on the specified cost and mint amount.\n    - Ensure minting functions respect the maximum supply and per-transaction mint limits.\n3. Administrative Functions:\n    - Allow the contract owner to mint tokens directly to a given address without cost (giveAway).\n    - Enable the owner to adjust minting cost, maximum mint amount, and the total supply cap.\n    - Provide a mechanism to toggle the sale status, enabling or disabling public minting.\n4. Withdrawal of Funds:\n    - Implement a withdrawal function for the contract owner to transfer collected Ether to their address.\n\nSafety Considerations:\n- Apply require statements to validate minting conditions, such as sale status, mint amount limits, supply caps, and sufficient payment.\n- Use the nonReentrant modifier to safeguard against reentrancy attacks in minting and withdrawal functions.\n\nImplementation Details:\n- Token URI Generation: Override the tokenURI function to concatenate the base URI with the token ID, ensuring a correct metadata endpoint for each NFT.\n- Dynamic Sale Parameters: Allow the owner to dynamically adjust key sale parameters (e.g., cost, max mint amount, sale status) to adapt to changing conditions or community feedback.\n- Supply and Minting Tracking: Utilize the totalSupply function from ERC721Enum to keep track of the current supply and ensure compliance with the minting limits and supply cap.\n\nExamples and Resources:\n- Reference OpenZeppelin's contracts for implementations of ERC721, Ownable, and ReentrancyGuard to ensure secure and standard-compliant contract functionality.\n- Highlight the importance of thorough testing for all contract functions, especially those involving Ether transfers, minting logic, and state changes, to ensure the contract performs reliably under various scenarios.\n"}, {"role": "assistant", "content": "\ncontract LionGame is ERC721Enum, Ownable, ReentrancyGuard {\n\tusing Strings for uint256;\n\tstring public baseURI;\n\t// sale settings\n\tuint256 public cost = 0.05 ether;\n\tuint256 public maxSupply = 777;\n\tuint256 public maxMint = 25;\n\tbool public status = false;\n\n\tconstructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _initBaseURI\n    ) \n    \n    ERC721(_name, _symbol){\n        setBaseURI(_initBaseURI);\n\t}\n\n\t// internal\n\tfunction _baseURI() internal view virtual returns (string memory) {\n\t    return baseURI;\n\t}\n\n    // free minting\n\tfunction freeMint(uint256 _mintAmount) public nonReentrant {\n        uint256 s = totalSupply();\n        require(!status, \"Off\" );\n        require(_mintAmount > 0, \"0\" );\n        require(_mintAmount <= maxMint, \"Too many\" );\n        require(s + _mintAmount <= maxSupply, \"Max\" );\n\n        for (uint256 i = 0; i < _mintAmount; ++i) {\n            _safeMint(msg.sender, s + i, \"\");\n\t    }\n\t    \n        delete s;\n\t}\n\n\t// public minting\n\tfunction mint(uint256 _mintAmount) public payable nonReentrant {\n        uint256 s = totalSupply();\n        require(status, \"Off\" );\n        require(_mintAmount > 0, \"0\" );\n        require(_mintAmount <= maxMint, \"Too many\" );\n        require(s + _mintAmount <= maxSupply, \"Max\" );\n        require(msg.value >= cost * _mintAmount);\n\n        for (uint256 i = 0; i < _mintAmount; ++i) {\n            _safeMint(msg.sender, s + i, \"\");\n        }\n\n        delete s;\n\t}\n\n\t// admin minting\n\tfunction giveAway(address recipient) external onlyOwner {\n        uint256 s = totalSupply();\n        require(s <= maxSupply, \"Max\" );\n        _safeMint(recipient, s, \"\" );\n        delete s;\t\n\t}\n\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: Nonexistent token\");\n        string memory currentBaseURI = _baseURI();\n        return bytes(currentBaseURI).length > 0\t? string(abi.encodePacked(currentBaseURI, tokenId.toString())) : \"\";\n\t}\n\n\tfunction setCost(uint256 _newCost) public onlyOwner {\n\t    cost = _newCost;\n\t}\n\n\tfunction setMaxMintAmount(uint256 _newMaxMintAmount) public onlyOwner {\n\t    maxMint = _newMaxMintAmount;\n\t}\n\n\tfunction setBaseURI(string memory _newBaseURI) public onlyOwner {\n\t    baseURI = _newBaseURI;\n\t}\n\n\tfunction setSaleStatus(bool _status) public onlyOwner {\n\t    status = _status;\n\t}\n\n\tfunction withdraw() public onlyOwner {\n\t    payable(msg.sender).call{value: address(this).balance}(\"\");\n\t}\n\n    function setmaxSupply(uint256 _newMaxSupply) public onlyOwner {\n\t    maxSupply = _newMaxSupply;\n\t}\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a PACFounder smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The PACFounder contract is an ERC721 token designed to mint \"PACDAO FOUNDER\" tokens with an increasing minting price mechanism, where the minimum price adjusts based on the transaction value and a predefined formula. It incorporates a unique feature where, for the first 20 tokens minted, an additional token is minted and sent to a beneficiary address, alongside the capability for the beneficiary to withdraw accumulated funds, update the beneficiary address, set individual and default token URIs. This smart contract uses a combination of payable, nonpayable, and admin functions to manage minting, pricing, and token metadata, ensuring dynamic pricing and exclusive control over key contract parameters by the beneficiary.\n\nContract Structure Overview:\n- Core Features: Leverage ERC721 for NFT functionalities, with additional logic to adjust minting price dynamically and to mint a token to a beneficiary for every public mint until a specified limit.\n- Dynamic Pricing and Minting Limit: Implement variables for the minimum minting price (minPrice), the beneficiary address (beneficiary), and a counter for the current token ID (currentId).\n\nFunctionality Requirements:\n1. Initialization and Base URI Setting:\n    - Initialize the contract with the DAO's name and symbol, and set the beneficiary address and base URI for token metadata.\n2. Minting with Dynamic Pricing:\n    - Create a mint function that allows public minting if the sent value meets or exceeds the current minimum price. Adjust the minting price based on the total amount sent by minters.\n    - Automatically mint an additional token to the beneficiary address for early mints, up to a defined limit.\n3. Administrative and Beneficiary Controls:\n    - Allow the beneficiary to withdraw contract balance, update the beneficiary address, set individual token URIs, and update the default metadata URI.\n4. Pricing Adjustment Logic:\n    - Implement logic within the minting function to increase the minimum price based on the amount sent by the minters and a predefined increment strategy.\n\nSafety Considerations:\n- Validate that the minting price meets the required minimum and adjust it based on a transparent and fair mechanism.\n- Ensure that the contract's balance withdrawal and metadata management functionalities are restricted to the beneficiary address.\n\nImplementation Details:\n- Automatic Beneficiary Minting: For the initial mints, alongside every public mint, automatically issue a token to the beneficiary address, ensuring that the beneficiary receives a portion of the total minted tokens.\n- Dynamic Price Calculation: Adjust the minting price dynamically to reflect the demand and participation in the minting process, ensuring the price is rounded to prevent fractional Wei issues.\n- Token Metadata Management: Provide functionality for the beneficiary to update the default metadata URI for new mints and to set or update metadata URIs for individual tokens.\n- Balance Withdrawal: Implement a secure withdrawal function that allows the beneficiary to transfer the contract's Ether balance to their address.\n\nExamples and Resources:\n- Reference OpenZeppelin's ERC721 implementation for secure and standard-compliant NFT functionalities.\n- Emphasize thorough testing, particularly for the dynamic pricing mechanism and administrative functions, to ensure the contract operates as expected and remains secure against potential vulnerabilities.\n"}, {"role": "assistant", "content": "\ncontract PACFounder is ERC721 {\n    // variables\n    uint256 public minPrice = 100000000000000;\n    address payable private beneficiary;\n    uint256 public currentId;\n    string defaultMetadata = \"QmcnEZQiGVzPonWS2MENbdY8DkwhWcCW7YBQNk5yHYF112\";\n\n    constructor (address payable _beneficiary) public ERC721 (\"PACDAO FOUNDER\", \"PAC-F\") {\n\t\tbeneficiary = _beneficiary;\n\t\t_setBaseURI(\"ipfs://\");\n    }\n\n    // Payable Functions\n    function mint() public payable {\n\t\trequire(msg.value >= minPrice, \"Must pay more\");\n\t\tcurrentId += 1;\n\t\t_safeMint(msg.sender, currentId);\n\t\t_setTokenURI(currentId, defaultMetadata);\n\t\tuint _target = minPrice * 1075000000000000000 / 1e18;\n\t\tif (_target - minPrice < 1e14) {\n\t\t\t_target = minPrice + 1e14;\n\t\t}\n\n\t\tif (currentId < 20) {\n\t\t\tcurrentId += 1;\n\t\t\t_safeMint(beneficiary, currentId);\n\t\t\t_setTokenURI(currentId, defaultMetadata);\n\t\t}\n\n\t\tif (msg.value > _target) {\n\t\t\tminPrice = msg.value + 1e14;\n\t\t} else {\n\t\t\tminPrice = _target;\n\t\t}\n\n\t\tminPrice = minPrice / 1e14 * 1e14;\n\t}\n\n\t// Nonpayable Functions\n\tfunction withdraw() public {\n\t\tbeneficiary.transfer(address(this).balance);\n\t}\n\n\t// Admin Functions\n\tfunction updateBeneficiary(address payable _newBeneficiary) public {\t\t\n\t\trequire(msg.sender == beneficiary);\n\t\tbeneficiary = _newBeneficiary;\n\t}\n\n\tfunction setTokenUri(uint256 _tokenId, string memory _newUri) public {\n\t\trequire(msg.sender == beneficiary);\n\t\t_setTokenURI(_tokenId, _newUri);\n\t}\n\n\tfunction setDefaultMetadata(string memory _newUri) public {\n\t\trequire(msg.sender == beneficiary);\n\t\tdefaultMetadata = _newUri;\n\t}\n\n\t// Fallback Functions\n\treceive() external payable {}\n\tfallback() external payable {}\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Cannabis1Contract smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The Cannabis1Contract is an ERC20 token named \"Cannabis1\" with the symbol \"CAN1\", designed with a fixed total supply of 15,000 tokens and incorporating 18 decimals for fractional values. It features standard ERC20 functions for token management, including transfers, allowances, and balance inquiries, alongside owner-specific functionalities like token burning to reduce the total supply. Moreover, the contract includes safety mechanisms to prevent accidental Ether transfers to the contract address, enforcing a strict token-only interaction model, and grants exclusive control over certain actions to the contract owner, such as token burning.\n\nContract Structure Overview:\n- Core Attributes: Define token properties including name, symbol, standard, decimals, and total supply using the ERC20 standard interface.\n- Ownership Management: Introduce an _contractOwner variable to identify the contract's owner and include ownership verification logic.\n- Token Balances and Approvals: Implement mappings for balances and allowed to manage token holdings and delegated spending permissions.\n\nFunctionality Requirements:\n1. Initialization:\n    - Allocate the entire initial token supply to the contract's deployer and set them as the contract owner.\n    - Set the base token properties (name, symbol, standard, decimals, total supply) upon deployment.\n2. Token Transfer and Approval Operations:\n    - Enable token holders to transfer tokens to others, approve spending by third parties, and execute transfers on behalf of others following ERC20 standards.\n3. Token Burning:\n    - Provide a function allowing token holders to permanently remove a portion of their tokens from circulation, reducing the total supply.\n4. Ownership and Access Control:\n    - Implement functions to check contract ownership and restrict certain actions (like burning tokens) to the owner only.\n5. Safety Measures:\n    - Prevent direct Ether transfers to the contract by reverting any payable transactions with an appropriate error message.\n\nSafety Considerations:\n- Use SafeMath library operations to safeguard against arithmetic overflows and underflows.\n- Validate function inputs, particularly for addresses and token amounts, to ensure they meet specified conditions (e.g., non-zero addresses, sufficient balances and allowances).\n- Implement ownership checks to restrict sensitive administrative actions to the contract owner.\n\nImplementation Details:\n- ERC20 Compliance: Ensure the contract fully adheres to the ERC20 token standard, providing reliable and standard-compliant behaviors for token transfers, approvals, and allowances.\n- Dynamic Total Supply: Adjust the token's total supply dynamically when tokens are burned, ensuring accurate tracking of circulating tokens.\n- Prevent Accidental Ether Receipt: Explicitly reject Ether transfers to the contract to safeguard against accidental loss of funds.\n- Contract Ownership: Facilitate ownership verification and transfer functionalities, ensuring secure management and potential ownership transitions.\n\nExamples and Resources:\n- Consult OpenZeppelin's ERC20 and SafeMath implementations for secure and efficient contract development.\n- Highlight the importance of comprehensive testing, especially for token transfer, approval mechanisms, and the token burn function, to ensure the contract operates securely and as intended.\n"}, {"role": "assistant", "content": "\ncontract Cannabis1Contract is ERC20 {\n    string internal _name = \"Cannabis1\";\n    string internal _symbol = \"CAN1\";\n    string internal _standard = \"ERC20\";\n    uint8 internal _decimals = 18;\n    uint256 internal _totalSupply = 15000 * 1 ether;\n    \n    address internal _contractOwner;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor () public {\n        balances[msg.sender] = totalSupply();\n        _contractOwner = msg.sender;\n    }\n    \n    // Prevents sending ETH to the contract by mistake.\n    function () external payable  {\n        revert(\"This SmartContract is not payable\");\n    }\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function standard() public view returns (string memory) {\n        return _standard;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n \n    function contractOwner() public view returns (address) {\n        return _contractOwner;\n    }\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require (_spender != address(0), \"_spender address has to be set\");\n        require (_value > 0, \"'_value' parameter has to be greater than 0\");\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_from != address(0), \"'_from' address has to be set\");\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[_from], \"Insufficient balance\");\n        require(_value <= allowed[_from][msg.sender], \"Insufficient allowance\");\n\n        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n        balances[_from] = SafeMath.sub(balances[_from], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Only owner can do that\");\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _contractOwner;\n    }\n    \n    function burn(uint256 _value) public {\n        require(_value <= balances[msg.sender]);\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        _totalSupply = SafeMath.sub(_totalSupply, _value);\n        emit Transfer(msg.sender, address(0), _value);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a SupernerdsMeta smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The SupernerdsMeta contract is an ERC721 token that incorporates several advanced features such as enumerable functionality for easy tracking of token ownership, access control for role-based permissions, and contract-wide royalties following the ERC2981 standard. It is designed with a capped total supply of 5555 tokens, from which a specific number is reserved for special holders, and it supports minting operations controlled by roles, specifically a MINTER_ROLE for issuing new tokens both for general sale and reserved allocations. The contract allows for dynamic setting of base token URI for metadata, and it includes functionality to set and update royalty information, ensuring creators or specified addresses receive a percentage of sales from secondary market transactions.\n\nContract Structure Overview:\n- Core Features: Utilize ERC721Enumerable for token enumeration, AccessControl for role-based permissions, and ERC2981ContractWideRoyalties for handling royalties.\n- Supply Management: Define variables for total supply cap (_totalCap), tokens available for sale (_availableForSale), and reserved tokens (_reserveTokens).\n- Royalty Configuration: Implement variables and functions to manage royalty information, including the recipient address and the royalty percentage.\n\nFunctionality Requirements:\n1. Initialization and Role Setup:\n    - Initialize the contract with collection name and symbol.\n    - Assign the DEFAULT_ADMIN_ROLE and MINTER_ROLE to the contract deployer.\n2. Royalty Management:\n    - Provide a function to set or update the royalty recipient and value, ensuring only an admin can execute this action.\n3. Base URI Management:\n    - Allow for setting and updating the base URI for token metadata, restricted to admin role holders.\n4. Minting Operations:\n    - Enable minting to specified addresses, with checks to prevent exceeding the total supply cap and distinguish between general sale minting and reserved minting.\n    - Ensure mint functions are accessible only by holders of the MINTER_ROLE.\n5. Supply and Cap Checks:\n    - Enforce the total supply cap and individual caps on sale and reserved tokens during the minting process.\n6. Safety Considerations:\n    - Apply require statements to enforce role permissions, non-zero addresses, and supply limits in minting functions.\n    - Use counters to safely increment token IDs and manage mint counts for both sale and reserved tokens.\n\nImplementation Details:\n- Royalty Configuration and Enforcement: Implement ERC2981 standards to set and enforce royalties on secondary sales, ensuring a fair distribution of proceeds.\n- Dynamic Minting Limits: Dynamically manage minting based on the defined caps for total supply, sale-available tokens, and reserved tokens, adjusting mint availability as necessary.\n- Interface Support: Override supportsInterface to accurately reflect the support for ERC721, AccessControl, and ERC2981 interfaces.\n- Access Control for Administrative Actions: Secure sensitive contract interactions such as setting base URI and configuring royalties behind admin and minter role checks.\n\nExamples and Resources:\n- Reference OpenZeppelin's implementations of ERC721, ERC721Enumerable, AccessControl, and ERC2981 for secure and standard-compliant contract development.\n- Highlight the importance of rigorous testing, especially for functions that modify contract state and handle Ether transactions, to ensure the contract operates securely and as intended under all conditions.\n"}, {"role": "assistant", "content": "\ncontract SupernerdsMeta is ERC721Enumerable, AccessControl, ERC2981ContractWideRoyalties {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    string public _baseTokenURI = \"\";\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    uint256 public _totalCap = 5555; //total number of tokens\n    uint256 public _availableForSale = 5154; // _totalCap - _availableForSale\n    uint256 public _reserveTokens = 401; //reserve tokens for Alpha Holders\n\n    uint256 public royaltyValue = 60000000000000000; // Royalty 6% in eth decimals\n    address public royaltyRecipient; // Royalty Recipient Main wallet (OpenSea)\n\n    uint256 public _mintedSale; // token minted in the all the sales\n    uint256 public _mintedReserved; // token minted for the alpha nerd hodlers\n\n    constructor() ERC721(\"Supernerds Meta\", \"Supernerds Meta\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(MINTER_ROLE, _msgSender());\n    }\n\n    /// @dev Sets the royalty value and recipient\n    /// @notice Only admin can call the function\n    /// @param recipient The new recipient for the royalties\n    /// @param value percentage (using 2 decimals - 10000 = 100, 0 = 0)\n    function setRoyalties(address recipient, uint256 value) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"only admin allowed\");\n        require(\n            recipient != 0x0000000000000000000000000000000000000000,\n            \"S16NFT: Royalty recipient address cannot be Zero Address\"\n        );\n        require(value > 0, \"S16NFT: invalid royalty percentage\");\n        _setRoyalties(recipient, value);\n\n        royaltyRecipient = recipient;\n        royaltyValue = value;\n    }\n\n    function cap() external view returns (uint256) {\n        return _totalCap;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, AccessControl, ERC2981Base) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    function setBaseURI(string memory baseURI) public {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\n            \"Caller is not a admin\"\n        );\n\n        _baseTokenURI = baseURI;\n    }\n\n    function mint(address _mintTo) external returns (bool) {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Caller is not a minter\");\n        require(_mintTo != address(0), \"ERC721: mint to the zero address\");\n        _tokenIds.increment();\n        uint256 totalSupply = totalSupply();\n        require(_mintedSale <= _availableForSale, \"sale minting completed\");\n        require(\n            totalSupply + 1 <= _totalCap,\n            \"Cap reached, maximum 5555 mints possible\"\n        );\n\n        _safeMint(_mintTo, _tokenIds.current());\n        _mintedSale++;\n\n        return true;\n    }\n\n    function mintReserve(address _mintTo) external returns (bool) {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Caller is not a minter\");\n        require(_mintTo != address(0), \"ERC721: mint to the zero address\");\n        _tokenIds.increment();\n        uint256 totalSupply = totalSupply();\n        require(_mintedReserved <= _reserveTokens, \"reserved sale completed\");\n        require(\n            totalSupply + 1 <= _totalCap,\n            \"Cap reached, maximum 5555 mints possible\"\n        );\n        _safeMint(_mintTo, _tokenIds.current());\n\n        _mintedReserved++;\n\n        return true;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Poolboys smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The Poolboys contract is an ERC721 token featuring a collection of 4444 uniquely identifiable tokens, with built-in mechanisms for public sale control, price setting, and withdrawal of contract funds by the owner. It incorporates a non-fungible token minting system that allows for the minting of a specified number of tokens per transaction, subject to a maximum purchase limit and the total supply cap, alongside a public sale toggle function for starting or pausing token sales. Additionally, the contract includes advanced features like setting a base URI for token metadata, reserving tokens for giveaways, and dynamically establishing a collection starting index post-sale, coupled with the ability to set a provenance hash to ensure the authenticity and origin of the artwork.\n\nContract Structure Overview:\n- Core Features: Leverage ERC721 for NFT functionalities, Ownable for ownership privileges, and ReentrancyGuard for preventing reentrant calls.\n- Sale and Collection Parameters: Implement variables for NFT price (pboyPrice), maximum purchase amount (maxPurchase), total NFTs (MAX_PBOYS), and sale state (publicSaleActive).\n- Provenance and Starting Index: Define variables for storing the collection's provenance hash (PBOY_PROVENANCE) and for calculating the starting index (collectionStartingIndex, collectionStartingIndexBlock) post-sale.\n\nFunctionality Requirements:\n1. Initial Setup and Metadata Management:\n    - Initialize the contract with the collection's name and symbol.\n    - Allow the contract owner to set the base URI for token metadata.\n2. Minting Operations:\n    - Facilitate NFT minting to a specified address, ensuring adherence to the maximum purchase limit and total supply cap.\n    - Enable public minting during the active sale period, with Ether payment validation.\n    - Reserve a specified number of NFTs for giveaways or promotional purposes by the contract owner.\n3. Sale Management:\n    - Provide a function to toggle the public sale state, enabling or disabling minting.\n4. Withdrawal of Contract Funds:\n    - Implement a secure withdrawal function for transferring the contract's Ether balance to the owner's address.\n5. Collection Starting Index and Provenance:\n    - After the sale begins, calculate the collection's starting index based on blockchain data to ensure fairness and unpredictability.\n    - Set and update the collection's provenance hash as an immutable record of the NFTs' metadata integrity.\n6. Safety Considerations:\n    - Apply require statements to enforce maximum purchase limits, total supply constraints, correct Ether payments, and valid operational states.\n    - Use the nonReentrant modifier on functions involving Ether transfers to protect against reentrancy attacks.\n\nImplementation Details:\n- Dynamic Starting Index Calculation: Calculate the starting index for the collection in a manner that remains unpredictable until after sales commence, ensuring equitable distribution.\n- Provenance Hash Setting: Securely record the provenance of the collection to maintain transparency and trust regarding the originality and integrity of the NFT metadata.\n- Base URI for Metadata: Override the _baseURI function to return the set base URI, ensuring correct resolution of NFT metadata.\n\nExamples and Resources:\n- Consult OpenZeppelin's implementations of ERC721, Ownable, and ReentrancyGuard for secure and standard-compliant contract functionalities.\n- Emphasize the importance of rigorous testing, particularly for minting functions and the dynamic calculation of the starting index, to ensure the contract behaves as expected under all conditions.\n"}, {"role": "assistant", "content": "\ncontract Poolboys is ERC721, Ownable, ReentrancyGuard {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    uint256 private collectionStartingIndexBlock;\n    uint256 public collectionStartingIndex;\n    string public PBOY_PROVENANCE = \"\";\n\n    uint256 public pboyPrice = 10000000000000000; // 0.01 ETH\n    uint256 public constant maxPurchase = 30;\n    uint256 public constant MAX_PBOYS = 4444;\n\n    bool public publicSaleActive = false;\n\n    string private _baseURIextended;\n\n    constructor() ERC721(\"Poolboys\", \"PBOY\") {}\n\n    function withdraw() external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function setPrice(uint256 newPrice) external onlyOwner {\n        pboyPrice = newPrice;\n    }\n\n    // Set base for the reveal\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\n        _baseURIextended = baseURI_;\n    }\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    // Returns the total current supply\n    function totalSupply() external view returns (uint256) {\n        return _tokenIdCounter.current();\n    }\n\n    // Pause sale if active, make active if paused\n    function flipSaleState() external onlyOwner {\n        publicSaleActive = !publicSaleActive;\n    }\n\n    function _mintToken(address _to, uint numberOfTokens) private {\n        require(numberOfTokens <= maxPurchase, \"Can only mint 30 tokens at a time\");\n        require(_tokenIdCounter.current() + numberOfTokens <= MAX_PBOYS, \"Purchase would exceed max supply\");\n\n        for(uint256 i; i < numberOfTokens; i++) {\n            uint256 tokenId = _tokenIdCounter.current();\n            if (tokenId < MAX_PBOYS) {\n                _tokenIdCounter.increment();\n                _safeMint(_to, tokenId);\n            }\n        }\n    }\n\n    // Set Poolboys aside for giveaways\n    function reserveToken(address _to, uint numberOfTokens) external onlyOwner {\n        _mintToken(_to,numberOfTokens);\n    }\n\n    // Mint Poolboys\n    function mintToken(uint numberOfTokens) external payable nonReentrant {\n        require(publicSaleActive, \"Public sale is not active\");\n        require(pboyPrice * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n        _mintToken(msg.sender,numberOfTokens);\n        if (collectionStartingIndex == 0) {\n            collectionStartingIndexBlock = block.number;\n        }\n\n    }\n\n    // Set the starting index for the collection\n    function setStartingIndices() external onlyOwner {\n\n        require(collectionStartingIndexBlock != 0, \"Starting index block must be set\");\n        require(collectionStartingIndex == 0, \"Starting index is already set\");\n\n        collectionStartingIndex = uint256(blockhash(collectionStartingIndexBlock)) % MAX_PBOYS;\n\n        if ((block.number - collectionStartingIndexBlock) > 255) {\n            collectionStartingIndex = uint256(blockhash(collectionStartingIndexBlock - 1)) % MAX_PBOYS;\n        }\n\n        if (collectionStartingIndex == 0) {\n            collectionStartingIndex++;\n        }\n    }\n\n    // Set provenance once it's calculated\n    function setProvenanceHash(string memory provenanceHash) external onlyOwner {\n        PBOY_PROVENANCE = provenanceHash;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ChromiaToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Design a smart contract named \"ChromiaToken\" that implements basic ERC20 token functionalities including ownership, balance tracking, transfers, allowances, and approvals. This contract should include mechanisms for managing the total supply of tokens, querying account balances, transferring tokens between accounts, setting spending allowances, and executing transfers on behalf of other accounts.\n\nContract Structure Overview:\n- Token Attributes: Implement core ERC20 properties such as total supply (_totalSupply), account balances (balances), and allowances (allowed).\n- Ownership: Define an owner variable to identify the contract's owner.\n- Event Declarations: Include Transfer and Approval events to notify external subscribers of token transfers and approval updates.\n\nFunctionality Requirements:\n1. Total Supply Management:\n    - Provide a function to report the total supply of tokens.\n2. Account Balance Query:\n    - Enable querying the token balance of a specific account.\n3. Transfers and Approvals:\n    - Implement a function to transfer tokens from the caller's account to another account.\n    - Allow token holders to approve a spender to transfer up to a specified number of tokens on their behalf.\n    - Facilitate transfers from an approved account to another account, ensuring the spender does not exceed their allowed limit.\n4. Allowance Checking:\n    - Provide a function to check the amount of tokens that an owner has allowed a spender to transfer.\n5. Safety Considerations:\n    - Ensure transfer and transferFrom functions check for overflows.\n    - Validate that transfer and approval amounts are greater than zero.\n    - Confirm that the transferFrom function does not allow transferring more than the allowed balance.\n\nImplementation Details:\n- Balance and Allowance Mappings: Utilize mappings to track the balance of each account and the allowance set by each token holder for approved spenders.\n- Transfer and Approval Logic: Ensure that the transfer logic accounts for sufficient balances and that the approval logic updates the allowed mapping accurately.\n- Event Logging: Emit Transfer and Approval events to log these actions on the blockchain, providing transparency and traceability.\n\nExamples and Resources:\n- Reference the ERC20 token standard documentation for details on function signatures and expected behaviors.\n- Consult Solidity documentation for guidance on mapping usage, event declaration, and function visibility.\n"}, {"role": "assistant", "content": "\ncontract ChromiaToken {\n    mapping(address => uint256) private balances;\n    mapping(address => mapping (address => uint256)) private allowed;\n    uint256 private _totalSupply = 100000000;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\n        require(balances[msg.sender] >= _amount, \"ERC20: transfer amount exceeds balance\");\n        require(_amount > 0 && balances[_to] + _amount > balances[_to], \"ERC20: Invalid amount\");\n\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\n        require(_from != address(0) && _to != address(0), \"ERC20: transfer from or to the zero address\");\n        require(balances[_from] >= _amount, \"ERC20: transfer amount exceeds balance\");\n        require(allowed[_from][msg.sender] >= _amount, \"ERC20: transfer amount exceeds allowance\");\n        require(_amount > 0 && balances[_to] + _amount > balances[_to], \"ERC20: Invalid amount\");\n\n        balances[_from] -= _amount;\n        balances[_to] += _amount;\n        allowed[_from][msg.sender] -= _amount;\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a POCTOKEN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract for \"POCTOKEN,\" an ERC20-like token with added functionality for burning tokens both by the token holder and on behalf of another account. This contract should include ERC20 standard functions such as transferring tokens, approving spenders, and checking balances and allowances, with an initial supply set at deployment.\n\nContract Structure Overview:\n- Token Attributes: Define core properties including token name, symbol, decimals, and the total supply of tokens.\n- Balance and Allowance Tracking: Implement mappings to track the token balances of each address and allowances granted to spenders.\n- Event Declarations: Include Transfer, Approval, and Burn events for logging these actions on the blockchain.\n\nFunctionality Requirements:\n1. Initial Setup:\n    - Initialize the contract with a specified initial supply, token name, and symbol.\n    - Assign the entire initial supply to the contract creator's balance.\n2. Token Transfers:\n    - Allow token holders to transfer a specified amount of their tokens to another address.\n3. Approval Mechanisms:\n    - Enable token holders to approve another address to spend a specified amount of tokens on their behalf.\n    - Implement a function for the approved spender to transfer an approved amount of tokens from the token holder's account to another account.\n4. Burning Tokens:\n    - Provide functionalities for token holders to burn (destroy) a specified amount of tokens from their own balance and for an approved spender to burn a specified amount of tokens on behalf of the token holder, reducing the total supply.\n5. Query Functions:\n    - Implement functions to query the total supply of tokens, the balance of a specific account, and the allowance a token holder has given to a spender.\n6. Safety Considerations:\n    - Validate all input parameters to prevent common contract vulnerabilities (e.g., checks for zero addresses).\n    - Ensure that token transfers, approvals, and burns only proceed under appropriate conditions (e.g., sufficient balances and allowances).\n\nImplementation Details:\n- Internal Transfer Function: Utilize an internal function to handle the logic common to both direct transfers and transfers on behalf of a spender, ensuring code reuse and simplification.\n- Adjusting Allowances: Carefully manage allowances to prevent the double-spending problem in the approval mechanism.\n- Burning and Total Supply: Accurately decrease the total supply of tokens when burning actions are executed to reflect the removal of tokens from circulation.\n\nExamples and Resources:\n- Reference the ERC20 token standard for function signatures and expected behaviors to ensure compatibility with wallets and exchanges.\n- Consult Solidity documentation for best practices on mapping usage, event logging, and function visibility to secure and optimize the contract.\n"}, {"role": "assistant", "content": "\ncontract POCTOKEN {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 8;\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    // Initializes contract with initial supply tokens to the creator of the contract\n    constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    // Internal transfer, only can be called by this contract\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != address(0x0));\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    // Send `_value` tokens to `_to` from your account\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    // Send `_value` tokens to `_to` on behalf of `_from`\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    // Set allowance for other address\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    // Set allowance for other address and notify\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n\n    // Destroy tokens\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    // Destroy tokens from other account\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        emit Burn(_from, _value);\n        return true;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a SmartGold smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract named \"SmartGold,\" simulating a simple token system. This contract should include basic functionalities such as initializing with an initial supply, assigning token metadata (name, symbol, decimals), and enabling token transfers between accounts. The contract is designed to prevent accidental Ether transfers.\n\nContract Structure Overview:\n- Token Attributes: Define properties like token standard, name, symbol, decimals, initial supply, and total supply.\n- Balance Tracking: Utilize a mapping to keep track of each address's token balance.\n- Transfer Functionality: Implement a function to allow token holders to transfer tokens to another address.\n\nFunctionality Requirements:\n1. Contract Initialization:\n    - Set initial token properties (name, symbol, decimals) and allocate the entire initial supply to the contract creator's address.\n2. Token Transfer:\n    - Enable token holders to transfer a specified amount of tokens to another address, ensuring sufficient balance and checking for overflow conditions.\n3. Prevent Ether Transfers:\n    - Reject any incoming Ether transfers to the contract to avoid accidental Ether loss.\n4. Safety Considerations:\n    - Validate transfer conditions, such as the sender's balance being sufficient and preventing overflows in the recipient's balance.\n    - Use checks to ensure that token transfers and other contract operations proceed under correct conditions.\n\nImplementation Details:\n- Token Supply Management: Accurately reflect changes in token balances and total supply as transfers occur.\n- Error Handling: Properly handle cases where operations cannot proceed, for instance, by reverting transactions when a sender has insufficient balance.\n- Ether Transfer Prevention: Implement a fallback function to reject all incoming Ether transfers, safeguarding against mistaken transactions.\n\nExamples and Resources:\n- Reference the ERC20 token standard for insights into implementing a comprehensive token system with additional functionalities like allowances and approvals.\n- Consult Solidity documentation for best practices on mappings, error handling, and preventing unintended contract interactions.\n"}, {"role": "assistant", "content": "\ncontract SmartGold {\n    // Public variables of the token\n    string public standard = 'Token 0.1';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public initialSupply;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n  \n    // Initializes contract with initial supply tokens to the creator of the contract\n    function SmartGold() {\n        initialSupply = 10000;\n        name =\"SmartGold\";\n        decimals = 2;\n        symbol = \"SMTG\";\n        \n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n        totalSupply = initialSupply;                        // Update total supply      \n    }\n\n    // Send coins\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n    }\n\n    // Called whenever someone tries to send ether to it\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a BunnyIceCream smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract named \"BunnyIceCream\" utilizing the ERC721 standard for minting unique NFTs, with integrated charity donation features, dynamic pricing, and store operational status. The contract should enable batch minting of NFTs with part of the proceeds automatically directed to specified charity wallets.\n\nContract Structure Overview:\n- Token Properties and Minting Control: Define token attributes, a counter for token IDs, and control mechanisms for batch minting.\n- Pricing and Charity Contributions: Establish variables for the public sale price and specify charity wallet addresses with corresponding donation percentages.\n- Operational Flags and Metadata Management: Implement flags to manage the store's operational status and functions to set dynamic properties such as URI prefix and pricing.\n\nFunctionality Requirements:\n1. Initialization and Configuration:\n    - Set initial parameters including token name, symbol, charity wallet addresses, charity percentages, URI prefix, initial price, and store status during contract deployment.\n2. Public Minting with Charity Donations:\n    - Allow public users to mint a specified number of NFTs within set limits, automatically transferring a portion of the proceeds to charity wallets based on defined percentages.\n3. Administrative Functions:\n    - Provide owner-exclusive functions to withdraw contract balance, adjust minting price, toggle the store's operational status, update URI prefix, and set charity wallet addresses and percentages.\n4. DAO Minting:\n    - Enable batch minting by the contract owner, bypassing public sale restrictions for promotional or operational needs.\n5. Safety Considerations:\n    - Validate operational and financial conditions before minting, such as the store being open and sufficient ETH sent with the transaction.\n    - Cap the number of NFTs mintable in a single transaction to prevent excessive gas costs and ensure equitable access during sales.\n    - Securely manage contract funds and ensure only the contract owner can modify critical settings or withdraw funds.\n\nImplementation Details:\n- Dynamic Property Management: Allow the owner to dynamically update sale prices, charity information, and operational flags to adapt to changing conditions or objectives.\n- Charity Donation Mechanism: Automatically calculate and distribute specified percentages of minting proceeds to charity wallets during the public minting process.\n- Token Metadata Customization: Utilize a base URI prefix combined with token ID and extension to dynamically generate token metadata URLs.\n\nExamples and Resources:\n- Reference OpenZeppelin's ERC721 and Ownable contracts for secure and standard-compliant implementation of NFT functionalities and ownership management.\n- Emphasize thorough testing, particularly for minting functions under different sale conditions and after updating dynamic properties, to ensure the contract functions as intended and securely handles funds.\n"}, {"role": "assistant", "content": "\ncontract BunnyIceCream is Ownable, ERC721 {\n    uint32 public currentTokenId;             // increments with each new message\n    string private _uriPrefix;                  // uri prefix\n    uint256 public publicPrice;                 // price in utility token 1e18 units\n    address public charityWallet1;\n    address public charityWallet2;\n    uint8 public charityPercentage1;\n    uint8 public charityPercentage2;\n    bool public isStoreOpen;\n\n    constructor(uint256 _initialPrice, string memory _initURIPrefix, address _charityWallet1, uint8 _charityPercentage1, address _charityWallet2, uint8 _charityPercentage2, bool _isStoreOpen) ERC721(\"Bunny Ice Cream\", \"BIC\") Ownable() {\n        currentTokenId = 0;\n        charityWallet1 = _charityWallet1;\n        charityWallet2 = _charityWallet2;\n        charityPercentage1 = _charityPercentage1;\n        charityPercentage2 = _charityPercentage2;\n        _uriPrefix = _initURIPrefix;\n        publicPrice = _initialPrice;\n        isStoreOpen = _isStoreOpen;\n    }\n\n    function mintBunnyIceCream(uint8 _number) external payable {\n        require(isStoreOpen == true, \"STORE_CLOSED\");\n        require(_number <= 10, \"TOO_MANY_MINTS\");\n\n        require(publicPrice * _number <= msg.value, \"INSUFFICIENT_ETH\");\n\n        for (uint8 i = 0; i < _number; i++) {\n            _mintBunnyIceCream();\n        }\n        payable(charityWallet1).transfer(charityPercentage1*publicPrice/100*_number);\n        payable(charityWallet2).transfer(charityPercentage2*publicPrice/100*_number);\n    }\n\n    function _mintBunnyIceCream() internal {\n        uint256 nextTokenId = _getNextTokenId();\n        _safeMint(_msgSender(), nextTokenId);\n        _incrementTokenId();\n    }\n\n    function withdraw() external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _uriPrefix;\n    }\n\n    function _getNextTokenId() private view returns (uint256) {\n        return currentTokenId + 1;\n    }\n\n    function _incrementTokenId() private {\n        currentTokenId++;\n    }\n\n    function daoMint(uint8 _number) external onlyOwner {\n        require(_number <= 10, \"TOO_MANY_MINTS\");\n\n        for (uint8 i = 0; i < _number; i++) {\n            _mintBunnyIceCream();\n        }\n    }\n\n    // need to specify in units of 1e18 \n    function setPrice(uint256 _newPrice) external onlyOwner {\n        publicPrice = _newPrice;\n    }     \n\n    function setStoreOpen(bool _newStatus) external onlyOwner {\n        isStoreOpen = _newStatus;\n    }     \n\n    function setURIPrefix(string calldata _newURIPrefix) external onlyOwner {\n        _uriPrefix = _newURIPrefix;\n    }\n\n    function setCharity1(address _newCharityAddress, uint8 _percentage) external onlyOwner {\n        charityWallet1 = _newCharityAddress;\n        charityPercentage1 = _percentage;\n    }\n\n    function setCharity2(address _newCharityAddress, uint8 _percentage) external onlyOwner {\n        charityWallet2 = _newCharityAddress;\n        charityPercentage2 = _percentage;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ZipflaxToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Construct a smart contract named \"ZipflaxToken\" that implements the ERC20 token standard. The contract includes functionalities for token distribution, balance management, token transfers, approval mechanisms, and enhanced approval operations. The initial supply is predefined, and the contract prevents accidental ETH transfers.\n\nContract Structure Overview:\n- Token Attributes: Define properties such as token symbol, name, decimal units, and the total supply of tokens.\n- Balance and Allowance Management: Utilize mappings to track the balance of each address and allowances for delegated token spending.\n- Event Declarations: Include events for transfers, approvals, and changes in approval amounts to notify external observers of significant activities.\n\nFunctionality Requirements:\n1. Initialization:\n    - Upon deployment, initialize the contract with token details (symbol, name, decimals) and allocate the entire initial supply to a specified address.\n2. Token Transfer:\n    - Enable holders to transfer a specified amount of their tokens to another address, ensuring the sender has a sufficient balance.\n3. Spending Approval:\n    - Allow token holders to authorize another address to spend a specific amount of tokens on their behalf.\n    - Implement transfer operations from an approved spender's perspective, checking against the set allowances.\n4. Approval Adjustment:\n    - Facilitate increasing or decreasing the approved amount for a spender without requiring a reset, enhancing user experience and security.\n5. Accidental ETH Transfer Prevention:\n    - Reject any direct ETH transfers to the contract, preventing accidental loss of ETH.\n6. Safety Considerations:\n    - Ensure comprehensive input validation to avoid unauthorized token creation, transfers to the zero address, and other common security pitfalls.\n    - Implement checks to prevent overflow and underflow scenarios in token arithmetic operations.\n    - Secure sensitive contract operations (like approval adjustments) against potential misuse while providing flexibility for token holders.\n\nImplementation Details:\n- ERC20 Compliance: Adhere to the ERC20 standard's specifications for token contracts, ensuring compatibility with the broader Ethereum ecosystem.\n- Enhanced Approval Logic: Incorporate functions to safely adjust allowances, addressing common pitfalls in ERC20 token contracts related to approval double-spending.\n- Operational Security: Use the Ownable contract pattern to restrict certain administrative actions to the contract owner, enhancing control and security.\n\nExamples and Resources:\n- Reference the official ERC20 token standard documentation for guidelines on implementing compliant token functionalities.\n- Utilize OpenZeppelin's contracts library for secure, tested implementations of standard contract features, including ERC20 token logic and ownership management.\n- Highlight the importance of gas optimization and security audits for contract code, especially when dealing with financial assets like tokens.\n"}, {"role": "assistant", "content": "\ncontract ZipflaxToken is ERC20Interface {\n    \n    using SafeMath for uint;\n\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    \n    // Constructor\n    function ZipflaxToken() public {\n        symbol = \"ZIX\";\n        name = \"Zipflax\";\n        decimals = 8;\n        _totalSupply = 280000000;\n        _totalSupply = _totalSupply.mul(10 ** uint(decimals));\n        balances[0xBF2B073fF018F6bF1Caee6cE716B833271C159ee] = _totalSupply;\n        emit Transfer(address(0), 0xBF2B073fF018F6bF1Caee6cE716B833271C159ee, _totalSupply);\n    }\n    \n    // Reject when someone sends ethers to this contract\n    function() public payable {\n        revert();\n    }\n    \n    // Total supply\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    // Transfer the balance from token owner's account to `to` account\n    function transfer(address to, uint tokens) public returns (bool success) {\n        require(to != address(0));\n        require(tokens > 0);\n        require(balances[msg.sender] >= tokens);\n        \n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    function approve(address spender, uint tokens) public returns (bool success) {\n        require(spender != address(0));\n        require(tokens > 0);\n        \n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        require(from != address(0));\n        require(to != address(0));\n        require(tokens > 0);\n        require(balances[from] >= tokens);\n        require(allowed[from][msg.sender] >= tokens);\n        \n        balances[from] = balances[from].sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    // Returns the amount of tokens approved by the owner that can be\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n    \n\n    // Increase the amount of tokens that an owner allowed to a spender.\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        require(_spender != address(0));\n        \n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n    \n    // Decrease the amount of tokens that an owner allowed to a spender.\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        require(_spender != address(0));\n        \n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a RMBT smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a comprehensive smart contract named \"RMBT\" based on the ERC20 token standard. This contract incorporates advanced functionalities such as supply top-up, admin roles, and owner-exclusive operations. It utilizes SafeMath for arithmetic operations to ensure security against overflow and underflow vulnerabilities.\n\nContract Structure Overview:\n- Token Attributes and Ownership: Establish token characteristics like symbol, name, decimals, and total supply. Define owner and admin roles with distinct permissions.\n- Balance and Allowance Management: Implement mappings to track each address's token balance and another for managing spending allowances between addresses.\n- Event Declarations: Include events for administrative actions, supply adjustments, admin changes, and ETH withdrawals to facilitate tracking and auditing of significant contract activities.\n\nFunctionality Requirements:\n1. Initialization:\n    - On deployment, set initial token attributes and allocate the total supply to the admin address.\n2. Supply Management:\n    - Implement a function allowing the admin to increase the token supply, updating both the total supply and the admin's balance.\n3. Admin and Owner Operations:\n    - Allow the contract owner to change the admin address and withdraw ETH from the contract.\n    - Enable the admin to transfer tokens from any address back to the admin's balance, reflecting emergency or corrective actions.\n4. ERC20 Standard Compliance:\n    - Provide standard ERC20 functionalities including balance querying, token transfers, spending approvals, and transfer on behalf.\n5. Safety Considerations:\n    - Use isOwner and isAdmin modifiers to restrict access to sensitive functions, ensuring that only authorized addresses can execute specific operations.\n    - Validate input parameters and state conditions to prevent unauthorized or unintended actions, such as transfers to the zero address or exceeding balance allowances.\n\nImplementation Details:\n- Role-Based Access Control: Clearly differentiate between owner and admin roles, specifying distinct capabilities and responsibilities for each to enhance contract governance and flexibility.\n- Dynamic Supply Adjustment: Detail the process for safely increasing the token supply, ensuring that supply adjustments are traceable and transparent through event logging.\n- Secure ETH Handling: Outline secure practices for managing ETH withdrawals by the contract owner, preventing unauthorized access to funds held within the contract.\n\nExamples and Resources:\n- Leverage the OpenZeppelin Contracts library for tested implementations of the ERC20 interface, SafeMath library, and ownership management.\n- Consult the Ethereum EIP-20 token standard documentation for specifications on expected behaviors and functionalities of ERC20 tokens.\n- Highlight best practices for contract security, especially in functions that handle external calls or manage financial assets.\n"}, {"role": "assistant", "content": "\ncontract RMBT is ERC20Interface {\n    using SafeMath for uint;\n\n    string public symbol   = \"RMBT\";\n    string public name     = \"RMBT\";\n    uint8  public decimals = 18;\n    uint _totalSupply      = 1000000000000e18;\n\n    address payable owner;\n    address admin;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    modifier isOwner() {\n        require(msg.sender == owner, \"must be contract owner\");\n        _;\n    }\n\n    modifier isAdmin() {\n        require(msg.sender == admin || msg.sender == owner, \"must be admin\");\n        _;\n    }\n\n    event Topup(address indexed _admin, uint tokens, uint _supply);\n    event ChangeAdmin(address indexed from, address indexed to);\n    event AdminTransfer(address indexed from, uint tokens);\n\n    // Constructor\n    constructor(address _admin) public {\n        owner = msg.sender;\n        admin = _admin;\n        balances[admin] = _totalSupply;\n        emit Transfer(address(0x0), admin, _totalSupply);\n    }\n\n    function topupSupply(uint tokens) external isAdmin returns (uint newSupply) {\n        _totalSupply = _totalSupply.add(tokens);\n        balances[admin] = balances[admin].add(tokens);\n        newSupply = _totalSupply;\n\n        emit Transfer(address(0x0), admin, tokens);\n        emit Topup(msg.sender, tokens, _totalSupply);\n    }\n\n    function withdrawFrom(address _address, uint tokens) external isAdmin returns(uint, uint) {\n        balances[_address] = balances[_address].sub(tokens);\n        balances[admin] = balances[admin].add(tokens);\n        emit Transfer(_address, admin, tokens);\n        emit AdminTransfer(_address, tokens);\n\n        return (balances[_address], balances[msg.sender]);\n    }\n\n    function changeAdmin(address _address) external isOwner {\n        uint _tokens = balances[admin];\n        balances[admin] = balances[admin].sub(_tokens);\n        balances[_address] = balances[_address].add(_tokens);\n\n        emit Transfer(admin, _address, _tokens);\n        emit ChangeAdmin(admin, _address);\n\n        admin = _address;\n    }\n\n    function withdrawEther(uint _amount) external isOwner {\n        owner.transfer(_amount);\n    }\n\n\n    // Total supply\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n\n    // Transfer the balance from token owner's account to `to` account\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[to]         = balances[to].add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from]            = balances[from].sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        balances[to]              = balances[to].add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    // Returns the amount of tokens approved by the owner that can be transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n    // accept ETH\n    function () external payable {\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a PixelHat smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The PixelHat contract is an ERC721 token that integrates with an ERC20 token (PIXL) for minting operations, allowing users to mint \"PixelHat\" NFTs in exchange for PIXL tokens. It sets a finite total supply of NFTs that can be minted and requires users to have enough PIXL tokens for the minting price, which is specified in the contract. Administrative functions included allow the contract owner to update the base URI for the NFT metadata, withdraw PIXL or any ERC20 tokens sent to the contract by mistake, and adjust the total supply and mint price, ensuring flexibility and control over the contract's operations and assets.\n\nContract Structure Overview:\n- Token and Supply Management: Utilize a counter for tracking NFT IDs and set parameters for total supply and minting price in PIXL tokens.\n- PIXL Token Integration: Define an interface for interacting with the PIXL ERC20 token, allowing users to mint NFTs by spending PIXL tokens.\n- Base URI for Metadata: Implement a base URI that points to the NFT metadata stored on IPFS, providing a method to update it.\n- Withdrawal and Supply Adjustment Functions: Offer administrative functions to withdraw PIXL and other ERC20 tokens, as well as to update the NFT total supply and mint price.\n\nFunctionality Requirements:\n1. Contract Initialization:\n    - Initialize with the PIXL token address, set the initial total supply of NFTs, mint price in PIXL, and base URI for metadata.\n2. Minting with PIXL Tokens:\n    - Allow users to mint NFTs by transferring the mint price amount in PIXL tokens from their account to the contract. Ensure that minting does not exceed the total supply.\n3. Query Functions:\n    - Provide functions to query the number of NFTs minted and the number of NFTs remaining.\n4. Base URI Management:\n    - Enable updating the base URI for NFT metadata to reflect changes in metadata storage or structure.\n\nSafety Considerations:\n- Ensure that minting transactions verify the user's PIXL token balance and that the contract has enough allowance to transfer PIXL tokens on the user's behalf.\n- Implement ownership checks to restrict administrative functions to the contract owner, preventing unauthorized access and manipulation.\n\nImplementation Details:\n- ERC721 and ERC20 Interaction: Detail the integration between the ERC721 NFT contract and the ERC20 PIXL token contract, emphasizing the approval and transfer mechanisms.\n- Dynamic Configuration: Describe methods for the contract owner to dynamically adjust NFT supply parameters and withdrawal functions to manage contract assets securely.\n- Metadata Flexibility: Discuss the significance of the base URI in pointing to off-chain metadata and the ability to update it for future expansions or corrections.\n\nExamples and Resources:\n- Utilize OpenZeppelin's contracts library for secure implementations of ERC721 (NFT) and ERC20 functionalities, along with ownership management.\n- Highlight the importance of testing the contract thoroughly, particularly the interactions between ERC721 and ERC20 contracts, to ensure smooth and secure minting transactions.\n- Encourage adherence to best practices in smart contract development, especially in handling external calls (like ERC20 transfers) and managing contract funds.\n"}, {"role": "assistant", "content": "\ncontract PixelHat is ERC721, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n    \n    IERC20 pixlToken;\n\n    uint256 public mintPriceInPixl;\n    uint256 public totalSupply;\n    string public baseURI;\n\n    constructor(IERC20 pixlTokenAddress) ERC721(\"PixelHat\", \"PHAT\") Ownable() {\n        pixlToken = pixlTokenAddress;\n        totalSupply = 10;\n        mintPriceInPixl = 25000 * 1e18;\n        baseURI = \"https://ipfs.io/ipfs/QmXUUXRSAJeb4u8p4yKHmXN1iAKtAV7jwLHjw35TNm5jN7/\";\n    }\n\n    // Client UI will have the user approve the ERC20 contract in order to let PixelHat transfer PIXL tokens for minting.\n    function mint() public returns (uint) {\n        uint256 pixlBalance = pixlToken.balanceOf(msg.sender);\n        require(pixlBalance >= mintPriceInPixl, \"Insufficient funds: not enough PIXL\");\n        require(_tokenIds.current() < totalSupply, \"Supply Exceeded: sold out\");\n        pixlToken.transferFrom(msg.sender, address(this), mintPriceInPixl);\n\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(msg.sender, newItemId);\n\n        return newItemId;\n    }\n\n    function amountMinted() public view returns (uint) {\n        return _tokenIds.current();\n    }\n\n    function amountUnsold() public view returns (uint) {\n        return totalSupply - _tokenIds.current();\n    }\n\n    function _baseURI() internal view virtual override returns (string memory){\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newURI) public onlyOwner {\n        baseURI = _newURI;\n    }\n\n    function withdrawPixl(uint256 _amount) public onlyOwner {\n        uint256 pixlBalance = pixlToken.balanceOf(address(this));\n        require(pixlBalance >= _amount, \"Insufficient funds: not enough PIXL\");\n        pixlToken.transfer(msg.sender, _amount);\n    }\n\n    function withdrawAllPixl() public onlyOwner {\n        uint256 pixlBalance = pixlToken.balanceOf(address(this));\n        require(pixlBalance > 0, \"No PIXL within this contract\");\n        pixlToken.transfer(msg.sender, pixlBalance);\n    }\n\n    function withdrawErc20(address erc20Contract, uint256 _amount) public onlyOwner {\n        uint256 erc20Balance = pixlToken.balanceOf(address(this));\n        require(erc20Balance >= _amount, \"Insufficient funds: not enough ERC20\");\n        IERC20(erc20Contract).transfer(msg.sender, _amount);\n    }\n\n    // Only use if adding more PixelHats to Pixelverse, followed by an extra push to IPFS\n    function updateTotalSupply(uint256 _supply) public onlyOwner {\n        totalSupply = _supply;\n    }\n\n    function updateMintPrice(uint256 _priceInPixl) public onlyOwner {\n        mintPriceInPixl = _priceInPixl;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a CrowdsaleToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a detailed smart contract named \"CrowdsaleToken\" that extends the functionality of a standard token with crowdsale capabilities. This contract allows for tokens to be sold during a crowdsale event, managed by a specific crowdsale address. It includes mechanisms for token allocation, release, and rejection, incorporating SafeMath for arithmetic operations to ensure security.\n\nContract Structure Overview:\n- Crowdsale Management: Integrate a specific address to manage the crowdsale process, ensuring only this address can initiate token sales.\n- Token Allocation: Utilize a mapping to keep track of tokens allocated to purchasers during the crowdsale, awaiting release or rejection.\n- Event Logging: Implement events for key activities including token sales, releases, rejections, and setting the crowdsale address.\n\nFunctionality Requirements:\n1. Crowdsale Address Setup:\n    - Allow the contract owner to set the address responsible for managing the crowdsale, ensuring that only this address can sell tokens to participants.\n2. Token Sale Mechanism:\n    - Facilitate the sale of tokens by the crowdsale address, recording allocated tokens in a waiting mapping and ensuring that the sale does not exceed the owner's balance.\n3. Token Release and Rejection:\n    - Provide functionalities for the contract owner to either release waiting tokens to a purchaser’s balance or reject and reset the allocation, adjusting the saled tokens accordingly.\n4. Safety Considerations:\n    - Utilize SafeMath library for all arithmetic operations to prevent overflow and underflow vulnerabilities.\n    - Include ownership and crowdsale-specific modifiers to restrict access to sensitive functions, such as token allocation and release.\n\nImplementation Details:\n- Integration with StandardToken: Detail how CrowdsaleToken extends StandardToken functionality, emphasizing ERC20 compliance and additional crowdsale features.\n- Dynamic Crowdsale Management: Describe methods for dynamically managing the crowdsale, including setting the crowdsale address and adjusting token allocations based on sale outcomes.\n- Secure Token Allocation: Discuss the importance of securely managing token allocations during the crowdsale, ensuring that tokens are neither oversold nor released without proper authorization.\n\nExamples and Resources:\n- Reference OpenZeppelin's contracts library for implementations of ERC20 tokens and ownership patterns to ensure security and compliance.\n- Highlight testing strategies for crowdsale functionalities, particularly focusing on the allocation, release, and rejection of tokens within different scenarios.\n- Encourage best practices for contract security, especially in the context of crowdsales, where financial transactions and token distributions require rigorous scrutiny.\n"}, {"role": "assistant", "content": "\ncontract CrowdsaleToken is StandardToken, Ownable {\n    using SafeMath for uint256;\n    address public crowdsale;\n    mapping (address => uint256) public waiting;\n    uint256 public saled;\n\n    event Sale(address indexed to, uint256 value);\n    event Release(address indexed to);\n    event Reject(address indexed to);\n    event SetCrowdsale(address indexed addr);\n\n    function setCrowdsale(address _addr) onlyOwner public {\n        crowdsale = _addr;\n        SetCrowdsale(_addr);\n    }\n\n    modifier onlyCrowdsale() {\n        require(crowdsale != address(0));\n        require(crowdsale == msg.sender);\n        _;\n    }\n\n    function sale(address _to, uint256 _value) public onlyCrowdsale returns (bool) {\n        require(_to != address(0));\n        assert(saled.add(_value) <= balances[owner]);\n\n        saled = saled.add(_value);\n        waiting[_to] = waiting[_to].add(_value);\n        Sale(_to, _value);\n        return true;\n    }\n\n    // send waiting tokens to customer's balance\n    function release(address _to) external onlyOwner {\n        require(_to != address(0));\n\n        uint256 val = waiting[_to];\n        waiting[_to] = 0;\n        balances[owner] = balances[owner].sub(val);\n        balances[_to] = balances[_to].add(val);\n        Release(_to);\n    }\n\n    // reject waiting token\n    function reject(address _to) external onlyOwner {\n        require(_to != address(0));\n\n        saled = saled.sub(waiting[_to]);\n        waiting[_to] = 0;\n\n        Reject(_to);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a BadBabies smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Generate an Ethereum smart contract named \"BadBabies\" utilizing the ERC721Enumerable and Ownable extensions. This contract is designed to manage a collection of unique digital assets represented as NFTs, featuring functionalities for minting, whitelist minting, transferring, and burning tokens. Additionally, the contract includes features for price setting, supply management, and base URI adjustments for metadata storage.\n\nContract Structure Overview:\n- Minting Mechanics: Incorporate both public and whitelist-based minting mechanisms, detailing the requirements for each, including pricing, sale dates, and authorization via signatures.\n- Token Management: Explain functionalities for transferring ownership of tokens, minting new tokens to specific addresses, and burning tokens to reduce supply.\n- Metadata Handling: Discuss the implementation of dynamic base URI management for token metadata, enabling seamless updates and integration with external storage solutions.\n- Supply and Pricing Adjustments: Describe methods for adjusting the total supply of tokens and modifying minting prices, emphasizing the owner's exclusive access to these functionalities.\n\nFunctionality Requirements:\n1. Minting Process:\n    - Outline the steps for minting tokens during both whitelist and public sale periods, including signature verification for whitelist participation and payment processing.\n2. Ownership and Transfer:\n    - Detail the ERC721 token transfer process, including ownership checks and updates to internal mappings tracking token ownership.\n3. Metadata Management:\n    - Explain how the contract manages token metadata through a base URI, allowing for on-the-fly updates to metadata locations and formats.\n4. Administrative Controls:\n    - Highlight owner-exclusive functions for managing the contract, such as minting tokens outside of the sale, withdrawing contract funds, adjusting supply, and changing pricing.\n\nSafety Considerations:\n- Emphasize the use of onlyOwner modifier for administrative actions to prevent unauthorized access and modifications.\n- Detail the importance of signature verification for whitelist minting to ensure participant authenticity.\n- Discuss the utilization of SafeMath and similar libraries to prevent arithmetic overflow and underflow vulnerabilities.\n\nImplementation Details:\n- ERC721 Compliance: Review the integration of ERC721Enumerable for iterating over token ownership and ensuring compliance with the ERC721 standard.\n- Signature Verification: Dive into the mechanics of Ethereum signature verification for validating whitelist participants, ensuring secure and authorized access.\n- Dynamic Content Delivery: Analyze the role of base URI in providing flexible and updateable links to token metadata, enhancing the collection's adaptability and user experience.\n\nExamples and Resources:\n- Provide examples of smart contract interactions, such as minting tokens during the whitelist period and public sale, transferring tokens between addresses, and modifying contract parameters like pricing and supply.\n- Reference relevant ERC721 and Ethereum documentation to aid in understanding contract standards and development practices.\n- Offer guidance on testing strategies for verifying contract functionalities, ensuring contract security, and optimizing gas usage.\n"}, {"role": "assistant", "content": "contract BadBabies is ERC721Enumerable, Ownable{\n    using Counters for Counters.Counter;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using Strings for uint256;\n\n    uint256 private _price = 0.04 ether;\n    uint256 private _supply = 10000;\n    uint256 private _whitelistPrice = 0.03 ether;\n    uint256 private _whitelistDate;\n    uint256 private _publicSaleDate;\n    string private _uri;\n    address private _authorizer = 0x7ACa8b1e3D01F52DF81bDD154319DB3D445cbD35;\n    mapping (address => EnumerableSet.UintSet) private _ownerBabies;\n    Counters.Counter private _babiesId;\n    \n    // Modifier check if address can buy, if public sale is open allows everyone if not checks whitelist   \n    constructor (string memory uri_) ERC721(\"Bad Babies\", \"BAD\")  {\n        _uri = uri_;\n        _whitelistDate = 1639771200;\n        _publicSaleDate = 1639771200 + 24 hours;\n        _babiesId.increment();\n    }\n    \n    // Buy and mint a new token   \n    function mintOnWhitelist(bytes memory signature) external payable {\n        require(recov(keccak256(abi.encodePacked(msg.sender)), signature) == _authorizer, \"Bad Babies: Invalid whitelist singature\");\n        require(msg.value >= _whitelistPrice, \"Bad Babies: msg.value less than price\");\n        require(_whitelistDate <= block.timestamp, \"Bad Babies: Mintin not allowed\");\n        require(_publicSaleDate > block.timestamp, \"Bad Babies: Only public sale\");\n        mint_(msg.sender);\n    }\n\n    function recov(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        return ECDSA.recover(hash, signature);\n    }\n\n    function mint() external payable {\n        require(_publicSaleDate <= block.timestamp, \"Bad Babies: Only whitelist\");\n        require(msg.value >= _price, \"Bad Babies: msg.value less than price\");\n        mint_(msg.sender);\n    }\n\n    function transfer(address to, uint256 tokenId) external {\n        _transfer(msg.sender, to, tokenId);\n    }\n\n    // Mint new token and maps to receiver    \n    function mint_(address to) private {\n        require(_babiesId.current() <= _supply, \"Bad Babies: All NFTs minted\");\n        _ownerBabies[to].add(_babiesId.current());\n        _mint(to, _babiesId.current());\n        _babiesId.increment();\n    }\n    \n    // Get token ID by owner index, useful for view owner tokens  \n    function getTokenByOwnerIndex(address owner, uint256 index) public view returns(uint256) {\n        return _ownerBabies[owner].at(index);\n    }\n\n    // Overrides ERC721 function to change owner on _ownerBabies map   \n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) override internal virtual {\n        _ownerBabies[from].remove(tokenId);\n        _ownerBabies[to].add(tokenId);\n    }\n\n\n    // Base URI getter\n \n    function _baseURI() override internal view virtual returns (string memory) {\n        return _uri;\n    }\n\n    // get token URI by token ID, adds .json extension     \n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), \".json\")) : \"\";\n    }\n\n    // Mint a new token and gift it\n    function gift(address to) external onlyOwner {\n        mint_(to);\n    }\n\n    // Burn a token\n    function burn(uint256 tokenId) external onlyOwner {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n\n    // Change Base URI can be used to reveal NFTs\n    function changeBaseURI(string memory uri_) external onlyOwner {\n        _uri = uri_;\n    }\n\n    // Withdraw ETH balance to the owner\n    function withdraw() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    // Decreases NFT supply.\n    function decreaseSupply(uint256 amount) external onlyOwner {\n        require((_supply-=amount) >= _babiesId.current());\n        _supply-=amount;\n    }\n\n    // Change token price\n    function changePrice(uint256 price_) external onlyOwner {\n        _price = price_;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a WIN12 smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a Ethereum smart contract named \"WIN12 GAME - GIGO Fair Token\" utilizing the ERC20Detailed standard. This contract aims to introduce unique mechanisms such as token burn percentages tied to transfers, special rules for specific wallets, and multi-address transfers.\n\nContract Structure Overview:\n- Tokenomics: Introduce the token economics behind WIN12, emphasizing its fixed supply, burn mechanism during transfers, and the rationale for these features.\n- Special Wallets: Elaborate on the roles of uniswapWallet and liquidityWallet, detailing their impact on the token's liquidity and exchange mechanics.\n- Burn Mechanism: Discuss the contract's approach to reducing the token supply through a burning mechanism during transfers, enhancing its scarcity and value.\n\nFunctionality Requirements:\n1. Token Transfer:\n    - Describe the process for transferring tokens, including conditions that modify transfer behaviors such as exemptions for specific wallets and the implementation of a burning mechanism during regular transfers.\n2. Multi-Address Transfer:\n    - Detail the functionality allowing the token owner to execute transfers to multiple addresses simultaneously, increasing transaction efficiency.\n3. Allowance Management:\n    - Explain the ERC20 standard's allowance system, allowing token holders to permit another address to spend a specified amount of tokens on their behalf.\n\nSafety and Security Considerations:\n- Highlight the significance of meticulously managing uniswapWallet and liquidityWallet to prevent unauthorized access and ensure the token's liquidity.\n- Discuss the importance of setting a reasonable burnPercent to maintain a balance between token scarcity and the holders' ability to transact without excessive deflation.\n- Outline common security measures and audits necessary for contracts with advanced features and financial implications, ensuring the safety of stakeholders' investments.\n\nImplementation Details:\n- Burn Mechanism Integration: Review how the contract calculates the token amount to burn for each transfer and the impact of this mechanism on the token's total supply.\n- Special Wallet Rules: Dive into the logic that exempts uniswapWallet and liquidityWallet from certain transfer rules, supporting the token's exchange and liquidity.\n- ERC20Detailed Compliance: Outline the contract's adherence to the ERC20Detailed standard, ensuring compatibility with Ethereum wallets and exchanges while adding custom token properties.\n\nExamples and Resources:\n- Provide code snippets demonstrating key functionalities such as token transfer with a burning mechanism, multi-address transfers, and allowance management.\n- Reference documentation for ERC20 and ERC20Detailed standards to facilitate a deeper understanding of basic and extended token functionalities.\n- Suggest tools and platforms for testing and deploying the smart contract, emphasizing the importance of security audits and community reviews before launch.\n"}, {"role": "assistant", "content": "contract WIN12 is ERC20Detailed {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    address uniswapWallet = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address liquidityWallet = 0xFC8B42aC9133EF1E9e6645b9b023f15A060f167B;\n\n    string constant tokenName = \"WIN12 GAME - GIGO Fair Token\";\n    string constant tokenSymbol = \"WIN12\";\n    uint8  constant tokenDecimals = 12;\n    uint256 _totalSupply = 12000000000000;\n    uint256 public burnPercent = 1200;\n  \n    constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function getburningPercent(uint256 value) public view returns (uint256)  {\n        uint256 roundValue = value.ceil(burnPercent);\n        uint256 burningPercent = roundValue.mul(burnPercent).div(10000);\n        return burningPercent;\n    }\n \n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[msg.sender]);\n        require(to != address(0));\n        if (msg.sender == uniswapWallet || msg.sender == liquidityWallet || to == liquidityWallet || to == uniswapWallet ){\n            uint256 tokenTransfer = value;\n            \n            _balances[msg.sender] = _balances[msg.sender].sub(value);\n            _balances[to] = _balances[to].add(tokenTransfer);\n            \n            emit Transfer(msg.sender, to, tokenTransfer);\n            return true;\n        } else {\n            if (value > 1200000000000) {\n                revert();\n            }\n\n        uint256 tokensToBurn = getburningPercent(value);\n        uint256 tokensForTransfer = value.sub(tokensToBurn);\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(tokensForTransfer);\n\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        emit Transfer(msg.sender, to, tokensForTransfer);\n        emit Transfer(msg.sender, address(0), tokensToBurn);\n        return true;\n        }\n    }\n\n    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n        for (uint256 i = 0; i < receivers.length; i++) {\n            transfer(receivers[i], amounts[i]);\n        }\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n    \n    \n     \n        if  (msg.sender == liquidityWallet || from == liquidityWallet){\n            _balances[from] = _balances[from].sub(value);\n                uint256 tokenTransfer = value;\n            _balances[to] = _balances[to].add(tokenTransfer);\n\n            _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n            emit Transfer(from, to, tokenTransfer);\n\n            return true;\n        } else {\n            _balances[from] = _balances[from].sub(value);\n            uint256 tokensToBurn = getburningPercent(value);\n                uint256 tokensForTransfer = value.sub(tokensToBurn);\n\n            _balances[to] = _balances[to].add(tokensForTransfer);\n\n            _totalSupply = _totalSupply.sub(tokensToBurn);\n\n            _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n            emit Transfer(from, to, tokensForTransfer);\n            emit Transfer(from, address(0), tokensToBurn);\n\n            return true;\n        }\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(amount != 0);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= _balances[account]);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[account] = _balances[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external {\n        require(amount <= _allowed[account][msg.sender]);\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);\n        _burn(account, amount);\n    }\n}\n"}]
