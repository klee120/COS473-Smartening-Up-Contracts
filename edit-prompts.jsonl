[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a XYZZ smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: You are tasked with generating an Ethereum smart contract for a token named XYZZ. This token is an ERC20 compliant digital asset with added functionalities to support initial coin offering (ICO) stages, including bonus periods, a soft cap, and account freezing capabilities for security.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nContract Structure Overview:\n- Token Information: Your contract should declare basic token attributes such as symbol, name, description, and decimals.\n- ICO Stages: Include variables to manage ICO stages, like `_startDate`, `_bonusEnds`, `_endDate`, `_internalCap`, and `_softCap`.\n- State Variables: Define mappings for storing balances (`_balances`), allowances (`_allowed`), and account freeze states (`_freezeState`).\n\nFunctionality Requirements:\n1. Constructor: Initialize the contract with token information, ICO parameters, and allocate initial tokens to the minter's account.\n2. ICO Constraints: Implement a modifier IcoSuccessful to check conditions for certain functions (e.g., token transfers post-ICO completion and achieving the soft cap).\n3. Balance and Transfers: Include functions for querying balances (balanceOf), transferring tokens (transfer, transferFrom), and managing allowances (approve, allowance).\n4. Freezing Accounts: Provide functionality to freeze and unfreeze accounts to prevent transfers during the ICO or due to security reasons.\n5. Token Minting and Burning: Allow the contract owner to mint new tokens or burn existing tokens from their balance or specified accounts.\n6. Bonus Mechanism: During the ICO, implement a method for purchasing tokens that awards bonus tokens if purchased during the bonus period.\n7. ERC20 Compliance: Ensure the contract adheres to the ERC20 standard for token contracts.\n\nSafety Considerations:\n- Use SafeMath for all arithmetic operations to protect against overflow and underflow.\n- Ensure only the contract owner can mint, burn, freeze, or unfreeze tokens.\n- Validate all user inputs and enforce checks on token transfers, especially when modifying allowances or executing transfers from and to accounts.\n\nImplementation Details:\n- Token Initialization: Start with defining the contract's metadata and ICO parameters within the constructor.\n- Function Implementations: Carefully implement each function, adhering to the ERC20 standard and custom business logic as outlined. Pay attention to security checks, such as verifying ICO success or account freeze status before proceeding with certain operations.\n- Event Logging: Emit appropriate events for token transfers, approval changes, and other significant actions for transparency and traceability.\n\nExamples and Resources:\n- Refer to OpenZeppelin contracts for secure implementation examples, especially for ERC20 functionality and SafeMath operations.\n- Consult the Ethereum EIP-20 token standard documentation for compliance requirements and function specifications.\n"}, {"role": "assistant", "content": "\ncontract XYZZ is ERC20Interface, Owned, SafeMath {\n    string public symbol;\n    string public name;\n    string public description;\n    uint8 public decimals;    \n    uint private _startDate;\n    uint private _bonusEnds;\n    uint private _endDate;\n    \n    uint256 private _internalCap;\n    uint256 private _softCap;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) _balances;\n    mapping(address => mapping(address => uint256)) _allowed;\n    mapping(address => bool) _freezeState;\n\n\n    // Constructor\n    constructor(\n        address payable minter) public {\n        \n        name   = \"VGNA Token\";\n        description = \"Virtual Geospatial Networking Asset\";\n        symbol = \"VGNA\";\n        decimals = 18;\n        _internalCap = 25000000;\n        _softCap     = 50000000;\n        \n        _bonusEnds = now + 3 days;\n        _endDate = now + 1 weeks;\n            \n        _owner = minter;\n        _balances[_owner] = _internalCap;  \n        _totalSupply = _internalCap;\n        emit Transfer(address(0), _owner, _internalCap);\n    }\n\n    modifier IcoSuccessful {\n        require(now >= _endDate);\n        require(_totalSupply >= _softCap);\n        _;\n    }\n\n\n    // Total supply\n    function totalSupply() public view returns (uint) {\n        return _totalSupply - _balances[address(0)];\n    }\n\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return _balances[tokenOwner];\n    }\n    \n    function isFreezed(address tokenOwner) public view returns (bool freezed) {\n        return _freezeState[tokenOwner];\n    }\n\n\n    // Transfer the balance from token owner's account to `to` account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    function transfer(address to, uint256 tokens) public IcoSuccessful returns (bool success) {\n        require(_freezeState[msg.sender] == false);\n        \n        _balances[msg.sender] = safeSub(_balances[msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    \n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account\n    function approve(address spender, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    //\n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the `from` account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    function transferFrom(address from, address to, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[from] == false && _freezeState[to] == false);\n        \n        _balances[from] = safeSub(_balances[from], tokens);\n        _allowed[from][msg.sender] = safeSub(_allowed[from][msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        require(_freezeState[spender] == false);\n        return _allowed[tokenOwner][spender];\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account. The `spender` contract function\n    // `receiveApproval(...)` is then executed\n    function approveAndCall(address spender, uint tokens, bytes memory data) public IcoSuccessful returns (bool success) {\n        require(_freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, _owner, data);\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // 1 VGNA Tokens per 1 Wei\n    function buy() public payable {\n    \n        require(msg.value >= 1 finney);\n        require(now >= _startDate && now <= _endDate);\n\n        uint256 weiValue = msg.value;\n        uint256 tokens = 0;\n        \n        if (now <= _bonusEnds) {\n            tokens = safeMul(weiValue, 2);\n        } else {\n            tokens = safeMul(weiValue, 1);\n        }\n        \n        _freezeState[msg.sender] = true;\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        _owner.transfer(msg.value);\n    }\n    \n    function () payable external {\n        buy();\n    }\n\n    function burn(uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[msg.sender] >= tokens);   // Check if the sender has enough\n        address burner = msg.sender;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function burnFrom(address account, uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[account] >= tokens);   // Check if the sender has enough\n        address burner = account;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function freeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = true;\n        return true;\n    }\n    \n    function unfreeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = false;\n        return true;\n    }\n    \n    function mint(uint256 tokens) public onlyOwner returns (bool success)\n    {\n        require(now >= _startDate && now <= _endDate);\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        return true;\n    }\n\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(_owner, tokens);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a AquaTools smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: This smart contract, named AquaTools, is an ERC1155 token with integrated ownership and supply tracking features, designed for both presale and public sale phases of unique digital assets with a capped quantity. It initializes with a predefined price, maximum supply, and a reserved quantity for the contract's owner, allowing adjustments to sale statuses, price, and token metadata via owner-exclusive functions. Additionally, it supports secure presale participation through a Merkle proof verification mechanism for whitelisted addresses, and governs the minting process with constraints on the number of tokens mintable per transaction, ensuring adherence to the overall supply limit.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nContract Structure Overview:\n- Token Attributes: Include ERC1155 token metadata and define attributes such as price, maxSupply, supplyLeft, reservedSupply, presaleActive, saleActive, presaleMaxMintsPerTrans, and publicMaxMintsPerTrans.\n- Merkle Whitelisting: Incorporate a merkleRoot for validating presale eligibility through Merkle proofs, ensuring a secure and transparent whitelist mechanism.\n- Whitelist Tracking: Use a mapping (whitelistClaimed) to track addresses that have claimed their presale tokens.\n\nFunctionality Requirements:\n1. Initialization: Initialize the contract by minting reserved tokens to the owner and updating the supply accordingly.\n2. Presale and Sale Management: Methods to toggle the status of the presale and the public sale, allowing the contract owner to start or stop token sales.\n3. Pricing and Metadata: Functions for the owner to update the token price, the URI for token metadata, and the Merkle root for presale eligibility verification.\n4. Withdrawal: Enable the contract owner to withdraw the contract's balance, ensuring secure handling of funds collected from token sales.\n5. Token Queries: Include view functions to retrieve the contract's balance, token price, remaining supply, and the total supply of tokens.\n\nSafety Considerations:\n- Implement access control for administrative functions (onlyOwner) to prevent unauthorized modifications.\n- Validate sale states (presaleActive, saleActive) and enforce minting limits (presaleMaxMintsPerTrans, publicMaxMintsPerTrans) during token purchase to uphold sale rules.\n- Use require statements to check for correct ETH amounts sent, presale whitelist eligibility, and supply constraints to ensure transactions meet all conditions for minting.\n\nImplementation Details:\n- Presale Minting: Detail the process for presale minting, including verifying the Merkle proof against the merkleRoot, ensuring the account hasn't already claimed, and enforcing the presale minting limit.\n- Public Minting: Describe the minting function accessible during the public sale phase, checking for active sale status, positive minting amounts, and compliance with the public minting limit.\n- Token Transfer Hooks: Incorporate necessary overrides for ERC1155's _beforeTokenTransfer to accommodate supply tracking and any additional token transfer logic.\n- ERC1155 Compatibility: Ensure the contract properly implements required ERC1155 and ERC1155Supply functions for compatibility with ERC1155 token standards and utilities.\n\nExamples and Resources:\n- Suggest referencing OpenZeppelin's ERC1155 and ERC1155Supply contracts for secure and standard-compliant implementations.\n- Recommend tools and platforms like Hardhat or Truffle for development, testing, and deployment, facilitating a smooth workflow for contract creation and management.\n"}, {"role": "assistant", "content": "contract AquaTools is ERC1155, Ownable, ERC1155Supply {\n    uint256 public price = 0.1 ether;\n    uint16 public maxSupply = 3000;\n    uint16 public supplyLeft = maxSupply;\n    uint8 public reservedSupply = 200;\n    bool public presaleActive;\n    bool public saleActive;\n    uint8 public presaleMaxMintsPerTrans = 1;\n    uint8 public publicMaxMintsPerTrans = 3;\n    uint8 public passIndex = 0;\n    bytes32 public merkleRoot =\n        0x9492a15aa69d55a18e1181ac3b84b971ef9799e23b284f144961474af08621d9;\n\n    mapping(address => bool) public whitelistClaimed;\n\n    constructor()\n        ERC1155(\"ipfs://QmTF8cSSv5Ewexo4TMU8Wg1MqEwXHfLVxYkuhy7GzwSU6U\")\n    {\n        _mint(msg.sender, passIndex, reservedSupply, \"\");\n\n        supplyLeft -= reservedSupply;\n    }\n\n    // Write functions\n\n    function setPresaleStatus(bool _presaleActive) public onlyOwner {\n        presaleActive = _presaleActive;\n    }\n\n    function setSaleStatus(bool _saleActive) public onlyOwner {\n        saleActive = _saleActive;\n    }\n\n    function setPrice(uint256 _price) public onlyOwner {\n        price = _price;\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    function setURI(string memory newuri) public onlyOwner {\n        _setURI(newuri);\n    }\n\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    // Read functions\n\n    function hasToken(address account) public view returns (bool) {\n        return balanceOf(account, passIndex) > 0;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return price;\n    }\n\n    function getSupplyLeft() public view returns (uint16) {\n        return supplyLeft;\n    }\n\n    function getMaxSupply() public view returns (uint16) {\n        return maxSupply;\n    }\n\n    function getMerkleRoot() public view returns (bytes32) {\n        return merkleRoot;\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // Mint\n\n    function mintPresale(\n        address account,\n        uint8 amount,\n        bytes32[] calldata _merkleProof\n    ) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(presaleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(!whitelistClaimed[msg.sender], \"Address has already claimed\");\n        require(amount <= presaleMaxMintsPerTrans, \"Only 1 mint allowed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(account));\n        require(\n            MerkleProof.verify(_merkleProof, merkleRoot, leaf),\n            \"Invalid proof\"\n        );\n\n        _mint(account, passIndex, amount, \"\");\n        whitelistClaimed[msg.sender] = true;\n\n        supplyLeft -= amount;\n    }\n\n    function mint(address account, uint8 amount) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(saleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(amount <= publicMaxMintsPerTrans, \"Only 3 mints allowed\");\n\n        _mint(account, passIndex, amount, \"\");\n\n        supplyLeft -= amount;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155, ERC1155Supply) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n}"}]
