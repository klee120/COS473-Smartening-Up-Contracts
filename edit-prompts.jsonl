{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Molokiwie smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create an Ethereum-based NFT minting smart contract named Molokiwie that adheres to the ERC721Enumerable and Ownable standards. This contract allows the owner to mint unique digital assets, manage minting costs, toggle the minting process on or off, and set metadata URIs for individual tokens and the contract itself. Additionally, the contract should enable the withdrawal of funds accumulated through minting operations.\n\nContract Specifications:\n- Inherits ERC721Enumerable for NFT enumeration and Ownable for ownership management.\n- Implements features such as minting control, dynamic pricing, and metadata management.\n- Utilizes Ethereum's native currency (ETH) for transactions.\n\nKey Functionalities:\n1. Minting Control: Allows the contract owner to enable or disable the NFT minting function to control the supply.\n2. Dynamic Pricing: The owner can adjust the cost per NFT minted to respond to market demands or strategic pricing adjustments.\n3. Metadata Management: Enables setting and updating the base URI for token metadata and the contract's metadata, facilitating dynamic content management.\n4. Funds Withdrawal: Allows the contract owner to withdraw the balance accumulated from minting fees, ensuring secure and exclusive access to the funds.\n\nImplementation Details:\n- Minting Process: The mint function enables users to mint a specified number of NFTs given they meet the prerequisites, such as minting being enabled, the minimum quantity requirement, and sufficient ETH to cover the cost.\n- Access Control: Utilizes the onlyOwner modifier from the Ownable contract to restrict certain functions, like pausing minting, setting costs, and withdrawing funds, to the contract owner.\n- Metadata URIs: The contract stores separate URIs for token metadata and contract metadata, which can be updated by the owner, providing flexibility in managing how NFTs and the contract are presented externally.\n- Error Handling: Implements checks and requires statements to validate function calls, ensuring operations like minting and withdrawing funds are executed under defined conditions.\n\nSecurity Considerations:\n- Reentrancy Guard: Consider implementing reentrancy guards for functions that transfer ETH to prevent reentrancy attacks.\n- Validation Checks: Ensure all user inputs and state-changing operations are correctly validated (e.g., mint amount, ETH sent for minting) to prevent exploits.\n- Access Control: The onlyOwner modifier is crucial for functions that could impact the contract's integrity and financial state. It's essential to ensure the ownership is securely managed.\n"}, {"role": "assistant", "content": "contract Molokiwie is ERC721Enumerable, Ownable { \n    uint256 public cost;\n    bool public paused;\n    string public tokenURIPrefix;\n    string public contractURIPrefix;\n\n    constructor() ERC721(\"MOLOKIWIE\", \"MOLOKIWIE\") {\n        pause(false);\n        setCost(20000000 gwei); //0.02 eth\n        setTokenURI(\"https://gateway.pinata.cloud/ipfs/QmPhtzrqnJ6ozr98JbVxWvac4anj6ViQeaCwTHBuAYmQU3\");\n        setContractURI(\"https://gateway.pinata.cloud/ipfs/QmR6cvG9F35yRKRn8QPfRX8cGhm3Ez27E3Z7uEu1jdTBVt\");\n    }\n\n    function mint(uint256 _mintAmount) public payable {\n        require(canMint(_mintAmount, msg.value), \"Can't mint\");\n        uint256 supply = totalSupply();\n        for (uint i; i < _mintAmount; ++i ) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    function setCost(uint256 _newCost) public onlyOwner {\n        cost = _newCost;\n    }\n\n    function canMint(uint256 _mintAmount, uint256 ethValue) public view returns (bool) {\n        require(!paused, \"Minting is paused\");\n        require(_mintAmount > 0, \"Need to mint at least 1 NFT\");\n        require(ethValue >= cost * _mintAmount, \"Insufficient funds\");\n        \n        return true;\n    }\n\n    function setTokenURI(string memory _tokenURIPrefix) public onlyOwner {\n        tokenURIPrefix = _tokenURIPrefix;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n        return tokenURIPrefix;\n    }\n\n    function setContractURI(string memory _contractURIPrefix) public onlyOwner {\n        contractURIPrefix = _contractURIPrefix;\n    }\n\n    function contractURI() public view returns (string memory) {\n        return contractURIPrefix;\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(os, \"Can't withdraw\");\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a TWOToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract named TWOToken implementing the ERC20Interface, along with an ownership management system through OwnerHelper. The contract introduces a custom token with features like token locking/unlocking for addresses, transfer restrictions, and mechanisms for the initial distribution of tokens to a founder. Additionally, it provides functions for token locking management and the ability to permanently destroy the contract.\n\nContract Specifications:\n- Implements ERC20 standard functionalities for token management.\n- Incorporates OwnerHelper for ownership-related actions.\n- Utilizes SafeMath for secure mathematical operations.\n- Features include token lock management, address whitelisting, and ERC20 standard operations.\n\nKey Functionalities:\n1. Token Information: The contract stores token-related data such as name, decimals, and symbol, defining the token's basic characteristics.\n2. Ownership and Token Supply: Establishes a founder address receiving the initial total token supply and integrates ownership management for critical administrative functions.\n3. Locking Mechanism: Introduces a system to lock or unlock the token transfer capabilities for specific addresses, enhancing security and compliance.\n4. ERC20 Compliance: Implements standard ERC20 functions for token transfers, balance inquiries, allowances, and approval mechanisms, ensuring interoperability with the broader Ethereum ecosystem.\n\nImplementation Details\n- Initial Setup: During contract creation, initial token attributes are set, and the total supply is allocated to the founder's address.\n- Transfer Restrictions: Incorporates a notLocked modifier to check if tokens are transferable by the sender, applying various conditions including owner privileges and address-specific locking status.\n- Lock Management: Offers functions for the contract owner to lock or unlock addresses, enabling or disabling their ability to transfer tokens.\n- ERC20 Functions: Detailed implementation of transfer, approve, allowance, and transferFrom methods adhering to the ERC20 standard, with added checks for the locking status.\n- Destruction Capability: Allows the contract owner to permanently destroy the contract, sending all remaining funds to the owner's address.\n\nSecurity Considerations\n- SafeMath: Utilizes SafeMath library to prevent overflow and underflow vulnerabilities in arithmetic operations.\n- Ownership Controls: Critical actions like locking tokens, updating lock status, and contract destruction are guarded with onlyOwner checks to prevent unauthorized access.\n- Locking Mechanism: The token lock feature should be carefully managed to ensure it does not inadvertently hinder the token's liquidity and transferability among rightful holders.\n"}, {"role": "assistant", "content": "contract TWOToken is ERC20Interface, OwnerHelper {\n    using SafeMath for uint;\n    \n    string public name;\n    uint public decimals;\n    string public symbol;\n\n    // Founder\n    address private founder;\n    \n    // Total\n    uint public totalTokenSupply;\n\n    mapping (address => uint) public balances;\n    mapping (address => mapping ( address => uint )) public approvals;\n    mapping (address => bool) private whiteAddresses; // Lock : false, unLock : true\n    \n    bool public tokenLock = false;\n\n    // Token Total\n    uint constant private E18 = 1000000000000000000;\n\n    constructor(address _founder, uint _totalTokenSupply) public {\n        name = \"two#\";\n        decimals = 18;\n        symbol = \"TO1\";\n\n        founder = _founder;\n        totalTokenSupply  = _totalTokenSupply * E18;\n        balances[founder] = totalTokenSupply;\n        emit Transfer(0x0, founder, totalTokenSupply);\n    }\n\n    modifier notLocked {\n        require(isTransferable() == true);\n        _;\n    }\n\n    function lock(address who) onlyOwner public {\n        whiteAddresses[who] = false;\n    }\n    \n    function unlock(address who) onlyOwner public {\n        whiteAddresses[who] = true;\n    }\n    \n    function isLocked(address who) public view returns(bool) {\n        return whiteAddresses[who];\n    }\n\n    function totalSupply() view public returns (uint) {\n        return totalTokenSupply;\n    }\n    \n    function balanceOf(address _who) view public returns (uint) {\n        return balances[_who];\n    }\n    \n    function transfer(address _to, uint _value) notLocked public returns (bool) {\n        require(balances[msg.sender] >= _value);\n        \n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        \n        emit Transfer(msg.sender, _to, _value);\n        \n        return true;\n    }\n    \n    function approve(address _spender, uint _value) notLocked public returns (bool){\n        require(balances[msg.sender] >= _value);\n        \n        approvals[msg.sender][_spender] = _value;\n        \n        emit Approval(msg.sender, _spender, _value);\n        \n        return true; \n    }\n    \n    function allowance(address _owner, address _spender) view public returns (uint) {\n        return approvals[_owner][_spender];\n    }\n\n    function transferFrom(address _from, address _to, uint _value) notLocked public returns (bool) {\n        require(balances[_from] >= _value);\n        require(approvals[_from][msg.sender] >= _value);\n        \n        approvals[_from][msg.sender] = approvals[_from][msg.sender].sub(_value);\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to]  = balances[_to].add(_value);\n        \n        emit Transfer(_from, _to, _value);\n        \n        return true;\n    }\n        \n    function isTransferable() private view returns (bool) {\n        if (tokenLock == false) {\n            return true;\n        }\n        else {\n          if(msg.sender == owner) {\n            return true;\n          }\n\n          if (whiteAddresses[msg.sender]) // true is unLocked {\n              return true;\n          }\n        }\n        return false;\n    }\n    \n    function setTokenUnlock() onlyOwner public {\n        require(tokenLock == true);\n        \n        tokenLock = false;\n    }\n    \n    function setTokenLock() onlyOwner public {\n        require(tokenLock == false);\n        \n        tokenLock = true;\n    }\n    \n    function close() onlyOwner public {\n        selfdestruct(msg.sender);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a XappCoin smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop an Ethereum smart contract named XappCoin that implements the ERC20 standard and includes ownership management. The contract introduces a cryptocurrency called XappCoin (XAPP) with a fixed supply, mechanisms for distributing tokens through ICOs, airdrops, and developer allocations. It also features dynamic token pricing throughout various ICO phases, the ability to withdraw collected funds, and functions for distributing tokens to specific addresses.\n\nContract Specifications:\n- Inherits ERC20 for token functionality and Owned for ownership management.\n- Uses SafeMath for safe mathematical operations to prevent overflow.\n- Defines constants for token name (XappCoin), symbol (XAPP), and decimals (18).\n- Sets a fixed total supply of tokens and allocates percentages for ICO, airdrops, and developer incentives.\n- Implements ERC20 functions with additional checks and custom distribution logic.\n\nKey Functionalities:\n1. Fixed Supply & Allocation: Sets a fixed total supply with predefined allocations for ICO sales, airdrops, and developer incentives.\n2. ICO and Token Sale Mechanics: Details the distribution of tokens through various sale phases (presale, ICO1, ICO2, etc.) with specific start times and ETH-to-token conversion rates.\n3. Airdrop and Developer Distribution: Specialized functions to distribute tokens for airdrops and to developer addresses, controlling the flow and allocation of tokens.\n4. Token Pricing and Adjustments: Mechanisms to update the tokens-per-ETH rate dynamically based on the phase of the ICO.\n5. Withdrawal and Burn Functions: Allows the withdrawal of ETH collected during the sale and the burning of tokens to reduce the supply.\n\nImplementation Details:\n- Initial Setup: Upon deployment, the contract allocates the total supply among the ICO, airdrop, and developer addresses based on predefined percentages.\n- Distribution Flags and Times: Utilizes flags to mark the opening and closing of the ICO, alongside timestamps to manage different sale phases.\n- Dynamic Token Pricing: Adjusts token pricing for each phase of the ICO, allowing for flexible investment opportunities.\n- Custom Distribution Functions: Includes methods for distributing tokens to private sale participants, airdrop recipients, and developers, ensuring each group receives their allotted share.\n- Security Measures: Implements checks for transaction amounts, sale phases, and ensures functions can only be called by the owner or authorized addresses.\n\nSecurity Considerations:\n- SafeMath Usage: Ensures arithmetic operations are secure and free from overflows and underflows.\n- Ownership and Access Control: Critical functions are protected by ownership checks to prevent unauthorized access.\n- Validation of Contributions: Checks for minimum contributions and valid phases ensure that transactions are processed correctly.\n- Mitigation of Common Vulnerabilities: Includes protections against reentrancy, short address attacks, and ensures proper handling of ERC20 tokens.\n"}, {"role": "assistant", "content": "contract XappCoin is ERC20, Owned {\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\t\t\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;    \n\n    string public constant name = \"XappCoin\";\n    string public constant symbol = \"XAPP\";\n    uint public constant decimals = 18;\n    \n    uint256 public totalSupply =  160000000000000000000000000;\n    uint256 public totalDistributed = 0; \n    uint256 public totalIcoDistributed = 0;\n    uint256 public constant minContribution = 1 ether / 100; // 0.01 Eth\n\t\n\t\n\tuint256 public tokensPerEth = 0;\n\t\n    // Token Distribution and Address\n    \n    // saleable 90%\n    uint256 public constant totalIco = 144000000000000000000000000;\n    uint256 public totalIcoDist = 0;\n    address storageIco = owner;\n\n    // airdrop 5%\n    uint256 public constant totalAirdrop = 8000000000000000000000000;\n    address private storageAirdrop = 0x9EF2b3c9D297342Cad1EEae796D1BE3e804A30F9;\n\n    // developer 5%\n    uint256 public constant totalDeveloper = 8000000000000000000000000;\n    address private storageDeveloper = 0x4E9084cB8B30CAD65f1210Ec7CCcED1F1a5F2D78;\n    \n    // sale start  price and bonus\n    \n    // presale\n\tuint public presaleStartTime = 1544979600; // Monday, 20 January 2020 00:00:00 GMT+07:00\n    uint256 public presalePerEth = 1000000000000000000000;\n    \n    // ico\n    uint public icoStartTime = 1546189200; // Thursday, 5 March 2020 00:00:00 GMT+07:00\n    uint256 public icoPerEth = 1000000000000000000000;\n    \n    // ico1\n    uint public ico1StartTime = 1547398800; // Sunday, 19 April 2020 00:00:00 GMT+07:00\n    uint256 public ico1PerEth = 1000000000000000000000;\n    \n    \n    // ico2\n    uint public ico2StartTime = 1548608400; // Wednesday, 3 June 2020 00:00:00 GMT+07:00\n    uint256 public ico2PerEth = 1000000000000000000000;\n    \n    \n    //ico start and end\n    uint public icoOpenTime = presaleStartTime;\n    uint public icoEndTime = 1610298000; // Thursday, 9 July 2019 00:00:00 GMT+07:00\n\t\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n    \n    event Burn(address indexed burner, uint256 value);\n\t\n\tevent Sent(address from, address to, uint amount);\n\t\n    bool public icoOpen = false; \n    bool public icoFinished = false;\n    bool public distributionFinished = false;\n\n    uint256 public tTokenPerEth = 0;\n    uint256 public tAmount = 0;\n    uint i = 0;\n    bool private tIcoOpen = false;\n    \n    constructor() public {        \n        balances[owner] = totalIco;\n        balances[storageAirdrop] = totalAirdrop;\n        balances[storageDeveloper] = totalDeveloper;       \n    }\n    \n    function totalSupply() public constant returns (uint) {\n        return totalSupply  - balances[address(0)];\n    }\n\n    modifier canDistr() {\n        require(!distributionFinished);\n        _;\n    }\n\t\n\tfunction startDistribution() onlyOwner canDistr public returns (bool) {\n        icoOpen = true;\n        presaleStartTime = now;\n        icoOpenTime = now;\n        return true;\n    }\n    \n    function finishDistribution() onlyOwner canDistr public returns (bool) {\n        distributionFinished = true;\n        icoFinished = true;\n        emit DistrFinished();\n        return true;\n    }\n    \n    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n        totalDistributed = totalDistributed.add(_amount);        \n        balances[_to] = balances[_to].add(_amount);\n        balances[owner] = balances[owner].sub(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n\n        return true;\n    }\n\t\n\tfunction send(address receiver, uint amount) public {\n        if (balances[msg.sender] < amount) return;\n        balances[msg.sender] -= amount;\n        balances[receiver] += amount;\n        emit Sent(msg.sender, receiver, amount);\n    }\n    \n   \n    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        \n        tokensPerEth = _tokensPerEth;\n        emit TokensPerEthUpdated(_tokensPerEth);\n    }\n           \n    function () external payable {\n\t\t\t\t\n\t\t// owner withdraw \n\t\tif (msg.sender == owner && msg.value == 0) {\n\t\t\twithdraw();\n\t\t}\n\t\t\n\t\tif (msg.sender != owner){\n\t\t\tif ( now < icoOpenTime ){\n\t\t\t\trevert('ICO does not open yet');\n\t\t\t}\n\t\t\t\n\t\t\t//is Open\n\t\t\tif (( now >= icoOpenTime ) && ( now <= icoEndTime )) {\n\t\t\t\ticoOpen = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (now > icoEndTime) {\n\t\t\t\ticoOpen = false;\n\t\t\t\ticoFinished = true;\n\t\t\t\tdistributionFinished = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (icoFinished == true) {\n\t\t\t\trevert('ICO has finished');\n\t\t\t}\n\t\t\t\n\t\t\tif (distributionFinished == true) {\n\t\t\t\trevert('Token distribution has finished');\n\t\t\t}\n\t\t\t\n\t\t\tif (icoOpen == true ) {\n\t\t\t\tif (now >= presaleStartTime && now < icoStartTime){ tTokenPerEth = presalePerEth; }\n\t\t\t\tif (now >= icoStartTime && now < ico1StartTime){ tTokenPerEth = icoPerEth; }\n\t\t\t\tif (now >= ico1StartTime && now < ico2StartTime){ tTokenPerEth = ico1PerEth; }\n\t\t\t\tif (now >= ico2StartTime && now < icoEndTime){ tTokenPerEth = ico2PerEth; }\n\t\t\t\t\n\t\t\t\ttokensPerEth = tTokenPerEth;\t\t\t\t\n\t\t\t\tgetTokens();\n\t\t\t}\n\t\t}\n     }\n    \n    function getTokens() payable canDistr  public {\n        uint256 tokens = 0;\n\n        require( msg.value >= minContribution );\n        require( msg.value > 0 );\n        \n        tokens = tokensPerEth.mul(msg.value) / 1 ether;\n        address investor = msg.sender;\n        \n        if (icoFinished == true) {\n\t\t\trevert('ICO Has Finished');\n\t\t}\n        \n        if (balances[owner] < tokens){\n\t\t\trevert('Insufficient Token Balance or Sold Out.');\n\t\t}\n        \n        if (tokens < 0) {\n\t\t\trevert();\n\t\t}\n        \n        totalIcoDistributed += tokens;\n        \n        if (tokens > 0) {\n           distr(investor, tokens);           \n        }\n\n        if (totalIcoDistributed >= totalIco) {\n            distributionFinished = true;\n        }\n    }\n\t\n\t\n    function balanceOf(address _owner) constant public returns (uint256) {\n        return balances[_owner];\n    }\n\n    // mitigates the ERC20 short address attack\n    modifier onlyPayloadSize(uint size) {\n        assert(msg.data.length >= size + 4);\n        _;\n    }\n    \n    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n        \n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n\n        require(_to != address(0));\n        require(_amount <= balances[_from]);\n        require(_amount <= allowed[_from][msg.sender]);\n        \n        balances[_from] = balances[_from].sub(_amount);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    \n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        // mitigates the ERC20 spend/approval race condition\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n    \n    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n        AltcoinToken t = AltcoinToken(tokenAddress);\n        uint bal = t.balanceOf(who);\n        return bal;\n    }\n    \n    function withdraw() onlyOwner public {\n        address myAddress = this;\n        uint256 etherBalance = myAddress.balance;\n        owner.transfer(etherBalance);\n    }\n    \n    function burn(uint256 _amount) onlyOwner public {\n        balances[owner] = balances[owner].sub(_amount);\n        totalSupply = totalSupply.sub(_amount);\n        totalDistributed = totalDistributed.sub(_amount);\n        emit Burn(owner, _amount);\n    }\n    \n    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {\n        AltcoinToken token = AltcoinToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n    \n    function dist_privateSale(address _to, uint256 _amount) onlyOwner public {\n\t\t\n\t\trequire(_amount <= balances[owner]);\n\t\trequire(_amount > 0);\n\t\t\n\t\ttotalDistributed = totalDistributed.add(_amount);        \n        balances[_to] = balances[_to].add(_amount);\n        balances[owner] = balances[owner].sub(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        tAmount = 0;\n\t}\n\t\n\tfunction dist_airdrop(address _to, uint256 _amount) onlyOwner public {\t\t\n\t\trequire(_amount <= balances[storageAirdrop]);\n\t\trequire(_amount > 0);\n        balances[_to] = balances[_to].add(_amount);\n        balances[storageAirdrop] = balances[storageAirdrop].sub(_amount);\n        emit Airdrop(_to, _amount, balances[_to]);\n        emit Transfer(address(0), _to, _amount);\n\t}\n\t\n\tfunction dist_multiple_airdrop(address[] _participants, uint256 _amount) onlyOwner public {\n\t\ttAmount = 0;\n\t\t\n\t\tfor ( i = 0; i < _participants.length; i++){\n\t\t\ttAmount = tAmount.add(_amount);\n\t\t}\n\t\t\n\t\trequire(tAmount <= balances[storageAirdrop]);\n\t\t\n\t\tfor ( i = 0; i < _participants.length; i++){\n\t\t\tdist_airdrop(_participants[i], _amount);\n\t\t}\n\t\t\n\t\ttAmount = 0;\n\t}    \n    \n    function dist_developer(address _to, uint256 _amount) onlyOwner public {\n\t\trequire(_amount <= balances[storageDeveloper]);\n\t\trequire(_amount > 0);\n\t\tbalances[_to] = balances[_to].add(_amount);\n        balances[storageDeveloper] = balances[storageDeveloper].sub(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        tAmount = 0;\n\t}\n\t\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a FricaCoin smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract named FricaCoin, an ERC20 token with additional features supporting Pre-ICO, ICO phases, advisor allocations, and a mechanism to pause and resume the ICO. The contract includes a fixed total supply of tokens, distribution among various stakeholders (including a public sale, advisors, and charity), and stages to manage the lifecycle of the ICO.\n\nContract Specifications:\n- Inherits the ERC20 standard for token functionality.\n- Utilizes SafeMath for safe arithmetic operations.\n- Defines constants such as name (FricaCoin), symbol (FRI), and decimals (8).\n- Sets a fixed total supply and initial allocations for the owner, employees, advisors, charity, and ICO rounds.\n- Implements a stage-based system to manage the ICO process.\n\nKey Functionalities:\n1. Initial Token Allocation: Distributes the initial supply among the owner, advisors, charity, and reserves for ICO and Pre-ICO sales.\n2. ICO Stage Management: Controls the ICO process through stages, including not started, pre-ICO, ICO, paused, and ended.\n3. Advisor Allocation: Manages the distribution of tokens to advisors, including adding new advisors and transferring tokens.\n4. ICO Participation: Allows investors to participate in the ICO by sending ETH in exchange for FricaCoin tokens during the active sale phase.\n5. Pause and Resume ICO: Provides the owner with the ability to pause and resume the ICO to address any unforeseen issues.\n\nImplementation Details:\n- Stage Modifiers: Uses stage-specific modifiers to ensure functions are executed only at the appropriate times in the ICO lifecycle.\n- Ownership Checks: Includes ownership verification to secure sensitive functions like starting the ICO, pausing, and distributing tokens.\n- Token Distribution: Details functions for transferring tokens from the contract to participants, including public sale buyers and advisors.\n- ICO Timing and Caps: Sets specific start and end dates for the Pre-ICO and ICO phases, along with a maximum cap for public sale contributions.\n- Advisors Management: Facilitates the addition of advisors and tracks the distribution of tokens to these key stakeholders.\n\nSecurity Considerations:\n- SafeMath for Arithmetic: Ensures all arithmetic operations are safe from overflows and underflows, protecting the token's integrity.\n- Contract Ownership: Critical actions are restricted to the contract owner, preventing unauthorized access and modifications.\n- Stage Restrictions: Functions are gated by the current ICO stage, reducing the risk of inappropriate token minting or distribution.\n- Advisors Whitelisting: Advisors are managed through a mapping, with functions to add and verify their status, mitigating the risk of unauthorized token allocation.\n"}, {"role": "assistant", "content": "contract FricaCoin is ERC20 { \n    using SafeMath for uint256;\n    string public constant name = \"FricaCoin\";\n\n    string public constant symbol = \"FRI\";\n    uint8 public constant decimals = 8;\n    uint public _totalsupply = 1000000000000 * 10 ** 8; // 1 trillion total supply // muliplies dues to decimal precision\n    address public owner; \n    uint256 no_of_tokens;\n    uint256 bonus_token;\n    uint256 total_token;\n    bool stopped = false;\n    uint256 public pre_startdate;\n    uint256 public ico1_startdate;\n    uint256 ico_first;\n    uint256 ico_second;\n    uint256 ico_third;\n    uint256 ico_fourth;\n    uint256 pre_enddate;\n  \n    uint256 public eth_received; // total ether received in the contract\n    uint256 maxCap_public = 250000000000 * 10 **8;  //  25% - 250 billion in Public Sale\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    mapping (address => bool) private Advisors;\n    \n    uint256 public advisorCount;\n\n    enum Stages {\n        NOTSTARTED,\n        PREICO,\n        ICO,\n        PAUSED,\n        ENDED\n    }\n    Stages public stage;\n    \n    modifier atStage(Stages _stage) {\n        if (stage != _stage)\n            // Contract not in expected state\n            revert();\n        _;\n    }\n    \n     modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    function FricaCoin() public {\n        owner = msg.sender;\n        balances[owner] = 50000000000 * 10 **8; // 5% - 50 billion to owner\n        stage = Stages.NOTSTARTED;\n        Transfer(0, owner, balances[owner]);\n        \n        uint256 _transfertoemployees = 140000000000 * 10 **8; // 14% - 140 billion to Employees Advisors Consultants & Partners\n        balances[0xa36eEa22131881BB0a8902A6b8bF4a2cbb9782BC] = _transfertoemployees;\n        Transfer(address(0), 0xa36eEa22131881BB0a8902A6b8bF4a2cbb9782BC, _transfertoemployees);\n        \n        uint256 _transfertofirstround = 260000000000 * 10 **8; // 26% - 260 billion to First Round & Bonus\n        balances[0x553015bc932FaCc0C60159b7503a58ef5806CA48] = _transfertofirstround;\n        Transfer(address(0), 0x553015bc932FaCc0C60159b7503a58ef5806CA48, _transfertofirstround);\n        \n        uint256 _transfertocharity = 50000000000 * 10 **8; // 5% - 50 billion to Charity and non-profit\n        balances[0x11Bfb0B5a901cbc5015EF924c39ac33e91Eb015a] = _transfertocharity;\n        Transfer(address(0), 0x11Bfb0B5a901cbc5015EF924c39ac33e91Eb015a, _transfertocharity);\n\n        uint256 _transfertosecondround = 250000000000 * 10 **8; // 25% - 250 billion to Second Round & Bonus\n        balances[0xaAA258C8dbf31De53Aa679F6b492569556e1c306] = _transfertosecondround;\n        Transfer(address(0), 0xaAA258C8dbf31De53Aa679F6b492569556e1c306, _transfertosecondround);\n    }\n  \n\n    function start_PREICO() public onlyOwner atStage(Stages.NOTSTARTED) {\n        stage = Stages.PREICO;\n        stopped = false;\n        balances[address(this)] =  maxCap_public;\n        pre_startdate = now;\n        pre_enddate = now + 16 days;\n        Transfer(0, address(this), balances[address(this)]);\n    }\n      \n    function start_ICO() public onlyOwner atStage(Stages.PREICO) {\n        require(now > pre_enddate || eth_received >= 1500 ether);\n        stage = Stages.ICO;\n        stopped = false;\n        ico1_startdate = now;\n        ico_first = now + 15 days;\n        ico_second = ico_first + 15 days;\n        ico_third = ico_second + 15 days;\n        ico_fourth = ico_third + 15 days;\n        Transfer(0, address(this), balances[address(this)]);\n    }\n    \n    function PauseICO() external onlyOwner {\n        stopped = true;\n    }\n\n    function ResumeICO() external onlyOwner {\n        stopped = false;\n    }\n    \n    function end_ICO() external onlyOwner atStage(Stages.ICO) {\n        require(now > ico_fourth);\n        stage = Stages.ENDED;\n        _totalsupply = (_totalsupply).sub(balances[address(this)]);\n        balances[address(this)] = 0;\n        Transfer(address(this), 0 , balances[address(this)]);\n        \n    }\n\n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalsupply;\n    }\n    \n    function balanceOf(address _owner)public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount )public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    function approve(address _spender, uint256 _amount)public returns (bool success) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n  \n    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n\n     // Transfer the balance from owner's account to another account\n     function transfer(address _to, uint256 _amount)public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    // Transfer the balance from owner's account to another account\n    function transferTokens(address _to, uint256 _amount) private returns(bool success) {\n        require( _to != 0x0);       \n        require(balances[address(this)] >= _amount && _amount > 0);\n        balances[address(this)] = (balances[address(this)]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(address(this), _to, _amount);\n        return true;\n    }\n \n    // Transfer the balance from owner's account to advisor's account\n    function transferToAdvisors(address _to, uint256 _amount) public returns(bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        \n        if(!isAdvisor(_to)) {\n          addAdvisor(_to);\n          advisorCount++ ;\n        }\n\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n \n    function addAdvisor(address _advisor) public {\n        Advisors[_advisor]=true;\n    }\n\n    function isAdvisor(address _advisor) public returns(bool success){\n        return Advisors[_advisor];\n        return true;\n    }\n    \n    function drain() external onlyOwner {\n        owner.transfer(this.balance);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a GenF smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Design a smart contract named GenF that combines the ERC721A token standard with unique features for a digital asset launch. This contract manages a collection with a Dutch auction for public sale, a whitelist for presale, and admin functions for managing the sale's parameters. It also includes provenance data for the collection's authenticity, Merkle proof verification for whitelist eligibility, and withdrawal functionality for collecting funds.\n\nContract Specifications:\n- Inherits ERC721A for efficient batch minting and Ownable for administrative control.\n- Manages a digital asset collection with a fixed supply, dynamic pricing for public sale, and restricted access for presale.\n- Utilizes a Merkle tree for verifying whitelist participants and their allocations.\n- Implements a Dutch auction mechanism for determining the sale price over time.\n\nKey Functionalities:\n1. Whitelist and Presale Management: Allows participants with verified Merkle proofs to mint tokens at a preset price before the public sale.\n2. Dutch Auction for Public Sale: Dynamically adjusts the minting price based on the elapsed time from the start of the sale.\n3. Provenance Record: Maintains a provenance hash to ensure the collection's authenticity and integrity.\n4. Admin Control: Includes functions for the owner to adjust sale parameters, manage the whitelist, and set collection metadata.\n\nImplementation Details:\n- Minting Restrictions: Enforces rules for minting during the presale and public sale, including checks for start times, allocation limits, and payment amounts.\n- Pricing Calculation: The Dutch auction pricing is calculated based on the current time, with the price decreasing at specified intervals until a floor price is reached.\n- Whitelist Verification: Utilizes a Merkle tree for efficient and secure verification of presale participants and their minting allocation.\n- Funds Withdrawal: Provides a function for the owner to withdraw accumulated funds to a specified recipient address.\n\nSecurity Considerations:\n- Ownership and Access Control: Uses the Ownable modifier to protect critical functions that could alter the contract's operational parameters or withdraw funds.\n- Minting Validation: Ensures that minting cannot occur before the sale starts, exceeds allocation limits, or surpasses the collection's maximum supply.\n- Pricing Integrity: The Dutch auction mechanism requires careful implementation to prevent manipulation or errors in pricing calculations.\n"}, {"role": "assistant", "content": "contract GenF is ERC721A, Ownable {\n    string public PROVENANCE;\n\n    bytes32 public merkleRoot = \"\"; // Construct this from (address, amount) tuple elements\n    mapping(address => uint) public whitelistRemaining; // Maps user address to their remaining mints if they have minted some but not all of their allocation\n    mapping(address => bool) public whitelistUsed; // Maps user address to bool, true if user has minted\n\n    uint public presaleMintPrice;\n    uint public dutchAuctionStart;\n    uint public dutchAuctionEnd = 0.025 ether;\n    uint public dutchAuctionIncrement = 0.025 ether;\n    uint public dutchAuctionStepTime = 300; // 5 minutes\n    uint public maxItems = 10000;\n    uint public maxItemsPerTx = 10;\n    address public recipient;\n    string public _baseTokenURI;\n    uint public startTimestamp;\n\n    event Mint(address indexed owner, uint indexed tokenId);\n\n    constructor(address _owner) ERC721A(\"Gen-F\", \"GENF\", 200) {\n        require(_owner != address(0x0), \"Set owner\");\n        transferOwnership(_owner);\n    }\n\n    modifier mintingOpen() {\n        require(startTimestamp != 0, \"Start timestamp not set\");\n        require(block.timestamp >= startTimestamp, \"Not open yet\");\n        _;\n    }\n\n    function dutchAuctionPrice() public view returns (uint) {\n        if (startTimestamp == 0 || block.timestamp <= startTimestamp) {\n            return dutchAuctionStart;\n        } else {\n            uint increments = (block.timestamp - startTimestamp) / dutchAuctionStepTime;\n            if (increments * dutchAuctionIncrement >= dutchAuctionStart) {\n                return dutchAuctionEnd;\n            } else {\n                return dutchAuctionStart - (increments * dutchAuctionIncrement);\n            }\n        }\n    }\n\n    function ownerMint(uint amount) external onlyOwner {\n        _mintWithoutValidation(msg.sender, amount, true);\n    }\n\n    function publicMint(uint amount) external payable mintingOpen {\n        // Require nonzero amount\n        require(amount > 0, \"Can't mint zero\");\n\n        // Check proper amount sent\n        require(msg.value == amount * dutchAuctionPrice(), \"Send proper ETH amount\");\n\n        _mintWithoutValidation(msg.sender, amount, false);\n    }\n\n    function whitelistMint(uint amount, uint totalAllocation, bytes32 leaf, bytes32[] memory proof) external payable {\n        // Create storage element tracking user mints if this is the first mint for them\n        if (!whitelistUsed[msg.sender]) {        \n            // Verify that (msg.sender, amount) correspond to Merkle leaf\n            require(keccak256(abi.encodePacked(msg.sender, totalAllocation)) == leaf, \"Sender and amount don't match Merkle leaf\");\n\n            // Verify that (leaf, proof) matches the Merkle root\n            require(verify(merkleRoot, leaf, proof), \"Not a valid leaf in the Merkle tree\");\n\n            whitelistUsed[msg.sender] = true;\n            whitelistRemaining[msg.sender] = totalAllocation;\n        }\n\n        // Require nonzero amount\n        require(amount > 0, \"Can't mint zero\");\n\n        // Check proper amount sent\n        require(msg.value == amount * presaleMintPrice, \"Send proper ETH amount\");\n\n        require(whitelistRemaining[msg.sender] >= amount, \"Can't mint more than remaining allocation\");\n\n        whitelistRemaining[msg.sender] -= amount;\n        _mintWithoutValidation(msg.sender, amount, false);\n    }\n\n    function _mintWithoutValidation(address to, uint amount, bool skipMaxItems) internal {\n        uint _totalSupply = totalSupply(); // Cache variable after reading from storage\n        require(_totalSupply + amount <= maxItems, \"mintWithoutValidation: Sold out\");\n        require(skipMaxItems || amount <= maxItemsPerTx, \"mintWithoutValidation: Surpasses maxItemsPerTx\");\n        _safeMint(to, amount);\n    }\n\n    function verify(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\n        return MerkleProof.verify(proof, root, leaf);\n    }\n\n    function setProvenance(string memory provenance) public onlyOwner {\n        PROVENANCE = provenance;\n    }\n\n    function setPresaleMintPrice(uint _presaleMintPrice) external onlyOwner {\n        presaleMintPrice = _presaleMintPrice;\n    }\n\n    function setDutchAuctionStart(uint _dutchAuctionStart) external onlyOwner {\n        dutchAuctionStart = _dutchAuctionStart;\n    }\n\n    function setDutchAuctionEnd(uint _dutchAuctionEnd) external onlyOwner {\n        dutchAuctionEnd = _dutchAuctionEnd;\n    }\n\n    function setDutchAuctionIncrement(uint _dutchAuctionIncrement) external onlyOwner {\n        dutchAuctionIncrement = _dutchAuctionIncrement;\n    }\n\n    function setDutchAuctionStepTime(uint _dutchAuctionStepTime) external onlyOwner {\n        dutchAuctionStepTime = _dutchAuctionStepTime;\n    }\n\n    function setMaxItems(uint _maxItems) external onlyOwner {\n        maxItems = _maxItems;\n    }\n\n    function setMaxItemsPerTx(uint _maxItemsPerTx) external onlyOwner {\n        maxItemsPerTx = _maxItemsPerTx;\n    }\n\n    function setRecipient(address _recipient) external onlyOwner {\n        recipient = _recipient;\n    }\n\n    function setStartTimestamp(uint _startTimestamp) external onlyOwner {\n        startTimestamp = _startTimestamp;\n    }\n\n    function setBaseTokenURI(string memory __baseTokenURI) public onlyOwner {\n        _baseTokenURI = __baseTokenURI;\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    // Withdraw the contract balance to the recipient address\n    function withdraw() external {\n        require(recipient != address(0x0), \"Set recipient first\");\n        uint amount = address(this).balance;\n        (bool success,) = recipient.call{value: amount}(\"\");\n        require(success, \"Failed to send ether\");\n    }\n\n    // Returns a URI for a given token ID's metadata\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n        return string(abi.encodePacked(_baseTokenURI, Strings.toString(_tokenId)));\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Adet smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a comprehensive smart contract named Adet that incorporates the ERC20 standard functionalities with additional features like burning, freezing, and unfreezing of tokens. This contract is designed to support the digital economy of Australia, represented by the token name \"Australia Digital Economy Token\" (ADET), with precision up to 6 decimal places. The contract includes mechanisms to reduce the total supply through burning, restrict token transfers by freezing tokens, and manage token ownership and permissions comprehensively.\n\nContract Specifications:\n- Inherits from Owned, SafeMath, and Pausable to utilize ownership management, safe arithmetic operations, and pausing functionality.\n- Implements the EIP20Interface for standard ERC20 token operations.\n- Introduces additional features for burning tokens to reduce the total supply, and freezing/unfreezing tokens to control token liquidity and transferability.\n\nKey Functionalities:\n1. Token Basics: Establishes token properties including name (\"Australia Digital Economy\"), symbol (\"ADET\"), decimals (6), and an initial total supply of 2.8 billion tokens.\n2. Burning Tokens: Allows the owner to permanently remove tokens from the total supply, reducing the number of tokens in circulation.\n3. Freezing and Unfreezing Tokens: Enables the contract owner to freeze tokens for a specified address, preventing those tokens from being transferred until they are unfrozen.\n4. ERC20 Compliance: Fully supports standard ERC20 functions such as balance queries, transfers, and approvals, ensuring compatibility with the broader Ethereum ecosystem.\n5. Pause Functionality: Incorporates the ability to pause and unpause token transfers, providing emergency controls to address potential issues.\n\nImplementation Details:\n- SafeMath for Arithmetic: Utilizes the SafeMath library to prevent overflow and underflow vulnerabilities in arithmetic operations.\n- Ownership and Access Control: Leverages the Owned contract to manage ownership-specific actions, such as burning and freezing tokens.\n- Pausable Transfers: Ensures that token transfers can be paused or unpaused by the owner, enhancing security and operational control.\n- Freeze and Unfreeze Mechanics: Details the process for freezing tokens, including reducing the available balance and tracking frozen amounts, and similarly for unfreezing.\n\nSecurity Considerations:\n- Role-Based Features: Restricts sensitive actions like burning and freezing tokens to the contract owner, preventing unauthorized use.\n- Input Validations: Includes checks for zero addresses, sufficient balances, and non-negative transaction values to ensure robustness and security.\n- Pause Control: Offers a mechanism to stop all token transfers in the event of a security concern or during contract upgrades, minimizing potential risks.\n"}, {"role": "assistant", "content": "contract Adet is Owned, SafeMath, Pausable, EIP20Interface {\n    uint256 private totalSupply_;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    \n    mapping (address => uint256) public balances;\n    mapping (address => uint256) public frozen;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    event Freeze(address indexed from, uint256 value);\n    event Unfreeze(address indexed from, uint256 value);\n    event Burned(address indexed from, uint256 value);\n\n    constructor() public {\n        name = \"Australia Digital Econmoy\";\n        symbol = \"ADET\";\n        decimals = 6;\n        totalSupply_ = 2800000000 * 10 ** uint256(decimals);\n        balances[msg.sender] = totalSupply_;\n    }\n\n    function burn(address _addr, uint256 _amount) onlyOwner public returns (bool success) {\n        require(_addr != 0);\n        require(_amount <= balances[_addr]);\n\n        totalSupply_ = sub(totalSupply_, _amount);\n        balances[_addr] = sub(balances[_addr], _amount);\n        emit Transfer(_addr, address(0), _amount);\n        emit Burned(_addr, _amount);\n        return true;\n    }\n\n    function freeze(address _addr, uint256 _value) public onlyOwner returns (bool success) {\n        require(balances[_addr] >= _value);\n        require(_value > 0);\n        balances[_addr] = sub(balances[_addr], _value);\n        frozen[_addr] = add(frozen[_addr], _value);\n        emit Freeze(_addr, _value);\n        return true;\n    }\n    \n    function unfreeze(address _addr, uint256 _value) public onlyOwner returns (bool success) {\n        require(frozen[_addr] >= _value);\n        require(_value > 0);\n        frozen[_addr] = sub(frozen[_addr], _value);\n        balances[_addr] = add(balances[_addr], _value);\n        emit Unfreeze(_addr, _value);\n        return true;\n    }\n\n    function frozenOf(address _addr) public view returns (uint256 balance) {\n        return frozen[_addr];\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    function balanceOf(address _addr) public view returns (uint256 balance) {\n        return balances[_addr];\n    }\n\n    function transfer(address _to, uint256 _value) public notPaused returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        require(balances[_to] + _value >= balances[_to]);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public notPaused returns (bool success) {\n        require(balances[_from] >= _value);\n        require(balances[_to] + _value >= balances[_to]);\n        require(allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public notPaused returns (bool success) {\n        require(_value > 0);\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    } \n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Hypechill smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract named Hypechill utilizing the ERC20 standard, augmented with a fee on transactions to support operational or developmental costs. This contract introduces a transfer fee mechanism applied to token transfers, excluding designated fee-exempt accounts, to generate revenue or support specific financial strategies. It includes administrative functions to manage the fee structure and exempt accounts, ensuring flexibility and control over the tokenomics.\n\nContract Specifications:\n- Inherits ERC20 for token functionality and Ownable for administrative actions.\n- Sets an initial supply of 25,800 CHILL tokens, with 18 decimal places, during contract deployment.\n- Implements a mechanism to levy fees on transfers, expressed as a percentage of the transaction amount.\n\nKey Functionalities:\n1. Initial Token Supply: Mints an initial supply of CHILL tokens to the contract owner's address upon deployment.\n2. Transfer Fee Mechanism: Applies a fee to token transfers, directing the fee to a specified recipient account, which can be changed by the contract owner.\n3. Fee Management: Allows the contract owner to adjust the transfer fee percentage and activate or deactivate the fee mechanism as needed.\n4. Fee Exceptions: Provides the ability to exempt certain accounts from transfer fees, accommodating use cases like liquidity pools or partner addresses.\n5. Event Logging: Emits events for significant administrative actions, such as changing the transfer fee, updating the fee recipient, and modifying fee exceptions.\n\nImplementation Details:\n- Fee Calculation: Calculates the transfer fee based on a set percentage of the transaction amount, ensuring the recipient receives the amount minus the fee.\n- Exempt Accounts: Manages a mapping of accounts that are exempt from transfer fees, allowing for strategic partnerships or operational necessities.\n- Administrative Controls: Includes functions for the owner to update the transfer fee percentage, designate the fee recipient, and manage exemptions.\n\nSecurity Considerations:\n- Ownership Verification: Utilizes the onlyOwner modifier to restrict sensitive operations, such as adjusting fees or designating exempt accounts, to the contract owner.\n- Fee Limits: Ensures the transfer fee percentage does not exceed a maximum threshold to protect users from excessive deductions.\n- Safe Math Operations: Employs the SafeMath library for arithmetic operations to prevent overflow and underflow vulnerabilities.\n"}, {"role": "assistant", "content": "contract Hypechill is ERC20, Ownable {\n    constructor() public ERC20(\"hypechill.finance\", \"CHILL\") { \n        // Mint 25,800 CHILL (18 Decimals)\n        _mint(msg.sender, 25800000000000000000000);\n    }\n\n    // Transfer Fee\n    event TransferFeeChanged(uint256 newFee);\n    event FeeRecipientChange(address account);\n    event AddFeeException(address account);\n    event RemoveFeeException(address account);\n\n    bool private activeFee;\n    uint256 public transferFee; // Fee as percentage\n    address public feeRecipient; \n\n    // Exception to transfer fees, for example for Uniswap contracts.\n    mapping (address => bool) public feeException;\n\n    function addFeeException(address account) public onlyOwner {\n        feeException[account] = true;\n        emit AddFeeException(account);\n    }\n\n    function removeFeeException(address account) public onlyOwner {\n        feeException[account] = false;\n        emit RemoveFeeException(account);\n    }\n\n    function setTransferFee(uint256 fee) public onlyOwner {\n        require(fee <= 2500, \"Fee cannot be greater than 25%\");\n        if (fee == 0) {\n            activeFee = false;\n        } else {\n            activeFee = true;\n        }\n        transferFee = fee;\n        emit TransferFeeChanged(fee);\n    }\n\n    function setTransferFeeRecipient(address account) public onlyOwner {\n        feeRecipient = account;\n        emit FeeRecipientChange(account);\n    }\n\n    // Transfer recipient recives amount - fee\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        if (activeFee && feeException[_msgSender()] == false) {\n            uint256 fee = transferFee.mul(amount).div(10000);\n            uint amountLessFee = amount.sub(fee);\n            _transfer(_msgSender(), recipient, amountLessFee);\n            _transfer(_msgSender(), feeRecipient, fee);\n        } else {\n            _transfer(_msgSender(), recipient, amount);\n        }\n\n        return true;\n    }\n\n    // TransferFrom recipient recives amount, sender's account is debited amount + fee\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        if (activeFee && feeException[recipient] == false) {\n            uint256 fee = transferFee.mul(amount).div(10000);\n            _transfer(sender, feeRecipient, fee);\n        }\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Onemizer90 smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract, Onemizer90, which is an ERC721 token with unique functionalities tailored for minting, reserving, and managing a limited supply of tokens. The contract integrates sales constraints, allowing tokens to be minted only after a specified start date and ensuring transactions meet the set ether value. Additionally, it supports owner-specific features like modifying contract parameters and reserving tokens for specific addresses.\n\nContract Specifications:\n- Inherits ERC721 and Ownable functionalities.\n- Utilizes Counters from OpenZeppelin to manage token IDs.\n- Establishes sale parameters including price, start date, max supply, and reserved tokens.\n- Includes a sale active modifier to control minting operations based on the start date.\n- Provides functions for minting, reserving tokens, querying total supply, and owner-specific operations like setting base URI, price, start date, max supply, and reserved tokens.\n\nKey Functionalities:\n1. Minting: Users can mint a specified number of tokens, adhering to the sale's active state, correct ether value, and max supply constraints.\n2. Reserving Tokens: The contract owner can reserve tokens for specific addresses, not affecting the publicly available supply.\n3. Supply and Ownership Queries: Functions are available to query the total supply of tokens and the list of token IDs owned by a specific address.\n4. Parameter Modifications: Only the contract owner can modify key parameters like the base URI, price, start date, max supply, and reserved tokens.\n5. Withdrawal: Enables the contract owner to withdraw funds to a specified address.\n6. OpenSea Integration: Overrides isApprovedForAll to whitelist OpenSea proxy accounts, facilitating gas-less listings.\n\nImplementation Details:\n- The mint function incorporates the saleIsActive modifier, ensuring tokens can only be minted after the sale starts, and checks if the ether sent with the request matches the total price for the requested number of tokens.\n- Reserved tokens are considered in the total supply to prevent exceeding the max supply when minting.\n- The reserve function is restricted to the contract owner, allowing them to mint tokens directly to given addresses without payment.\n- Base URI, price, start date, max supply, and reserved tokens can be updated by the owner, allowing for flexibility in managing the sale.\n\nSecurity Considerations:\n- Ensures that only the contract owner can modify critical contract parameters and reserve tokens, protecting against unauthorized alterations.\n- Includes checks for valid addresses and correct ether values to mitigate common vulnerabilities.\n- The use of the Ownable and Counters libraries from OpenZeppelin provides tested and secure management of ownership and token ID incrementation.\n- The contract adheres to ERC721 standards for NFTs, ensuring compatibility and security in transactions and ownership management.\n"}, {"role": "assistant", "content": "contract Onemizer90 is ERC721, Ownable {\n    using Counters for Counters.Counter;\n    address proxyRegistryAddress;\n    Counters.Counter private _tokenSupply;\n\n    uint256 public PRICE;\n    uint256 public START_DATE;\n    uint256 public MAX_SUPPLY;\n    uint256 public RESERVED;\n\n    string private baseUri;\n\n    modifier saleIsActive() {\n        require(START_DATE != 0 && block.timestamp >= START_DATE, \"Sale is not active yet\");\n        _;\n    }\n\n    constructor(address _proxyRegistryAddress, uint256 _price, uint256 _startDate, uint256 _maxSupply, uint256 _reserved, string memory _baseUri) ERC721(\"Onemizer90\", \"OM\") {\n        proxyRegistryAddress = _proxyRegistryAddress;\n        PRICE = _price;\n        START_DATE = _startDate;\n        MAX_SUPPLY = _maxSupply;\n        RESERVED = _reserved;\n        baseUri = _baseUri;\n    }\n\n    function mint(uint256 numberOfTokens) public payable saleIsActive {\n        require(numberOfTokens * PRICE == msg.value, \"Ether value is not correct\");\n        require(_tokenSupply.current() + numberOfTokens + RESERVED <= MAX_SUPPLY, \"Sold out!\");\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, _tokenSupply.current());\n            _tokenSupply.increment();\n        }\n    }\n\n    function reserve(address[] calldata to) public onlyOwner {\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], _tokenSupply.current());\n            _tokenSupply.increment();\n        }\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _tokenSupply.current();\n    }\n\n    function contractURI() public pure returns (string memory) {\n        return \"ipfs://bafybeigpmcheddbbt7un2745fzpoi3r3vsxnjhtzj5poovsledgb52qd3i\";\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseUri;\n    }\n\n    function setBaseURI(string memory _baseUri) public onlyOwner {\n        baseUri = _baseUri;\n    }\n\n    function setPrice(uint256 _price) public onlyOwner {\n        PRICE = _price;\n    }\n\n    function setStartDate(uint256 _startDate) public onlyOwner {\n        START_DATE = _startDate;\n    }\n\n    function setMaxSupply(uint256 _maxSupply) public onlyOwner {\n        MAX_SUPPLY = _maxSupply;\n    }\n\n    function setReserved(uint256 _reserved) public onlyOwner {\n        RESERVED = _reserved;\n    }\n\n    function walletOfOwner(address owner) public view returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](balanceOf(owner));\n        uint256 i = 0;\n\n        for (uint256 tokenId = 0; tokenId < _tokenSupply.current(); tokenId++) {\n            if (_exists(tokenId) && ownerOf(tokenId) == owner) {\n                result[i] = tokenId;\n                i += 1;\n            }\n        }\n        return result;\n    }\n\n    function withdraw(address payable to, uint256 amount) public onlyOwner {\n        require(to != address(0x0), \"Invalid address\");\n        to.transfer(amount);\n    }\n\n    // Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        // Whitelist OpenSea proxy contract for easy trading.\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n\n        return super.isApprovedForAll(owner, operator);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a YahtsContract smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop an ERC20 token smart contract named YahtsContract with advanced features including burning tokens and preventing accidental ETH transfers to the contract. The contract aims to manage a predefined supply of tokens, facilitate transfers between addresses, allow token spending approvals, and enable token holders to reduce the total supply by burning tokens they own.\n\nContract Specifications:\n- Implements ERC20 standard functionalities.\n- Initializes with a fixed token supply, name, symbol, standard, and decimals.\n- Incorporates functions for token transfer, allowance management, balance queries, and token burning.\n- Utilizes SafeMath for arithmetic operations to prevent overflow and underflow vulnerabilities.\n- Rejects incoming ETH transactions to prevent accidental ETH deposits.\n\nKey Functionalities:\n1. Initial Token Allocation: Assigns the entire initial supply to the contract creator's address.\n2. Token Transfer: Enables token holders to transfer tokens to another address, with checks for sufficient balance.\n3. Approval Mechanism: Allows token holders to authorize a third party to spend a specified amount of tokens on their behalf.\n4. Transfer from Approved Account: Facilitates transfers from an approved account up to the allowed limit, adjusting balances and allowances accordingly.\n5. Token Burning: Permits token holders to reduce the circulating supply by destroying a portion of their tokens.\n6. Query Functions: Provides public view functions to access token details (name, symbol, standard, decimals) and account-specific details (balance, allowance).\n\nImplementation Details:\n- The transfer, approve, and transferFrom functions incorporate checks for zero addresses and sufficient balances/allowances, aligning with ERC20 standards.\n- The burn function allows token holders to voluntarily decrease the total supply by destroying their tokens, emitting a transfer event to the zero address to signify the burn.\n- SafeMath library is used to safely conduct arithmetic operations, protecting against overflow and underflow.\n- The contract explicitly rejects direct ETH transfers by reverting transactions, ensuring that users do not mistakenly send ETH to the contract.\n\nSecurity Considerations:\n- Utilizes OpenZeppelin's SafeMath library to mitigate arithmetic vulnerabilities.\n- Includes input validation to prevent transfers to the zero address and ensure action legitimacy.\n- Implements a mechanism to reject ETH deposits, protecting users from accidental loss of ETH.\n- Adheres to the ERC20 standard, ensuring compatibility with the Ethereum ecosystem and preventing common token contract issues.\n"}, {"role": "assistant", "content": "contract YahtsContract is ERC20 {\n    string internal _name = \"VI YAHTS 1\";\n    string internal _symbol = \"VT1\";\n    string internal _standard = \"ERC20\";\n    uint8 internal _decimals = 18;\n    uint internal _totalSupply = 500000 * 1 ether;\n    \n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor () public {\n        balances[msg.sender] = totalSupply();\n    }\n\n    function () external payable  {\n        revert(\"This SmartContract is not payable\");\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function standard() public view returns (string memory) {\n        return _standard;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require (_spender != address(0), \"_spender address has to be set\");\n        require (_value > 0, \"'_value' parameter has to be greater than 0\");\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_from != address(0), \"'_from' address has to be set\");\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[_from], \"Insufficient balance\");\n        require(_value <= allowed[_from][msg.sender], \"Insufficient allowance\");\n\n        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n        balances[_from] = SafeMath.sub(balances[_from], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n    \n    function burn(uint256 _value) public returns (bool success) {\n        require(_value <= balances[msg.sender]);\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        _totalSupply = SafeMath.sub(_totalSupply, _value);\n        emit Transfer(msg.sender, address(0), _value);\n        return true;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a PerkyPineapples smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a unique ERC721 token smart contract, PerkyPineapples, designed to manage a collection of NFTs with distinct minting phases, including a free minting period. This contract incorporates several adjustable parameters to control the sales process, such as activation status, price per token, maximum tokens per transaction, and limitations on free mints per wallet. It also includes a mechanism to gift tokens and withdraw contract balances, alongside integration with proxy registries for marketplace compatibility.\n\nContract Specifications:\n- Inherits ERC721 and Ownable functionalities for NFT management and ownership control.\n- Defines parameters for sale activation, token pricing, minting caps, and free mint allowances.\n- Utilizes a counter to track the total supply of tokens.\n- Allows for the setting of hidden and base URIs to manage how token metadata is presented before and after reveal.\n- Includes proxy registry address integration for marketplace facilitation.\n\nKey Functionalities:\n1. Sale Activation: The contract owner can toggle the sale's active status, controlling when minting is allowed.\n2. Minting: Users can mint a specified number of tokens, adhering to maximum per transaction and total supply limits, with a distinction between paid and free minting based on the current supply and per-wallet free mint limits.\n3. Gifting Tokens: The contract owner can mint tokens directly to any address, bypassing payment and mint limits.\n4. Withdrawal: Enables the contract owner to withdraw the balance of ETH collected from token sales.\n5. Metadata Management: Offers functions to set hidden and revealed metadata URIs for the tokens.\n6. Marketplace Integration: Adjusts approval checks for token operations through a proxy registry, aiding in marketplace listings.\n\nImplementation Details:\n- The contract distinguishes between free and paid mints based on the total amount of tokens already minted and individual wallet contributions to the free mint count.\n- Incorporates safety checks to prevent sending ETH to the contract unintentionally.\n- Utilizes a constructor to gift an initial set of tokens to the contract deployer.\n- Employs Counters to safely increment token IDs upon minting.\n- Provides public view functions for querying contract states, such as total supply and sale activation status.\n\nSecurity Considerations:\n- Ensures that minting functions check for sale activation and adhere to max supply constraints to prevent over-minting.\n- Uses onlyOwner modifiers for functions that modify critical parameters, ensuring that only the contract owner can alter the sale dynamics.\n- Prevents direct ETH transfers to the contract, mitigating the risk of unintended contract interactions.\n- Safe use of external calls (msg.sender.call) in the withdrawal function, though care must be taken to monitor for reentrancy vulnerabilities.\n"}, {"role": "assistant", "content": "contract PerkyPineapples is ERC721, Ownable {\n    bool public saleIsActive = false;\n\n    uint256 public price = 0.025 ether;\n\tuint public maxPerTx = 10;\n\tuint public maxFreeMintPerWallet = 20;\n\tuint public amountAvailableFreeMint = 200;\n\tuint public maxSupply = 5000;\n\taddress proxyRegistryAddress ; \n\tmapping(address => uint) public addressFreeMinted;\n    string public _hiddenURI = \"ipfs://QmRkNnfQExTwer7vL1PNuRszzshpUWjRb7AerWQt1Ef82Q/hidden.json\";\n    string public _baseURIextended = \"\";\n\t\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenSupply;\n\n    constructor() ERC721(\"PerkyPineapples\", \"PP\") {\n        for (uint256 i = 0; i < 10; i++){\n            gift(msg.sender);\n        }\n    }\n\n    function totalSupply() public view returns (uint256 supply) {\n        return _tokenSupply.current();\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n\n        return super.isApprovedForAll(owner, operator);\n    }\n\n    function mint(uint numberOfTokens) external payable {\n        require(saleIsActive, \"Sale is inactive.\");\n        require(numberOfTokens <= maxPerTx, \"You can only mint 10 at a time.\");\n        require(_tokenSupply.current() + numberOfTokens <= maxSupply, \"Purchase would exceed max supply of tokens\");\n        \n        if (_tokenSupply.current() + numberOfTokens > amountAvailableFreeMint) {\n            require((price * numberOfTokens) <= msg.value, \"Don't send under (in ETH).\");\n        } else {\n\t\t\trequire(msg.value == 0, \"Don't send ether for the free mint.\");\n\t\t\trequire(addressFreeMinted[msg.sender] < maxFreeMintPerWallet, \"You can only adopt 20 free CAU per wallet. Wait for the paid adoption.\");\n\t\t}\n\t\t\n\t\taddressFreeMinted[msg.sender] += numberOfTokens;\n        for(uint i = 0; i < numberOfTokens; i++) {\n\t\t  uint256 _tokenId = _tokenSupply.current() + 1;\n            _safeMint(msg.sender, _tokenId);\n            _tokenSupply.increment();\n        }\n    }\n\n    function gift(address _to) public onlyOwner {\n        uint256 _tokenId = _tokenSupply.current() + 1;\n        _safeMint(_to, _tokenId);\n        _tokenSupply.increment();\n    }\n\n    function withdraw() public onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 \n            ? string(abi.encodePacked(baseURI, Strings.toString(tokenId), \".json\")) \n            : _hiddenURI; // If the base URI is not set, return a hidden URI\n    }\n\n    function setSaleIsActive(bool newState) public onlyOwner {\n        saleIsActive = newState;\n    }\n\n    function setPrice(uint newPrice) public onlyOwner {\n        price = newPrice;\n    }\n\n    function setMaxPerTx(uint _maxPerTx) external onlyOwner() {\n        maxPerTx = _maxPerTx;\n    }\n\n    function setMaxFreeMintPerWallet(uint _maxFreeMint) public onlyOwner() {\n        maxFreeMintPerWallet = _maxFreeMint;\n    }\n\n    function setAmountAvailableFreeMint(uint _freeMint) public onlyOwner() {\n        amountAvailableFreeMint = _freeMint;\n    }\n\n    function setMaxSupply(uint _maxSupply) public onlyOwner() {\n        maxSupply = _maxSupply;\n    }\n\n    // rinkeby: 0xf57b2c51ded3a29e6891aba85459d600256cf317\n    // mainnet: 0xa5409ec958c83c3f309868babaca7c86dcb077c1\n    function setProxyRegistryAddress(address proxyAddress) external onlyOwner {\n        proxyRegistryAddress = proxyAddress;\n    }\n\n    function setHiddenUri(string memory hiddenURI) public onlyOwner() {\n        _hiddenURI = hiddenURI;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\n        _baseURIextended = baseURI_;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a XYZZ smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a versatile ERC20 token smart contract, XYZZ, that incorporates a crowdfunding ICO mechanism with specific timelines, bonus periods, and caps. The contract features advanced token management options such as minting, burning, freezing accounts, and facilitating purchases within defined periods. Additionally, it incorporates SafeMath for arithmetic operations to prevent overflow and underflow vulnerabilities.\n\nContract Specifications:\n- Implements the ERC20 standard with extensions for crowdfunding functionality.\n- Initial setup includes token name, symbol, description, decimals, and caps (internal, soft).\n- Defines time-bound conditions for bonus periods and ICO duration.\n- ICO Stages: Include variables to manage ICO stages, like `_startDate`, `_bonusEnds`, `_endDate`, `_internalCap`, and `_softCap`\n- Utilizes mappings for token balances, allowances, and account freeze states.\n- Provides a mechanism for token purchases with bonuses, account freezing/unfreezing, token minting, and burning.\n- State Variables: Define mappings for storing balances (`_balances`), allowances (`_allowed`), and account freeze states (`_freezeState`).\n\nKey Functionalities:\n1. Constructor: Initialize the contract with token information, ICO parameters, and allocate initial tokens to the minter's account.\n2. ICO and Bonus Periods: Specifies start, bonus, and end dates for the ICO, including bonus token issuance for early contributions.\n3. Token Purchase: Enables the purchase of tokens by sending ETH to the contract, with bonus tokens awarded during the bonus period.\n4. Account Freezing: Allows the contract owner to freeze/unfreeze accounts, preventing affected accounts from transferring tokens.\n5. Token Minting and Burning: Grants the contract owner the ability to mint new tokens or burn existing tokens from the supply.\n6. Crowdfunding Goals: Incorporates soft and internal cap goals to gauge the success of the crowdfunding effort.\n7. Transfer Restrictions: Enforces transfer and approval restrictions until the ICO is successfully concluded, based on the end date and soft cap achievement.\n\nImplementation Details:\n- The constructor sets initial token parameters and allocates the internal cap amount to the contract owner.\n- Token purchases are allowed within the ICO period, with the amount of tokens received based on the contribution amount and current phase.\n- Implements SafeMath library functions for secure mathematical operations.\n- Includes modifiers to enforce ICO success conditions and check for account freeze states before allowing token transfers or approvals.\n- Offers approveAndCall function for compatibility with contracts that need to execute functions upon receiving approval.\n\nSecurity Considerations:\n- Utilizes the SafeMath library to mitigate overflow and underflow risks in arithmetic operations.\n- Restricts critical operations such as minting, burning, freezing, and unfreezing of accounts to the contract owner, protecting against unauthorized access.\n- Enforces a freeze mechanism to temporarily halt transactions for specific accounts, adding an extra layer of control over token circulation.\n- Ensures that token purchases, transfers, and approvals are only processed if the ICO has reached its end and the soft cap goal, safeguarding against premature distribution.\n"}, {"role": "assistant", "content": "contract XYZZ is ERC20Interface, Owned, SafeMath {\n    string public symbol;\n    string public name;\n    string public description;\n    uint8 public decimals;    \n    uint private _startDate;\n    uint private _bonusEnds;\n    uint private _endDate;\n\n    uint256 private _internalCap;\n    uint256 private _softCap;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) _balances;\n    mapping(address => mapping(address => uint256)) _allowed;\n    mapping(address => bool) _freezeState;\n\n    constructor(\n        address payable minter) public {\n        \n        name   = \"VGNA Token\";\n        description = \"Virtual Geospatial Networking Asset\";\n        symbol = \"VGNA\";\n        decimals = 18;\n        _internalCap = 25000000;\n        _softCap     = 50000000;\n        \n        _bonusEnds = now + 3 days;\n        _endDate = now + 1 weeks;\n            \n        _owner = minter;\n        _balances[_owner] = _internalCap;  \n        _totalSupply = _internalCap;\n        emit Transfer(address(0), _owner, _internalCap);\n    }\n\n    modifier IcoSuccessful {\n        require(now >= _endDate);\n        require(_totalSupply >= _softCap);\n        _;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply - _balances[address(0)];\n    }\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return _balances[tokenOwner];\n    }\n    \n    function isFreezed(address tokenOwner) public view returns (bool freezed) {\n        return _freezeState[tokenOwner];\n    }\n\n    // Transfer the balance from token owner's account to `to` account\n    function transfer(address to, uint256 tokens) public IcoSuccessful returns (bool success) {\n        require(_freezeState[msg.sender] == false);\n        \n        _balances[msg.sender] = safeSub(_balances[msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    \n    // Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account\n    function approve(address spender, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    function transferFrom(address from, address to, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[from] == false && _freezeState[to] == false);\n        \n        _balances[from] = safeSub(_balances[from], tokens);\n        _allowed[from][msg.sender] = safeSub(_allowed[from][msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    // Returns the amount of tokens approved by the owner that can be transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        require(_freezeState[spender] == false);\n        return _allowed[tokenOwner][spender];\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account. The `spender` contract function `receiveApproval(...)` is then executed\n    function approveAndCall(address spender, uint tokens, bytes memory data) public IcoSuccessful returns (bool success) {\n        require(_freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, _owner, data);\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // 1 VGNA Tokens per 1 Wei\n    function buy() public payable {\n        require(msg.value >= 1 finney);\n        require(now >= _startDate && now <= _endDate);\n\n        uint256 weiValue = msg.value;\n        uint256 tokens = 0;\n        \n        if (now <= _bonusEnds) {\n            tokens = safeMul(weiValue, 2);\n        } else {\n            tokens = safeMul(weiValue, 1);\n        }\n        \n        _freezeState[msg.sender] = true;\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        _owner.transfer(msg.value);\n    }\n    \n    function () payable external {\n        buy();\n    }\n\n    function burn(uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[msg.sender] >= tokens);   // Check if the sender has enough\n        address burner = msg.sender;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function burnFrom(address account, uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[account] >= tokens);   // Check if the sender has enough\n        address burner = account;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function freeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = true;\n        return true;\n    }\n    \n    function unfreeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = false;\n        return true;\n    }\n    \n    function mint(uint256 tokens) public onlyOwner returns (bool success)\n    {\n        require(now >= _startDate && now <= _endDate);\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        return true;\n    }\n\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(_owner, tokens);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a AquaTools smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a comprehensive prompt for a smart contract named AquaTools, which integrates the ERC1155 standard for NFTs, includes ownership and supply tracking functionalities, and enables presale and public sale mechanisms with price and supply management. This contract is designed for a specific collection with a maximum supply limit and incorporates a whitelist verification system using Merkle proofs for presale participants.\n\nContract Specifications:\n- Inherits from ERC1155 for NFT functionality, Ownable for ownership management, and ERC1155Supply for supply tracking.\n- Sets a token price, maximum supply, reserved supply for the owner, and sale status flags.\n- Includes minting functions for both presale and public sale with specific limits per transaction.\n- Utilizes a Merkle proof for whitelist verification during the presale.\n- Provides owner-only functions to adjust sale parameters and withdraw contract balance.\n\nKey Functionalities:\n1. Initial Setup: On deployment, mints a specified reserved supply to the contract owner and sets initial URI for metadata.\n2. Sale Management: Allows the owner to toggle presale and sale status, adjust the token price, set a new Merkle root for whitelist verification, and update the metadata URI.\n3. Withdrawal Function: Enables the owner to withdraw all funds collected from sales.\n4. Minting Mechanics:\n    - Presale Minting: Requires valid Merkle proof for whitelist, checks for presale status, and enforces a limit on the number of mints per transaction.\n    - Public Sale Minting: Checks for sale status and limits the number of mints per transaction.\n5. Supply and Ownership Queries: Functions to check the remaining supply, token ownership, and contract balance.\n\nImplementation Details:\n- The constructor mints the reserved supply to the owner and decreases the available supply accordingly.\n- Mint functions deduct from the supplyLeft and ensure the total minted tokens don't exceed maxSupply.\n- Presale minting requires a valid Merkle proof linking the transaction sender to the whitelist.\n- Sale status, price, and Merkle root can only be modified by the contract owner.\n- Uses ERC1155Supply to track and limit the total supply of tokens.\n- Includes safety checks for transfers and receiving tokens to comply with ERC1155 standards.\n\nSecurity Considerations:\n- The onlyOwner modifier ensures that critical functions can only be executed by the contract owner.\n- Merkle proof verification adds a layer of security for presale participation, ensuring only whitelisted addresses can mint.\n- Requires value sent with the mint transaction to match or exceed the calculated price to prevent underpayment.\n- Enforces max supply limits to prevent over-minting beyond the specified collection size.\n- Input validation for mint amounts and sale activation flags to avoid unintended state changes.\n"}, {"role": "assistant", "content": "contract AquaTools is ERC1155, Ownable, ERC1155Supply {\n    uint256 public price = 0.1 ether;\n    uint16 public maxSupply = 3000;\n    uint16 public supplyLeft = maxSupply;\n    uint8 public reservedSupply = 200;\n    bool public presaleActive;\n    bool public saleActive;\n    uint8 public presaleMaxMintsPerTrans = 1;\n    uint8 public publicMaxMintsPerTrans = 3;\n    uint8 public passIndex = 0;\n    bytes32 public merkleRoot = 0x9492a15aa69d55a18e1181ac3b84b971ef9799e23b284f144961474af08621d9;\n\n    mapping(address => bool) public whitelistClaimed;\n\n    constructor() ERC1155(\"ipfs://QmTF8cSSv5Ewexo4TMU8Wg1MqEwXHfLVxYkuhy7GzwSU6U\") {\n        _mint(msg.sender, passIndex, reservedSupply, \"\");\n\n        supplyLeft -= reservedSupply;\n    }\n\n    function setPresaleStatus(bool _presaleActive) public onlyOwner {\n        presaleActive = _presaleActive;\n    }\n\n    function setSaleStatus(bool _saleActive) public onlyOwner {\n        saleActive = _saleActive;\n    }\n\n    function setPrice(uint256 _price) public onlyOwner {\n        price = _price;\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    function setURI(string memory newuri) public onlyOwner {\n        _setURI(newuri);\n    }\n\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function hasToken(address account) public view returns (bool) {\n        return balanceOf(account, passIndex) > 0;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return price;\n    }\n\n    function getSupplyLeft() public view returns (uint16) {\n        return supplyLeft;\n    }\n\n    function getMaxSupply() public view returns (uint16) {\n        return maxSupply;\n    }\n\n    function getMerkleRoot() public view returns (bytes32) {\n        return merkleRoot;\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function mintPresale(address account, uint8 amount, bytes32[] calldata _merkleProof) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(presaleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(!whitelistClaimed[msg.sender], \"Address has already claimed\");\n        require(amount <= presaleMaxMintsPerTrans, \"Only 1 mint allowed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(account));\n        require(\n            MerkleProof.verify(_merkleProof, merkleRoot, leaf),\n            \"Invalid proof\"\n        );\n\n        _mint(account, passIndex, amount, \"\");\n        whitelistClaimed[msg.sender] = true;\n\n        supplyLeft -= amount;\n    }\n\n    function mint(address account, uint8 amount) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(saleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(amount <= publicMaxMintsPerTrans, \"Only 3 mints allowed\");\n\n        _mint(account, passIndex, amount, \"\");\n\n        supplyLeft -= amount;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155, ERC1155Supply) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a KOK_Contract smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a comprehensive prompt for the KOK_Contract, a smart contract that implements the ERC20 token standard with added features for ownership, blacklisting, and emergency stopping. The contract is designed for the \"KOK Coin\" with a fixed supply and additional mechanisms to control token distribution, such as an airdrop function for initial distribution and the ability to blacklist addresses to prevent them from participating in transactions.\n\nContract Specifications:\n- Inherits from ERC20Interface for standard token functionality and Owned for ownership management.\n- The token has a fixed supply, specified symbol, name, and decimal units.\n- Incorporates a blacklisting feature to restrict certain addresses from transferring or receiving tokens.\n- Includes an emergency stop feature that can halt all token transfers.\n- Allows the owner to distribute tokens through an airdrop to a list of addresses.\n\nKey Functionalities\n1. Initial Setup: On deployment, assigns the total supply of KOK Coins to the contract creator's address.\n2. Token Distribution via Airdrop: Allows the owner to distribute tokens to multiple addresses in one transaction, excluding addresses that already hold tokens.\n3. Blacklist Management: Provides functions for the owner to blacklist or remove addresses from the blacklist, affecting their ability to participate in transactions.\n4. Emergency Stop: Includes functionality to stop or restart the contract, preventing or allowing token transfers.\n5. ERC20 Compliance: Implements standard ERC20 functions for balance queries, transfers, allowance setup, and approval mechanisms, with added checks against the blacklist and stopped status.\n\nImplementation Details:\n- The constructor initializes the contract by setting the total token supply to the owner's balance.\n- The airdrop function iterates through an array of addresses, transferring specified token amounts to each, provided they don't already hold tokens.\n- Blacklisting is managed through a mapping, with events emitted upon changes to the blacklist status of any address.\n- Token transfers and approvals check whether the contract is stopped and if either the sender or recipient is blacklisted, rejecting transactions as necessary.\n- Standard ERC20 functions are modified to integrate checks for the stopped status and blacklist.\n\nSecurity Considerations:\n- The onlyOwner modifier ensures sensitive actions like stopping the contract, managing the blacklist, and performing airdrops are restricted to the contract owner.\n- Blacklist functionality adds a layer of security and control, allowing the owner to prevent malicious actors from participating in the token economy.\n- The stopped state acts as a circuit breaker to halt all token transfers in the event of an emergency, mitigating potential risks or vulnerabilities.\n- Validation checks in transfer functions prevent token losses and ensure that transactions adhere to the defined rules regarding blacklisting and emergency stops.\n"}, {"role": "assistant", "content": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if (balances[_to[i]] > 0) {\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success) {\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif (blackList[msg.sender] > 0) {\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (blackList[_to] > 0) {\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success) {\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif (blackList[_from] > 0) {\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (blackList[_to] > 0) {\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Minttk smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Craft a detailed prompt for the Minttk smart contract, which implements the ERC20 token standard alongside unique features such as Proof of Stake (PoS) mining rewards, a specified distribution of tokens for different purposes, and a minting function that rewards token holders. This contract is designed to manage the \"Minttk\" token with a predefined total supply, incorporating functionalities for ownership management, token distribution, and an incentive mechanism for token holders.\n\nContract Specifications:\n- Inherits from ERC20 for standard token functionality.\n- Utilizes SafeMath for safe arithmetic operations to prevent overflow and underflow.\n- Specifies token characteristics like name, symbol, decimals, and total supply.\n- Defines allocations for crowd sale, PoS mining, corporate reserve, promotion and bounty, and remaining tokens not allocated to PoS mining.\n- Includes an owner-specific modifier for functions that can only be executed by the contract owner.\n\nKey Functionalities:\n1. Initial Token Distribution: Upon deployment, assigns a portion of the total supply to the contract owner's balance.\n2. Token Minting Reward Mechanism: Allows token holders to receive rewards through a minting function, calculated as a percentage of their holdings if certain conditions are met.\n3. Token Transfer and Approval: Implements ERC20 standard functions with checks for blacklisted addresses and ensures that transfers only occur if the sender has sufficient balance.\n4. Ownership and Access Control: Uses an onlyOwner modifier to restrict certain administrative actions to the contract owner.\n5. Emergency Drain Function: Allows the contract owner to transfer all ether held by the contract to their address.\n\nImplementation Details:\n- The constructor initializes the contract, setting the initial token distribution to the owner.\n- The minting function calculates a 2% bonus of the holder's current balance, requiring at least a week between minting actions per address.\n- Token transfers are modified to include a check that prevents execution if the required time since the last minting has not passed, aligning with the minting restrictions.\n- Functions for transferring tokens (transfer, transferFrom), approving spending (approve), and checking allowances (allowance) adhere to ERC20 standards with added custom logic for the contract's features.\n- The contract employs SafeMath library functions to ensure safe arithmetic operations, guarding against common smart contract vulnerabilities.\n\nSecurity Considerations:\n- The onlyOwner modifier provides a mechanism to prevent unauthorized access to critical functions such as drain, ensuring that only the contract owner can perform these actions.\n- Utilizes the SafeMath library to prevent overflow and underflow, enhancing the contract's security by ensuring arithmetic operations are executed safely.\n- Minting restrictions, requiring a minimum interval between minting actions, aim to prevent abuse of the minting reward mechanism.\n- Validation checks in transfer functions ensure that tokens are not sent to the zero address, preventing accidental loss of tokens.\n"}, {"role": "assistant", "content": "contract Minttk is ERC20 { \n    using SafeMath for uint256;\n    string public constant name = \"Minttk\"; // Name of the token\n    string public constant symbol = \"MNT\"; // Symbol of token\n    uint8 public constant decimals = 18; // Decimal of token\n    uint public _totalsupply = 500000000 * 10 ** 18; // 500 million total supply // muliplies dues to decimal precision\n    uint public crowdSale = 60000000 * 10 ** 18; // 60 million in Crowd Sale\n    uint public posMining = 350000000 * 10 ** 18; // 350 million in POS Mining\n    uint public corporateReserve = 80000000 * 10 ** 18; // 80 million in Corporate Reserve\n    uint public promotionBounty = 10000000 * 10 ** 18; // 10 million in Promotion & Bounty\n    uint public remainingToken = 150000000 * 10 ** 18; // 150 million in Remaining Token | Total Supply - POS\n    address public owner; // Owner of this contract\n    mapping(address => uint256) internal mintingDate;\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    \n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    function Minttk() public {\n        balances[msg.sender] = remainingToken;\n        Transfer(0, msg.sender, remainingToken);\n    }\n    \n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalsupply;\n    }\n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    \n    // Token minting function\n    function mint() public {\n        address _customerAddress = msg.sender;\n        uint256 userBalance = balances[_customerAddress];\n        uint256 currentTs = now;\n        uint256 userMintingDate = mintingDate[_customerAddress] + 7 days;\n        require (userBalance > 0);\n        require (currentTs > userMintingDate);\n        mintingDate[_customerAddress] = currentTs;\n        uint256 _bonusAmount = SafeMath.percent(userBalance,2,100,18);\n        balances[_customerAddress] = (uint256)(balances[_customerAddress]).add(_bonusAmount);\n    }\n    \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount ) public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n  \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        \n        address _customerAddress = msg.sender;\n        uint256 currentTs = now;\n        uint256 userMintingDate = mintingDate[_customerAddress] + 7 days;\n        require (currentTs > userMintingDate);\n        \n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    // Transfer the balance from owner's account to another account\n    function transferTokens(address _to, uint256 _amount) private returns (bool success) {\n        require( _to != 0x0);       \n        require(balances[address(this)] >= _amount && _amount > 0);\n        balances[address(this)] = (balances[address(this)]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(address(this), _to, _amount);\n        return true;\n    }\n \n    function drain() external onlyOwner {\n        owner.transfer(this.balance);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a TattooSkullzSociety smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a TattooSkullzSociety smart contract, which is an ERC721 non-fungible token (NFT) contract designed to manage the minting, sale, and distribution of a unique digital art collection called \"Skullz\". The contract incorporates features for a public sale, an allowlist (whitelist) sale, setting a provenance record, and managing base URI for metadata. It enforces limits on the total supply and the number of tokens that can be minted per transaction both in the public sale and allowlist sale.\n\nContract Specifications:\n- Inherits ERC721 for NFT functionality and ERC721Enumerable for enumerable extensions, along with Ownable for ownership management.\n- Defines constants for maximum supply, maximum tokens mintable per public transaction, reserve minting amount, and price per token.\n- Utilizes a mapping to manage the allowlist with the number of tokens addresses are allowed to mint.\n- Includes a provenance record and a variable for an extended base URI for metadata.\n\nKey Functionalities:\n1. Initial Setup: Upon deployment, initializes the NFT collection with a name and symbol.\n2. Allowlist Management:\n    - Ability to activate or deactivate the allowlist sale.\n    - Functions to set the allowlist and specify the number of tokens each address is allowed to mint.\n    - A method to check the number of tokens an address is eligible to mint from the allowlist.\n3. Minting Operations:\n    - Allowlist minting function that checks eligibility and enforces limits based on the allowlist.\n    - Public minting function available when the public sale is active, with checks on purchase limits and total supply constraints.\n    - Reserve minting function for the contract owner to mint tokens up to a specified reserve limit.\n4. Sale and Contract Management:\n    - Functions to toggle the public sale state.\n    - Withdraw function for the owner to transfer contract's Ether balance.\n    - Ability to set the provenance hash and base URI for the collection.\n\nImplementation Details:\n- The contract uses onlyOwner modifier to restrict certain management functions to the owner, such as toggling sale states, modifying the allowlist, and setting provenance and base URI.\n- Minting functions enforce checks for sale activation, maximum mint limits per transaction, total supply limits, and correct Ether value sent for the number of tokens being minted.\n- The contract overrides _baseURI to return a custom URI for token metadata, supporting dynamic content.\n\nSecurity Considerations:\n- Utilizes onlyOwner for critical functions to mitigate unauthorized access and potential vulnerabilities in contract management.\n- Includes sale state flags (isAllowListActive, saleIsActive) to control minting operations and prevent unauthorized minting outside of designated sale periods.\n- Implements checks in minting functions to prevent exceeding the maximum supply, ensuring scarcity and integrity of the collection.\n- Employs checks for Ether value sent in minting transactions to match the required price, protecting against underpayment.\n"}, {"role": "assistant", "content": "contract TattooSkullzSociety is ERC721, ERC721Enumerable, Ownable {\n    string public PROVENANCE;\n    string private _baseURIextended;\n\n    bool public isAllowListActive = false;\n    bool public saleIsActive = false;\n    \n    uint256 public constant MAX_SUPPLY = 5000;\n    uint256 public constant MAX_PUBLIC_MINT = 22;\n    uint256 public constant RESERVE_MINT = 222;\n    uint256 public constant PRICE_PER_TOKEN = 0.08 ether;\n\n    mapping(address => uint8) private _allowList;\n\n    constructor() ERC721(\"TattooSkullzSociety\", \"SKULLZ\") {}\n\n    // Whitelist\n    function setIsAllowListActive(bool _isAllowListActive) external onlyOwner {\n        isAllowListActive = _isAllowListActive;\n    }\n\n    function setAllowList(address[] calldata addresses, uint8 numAllowedToMint) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            _allowList[addresses[i]] = numAllowedToMint;\n        }\n    }\n\n    function numAvailableToMint(address addr) external view returns (uint8) {\n        return _allowList[addr];\n    }\n\n    function mintAllowList(uint8 numberOfTokens) external payable {\n        uint256 ts = totalSupply();\n        require(isAllowListActive, \"Allow list is not active\");\n        require(numberOfTokens <= _allowList[msg.sender], \"Exceeded max available to purchase\");\n        require(numberOfTokens <= MAX_PUBLIC_MINT, \"Exceeded max token purchase\");\n        require(ts + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max tokens\");\n        require(PRICE_PER_TOKEN * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n\n        _allowList[msg.sender] -= numberOfTokens;\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, ts + i);\n        }\n    }\n\n    function setSaleState(bool newState) public onlyOwner {\n        saleIsActive = newState;\n    }\n\n    function mint(uint numberOfTokens) public payable {\n        uint256 ts = totalSupply();\n        require(saleIsActive, \"Sale must be active to mint tokens\");\n        require(numberOfTokens <= MAX_PUBLIC_MINT, \"Exceeded max token purchase\");\n        require(ts + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max tokens\");\n        require(PRICE_PER_TOKEN * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, ts + i);\n        }\n    }\n\n    function reserve(uint numberOfTokens) public onlyOwner {\n      uint supply = totalSupply();\n      uint i;\n      for (i = 0; i < numberOfTokens; i++) {\n          _safeMint(msg.sender, supply + i);\n      }\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function setProvenance(string memory provenance) public onlyOwner {\n        PROVENANCE = provenance;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\n        _baseURIextended = baseURI_;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a ERC721PresetMinterPauserAutoId smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Design an ERC721 token contract, ERC721PresetMinterPauserAutoId, incorporating automatic token ID assignment, minting authorization, and pausable transfers. This advanced template extends the standard ERC721 token capabilities, integrating AccessControl for role management. It provides mechanisms for minting new tokens with sequential IDs, pausing/unpausing token transfers for emergency or administrative reasons, and controlling token URI base setting with restrictions.\n\nContract Specifications:\n- Inherits from ERC721Enumerable, ERC721Burnable, ERC721Pausable, and AccessControlEnumerable for a rich set of features including token enumeration, burnability, pausability, and role-based access control.\n- Utilizes Counters to maintain a sequential token ID tracker, ensuring unique and incrementing identifiers for each minted token.\n- Defines MINTER_ROLE and PAUSER_ROLE to restrict minting and pausing capabilities to authorized accounts.\n- Implements a limit on the number of times the base token URI can be reset, enhancing security and predictability of token metadata.\n\nKey Functionalities:\n1. Role-based Permissions: Enforces that only accounts with specific roles can mint new tokens, pause or unpause the contract.\n2. Sequential Token IDs: Automatically assigns token IDs in a sequential manner, mitigating the risk of collision or gaps due to token burning.\n3. Pausable Transfers: Allows the contract to halt all token transfers in the case of an emergency or need for administrative intervention.\n4. Limited URI Resets: Provides the functionality to set and reset the base token URI, with a strict limit on the number of resets to prevent abuse.\n5. Comprehensive Interface Support: Guarantees compatibility with a wide array of ERC standards and interfaces through meticulous implementation of supportsInterface.\n\nImplementation Details:\n- The constructor initializes the contract with given name and symbol, and assigns the deploying account (_msgSender()) all roles necessary for administration.\n- The setBaseURI function updates the base URI for token metadata, constrained by a maximum number of allowed resets to maintain integrity.\n- Minting is streamlined through the mint function, which ensures that the minter has the appropriate role and increments the token ID counter upon each call.\n- Pausing and unpausing token transfers is managed through pause and unpause functions, respectively, each guarded by the PAUSER_ROLE.\n- Overrides _beforeTokenTransfer and supportsInterface to integrate the functionalities of its parent contracts effectively, ensuring that token transfers adhere to the pausable conditions and that the contract accurately reports its supported interfaces.\n\nSecurity Considerations:\n- Role-based access control is employed to safeguard against unauthorized minting, URI resets, and changes to the contract's operational state.\n- The use of a counter for token IDs prevents errors or vulnerabilities associated with manual ID assignment.\n- The pausability feature offers a mechanism to respond to security threats by freezing token transfers until the issue is resolved.\n- Limitations on the number of times the base URI can be reset protect against potential manipulation or confusion regarding token metadata locations.\n"}, {"role": "assistant", "content": "contract ERC721PresetMinterPauserAutoId is Context, AccessControlEnumerable, ERC721Enumerable, ERC721Burnable, ERC721Pausable {\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    Counters.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n    \n    uint8 private constant MAX_URI_RESETS_ALLOWED = 1;\n    uint8 public uriResetCount = 0;\n\n    // Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the account that deploys the contract.\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n    \n    \n    // Sets `_baseTokenURI`. Resets allowed only `MAX_URI_RESETS_ALLOWED` no of times\n    function setBaseURI(string memory baseTokenURI) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"You don't have permission to do this.\");\n        require(uriResetCount <= MAX_URI_RESETS_ALLOWED, \"Max resets allowed is breached now\");\n        _baseTokenURI = baseTokenURI;\n        uriResetCount++;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    // Creates a new token for `to`. Its token ID will be automatically assigned (and available on the emitted {IERC721-Transfer} event), and the token URI autogenerated based on the base URI passed at construction.\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    // Pauses all token transfers.\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    //  Unpauses all token transfers.\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Wallstreetbets smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Design an ERC20 token contract named Wallstreetbets, focusing on the theme of stocks and options trading within the cryptocurrency space. This contract includes advanced features like token burning and ownership transfer, adhering strictly to the ERC20 standard. It utilizes SafeMath for all arithmetic operations to prevent overflow and underflow vulnerabilities.\n\nContract Specifications:\n- Implements the ERC20 token standard with additional functionalities.\n- Sets a fixed total supply of 65 million tokens, factoring in 18 decimal places for precision.\n- Includes a modifier to restrict certain functions to the contract owner only.\n- Employs SafeMath library for safe arithmetic operations.\n\nKey Functionalities:\n1. Token Ownership: Initially assigns the entire token supply to the contract creator, marking them as the owner.\n2. Token Burning: Allows the owner to reduce the total supply by permanently destroying a specified amount of tokens.\n3. Transfer Ownership: Enables the current owner to transfer ownership of the contract to a new address, along with the balance associated with the owner's account.\n4. ERC20 Compliance: Supports standard functions such as balanceOf, transfer, transferFrom, approve, and allowance to interact with token balances and allowances.\n5. Safety Measures: Integrates the SafeMath library for all mathematical operations to prevent common vulnerabilities in smart contracts.\n\nImplementation Details:\n- The constructor initializes the contract by setting the creator as the owner and allocating the entire token supply to them.\n- The burntokens function allows the owner to decrease the total supply, requiring the invocation by the current owner only.\n- Ownership transfer is facilitated through the transferOwnership function, transferring the owner's balance to the new owner and updating the owner address.\n- Standard ERC20 functions are implemented with additional checks to ensure the safety and integrity of transactions, such as non-zero addresses and sufficient balances.\n\nSecurity Considerations:\n- Utilizes the onlyOwner modifier to protect sensitive functions that could alter the contract's state or token distribution.\n- Incorporates the SafeMath library to guard against arithmetic overflow and underflow, enhancing contract security.\n- Enforces checks for zero addresses in token transfers and approvals to prevent loss of tokens and ensure transactions are intentional and valid.\n- Provides a mechanism for ownership transfer, ensuring continuity of contract management in the event of changes in ownership or control.\n"}, {"role": "assistant", "content": "contract Wallstreetbets is ERC20 {\n    using SafeMath for uint256;\n    string public constant symbol = \"Wallstreetbets\";\n    string public constant name = \"Wallstreetbets stocks and Options trading\";\n    uint public constant decimals = 18;\n    uint256 _totalSupply = 65999999 * 10 ** 18; // 65 million Total Supply including 18 decimal\n\n    // Owner of this contract\n    address public owner;\n     \n    // Balances for each account\n    mapping(address => uint256) balances;\n\n    // Owner of account approves the transfer of an amount to another account\n    mapping(address => mapping (address => uint256)) allowed;\n\n    // Functions with this modifier can only be executed by the owner\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    // Constructor\n    constructor () public {\n        owner = msg.sender;\n        balances[owner] = _totalSupply;\n        emit Transfer(0, owner, _totalSupply);\n    }\n    \n    function burntokens(uint256 tokens) public onlyOwner {\n        _totalSupply = (_totalSupply).sub(tokens);\n    }\n\n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalSupply;\n    }\n    function balanceOf(address _owner)public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount)public returns (bool ok) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n         \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount )public returns (bool ok) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    function approve(address _spender, uint256 _amount)public returns (bool ok) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n     }\n  \n    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n        \n     // In case the ownership needs to be transferred\n\tfunction transferOwnership(address newOwner) external onlyOwner\t{\n\t    uint256 x = balances[owner];\n\t    require( newOwner != 0x0);\n\t    balances[newOwner] = (balances[newOwner]).add(balances[owner]);\n\t    balances[owner] = 0;\n\t    owner = newOwner;\n\t    emit Transfer(msg.sender, newOwner, x);\n\t}\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a ChubbyCherubs smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create an ERC721 token smart contract named ChubbyCherubs that manages a limited collection of unique digital assets. This contract includes functionality for minting tokens up to a capped maximum, setting and updating the base token URI for metadata, toggling the sale state, withdrawing contract funds, and airdropping tokens to specific addresses. It emphasizes owner control for critical operations and integrates a public sale mechanism with price setting.\n\nContract Specifications:\n- Inherits ERC721 standards for NFT functionality and Ownable for ownership management.\n- Sets a fixed cap (MAX_CHUB) of 1111 tokens to maintain exclusivity.\n- Implements a variable token price, initially set to 0.07 Ether, adjustable by the owner.\n- Incorporates a switch to open or close the token sale, allowing for phased release.\n- Tracks the total number of minted tokens to prevent exceeding the maximum supply.\n\nKey Functionalities:\n1. Initialization and Base URI Management:\n    - Initialize the contract with a base token URI.\n    - Provide an onlyOwner function to update the base URI as needed.\n2. Minting Price and Sale State:\n    - Allow the contract owner to set and adjust the minting price.\n    - Implement a function to toggle the sale's open/closed state, enabling or disabling public minting.\n3. Public Minting Functionality:\n    - Enable users to mint a specified number of tokens within set limits per transaction, provided the sale is open and the maximum supply has not been reached.\n    - Charge the correct amount of Ether for the number of tokens minted and enforce a maximum mint limit per transaction for non-owner minters.\n4. Airdrop Functionality:\n    - Offer an onlyOwner function to airdrop tokens to a list of addresses, ensuring the operation does not exceed the maximum supply or mint tokens to the null address.\n5. Withdrawal of Contract Funds:\n    - Implement an onlyOwner function to withdraw all Ether collected by the contract through minting operations.\n\nImplementation Details:\n- The constructor sets the initial base URI for token metadata, essential for linking each token to its digital asset.\n- setBaseURI and setPrice functions allow the owner to update metadata pathways and token price, reflecting operational flexibility.\n- flipSaleState toggles the sale's active status, enabling or disabling public minting.\n- The mint function includes checks for sale status, minting limits per transaction, total supply constraints, and correct Ether values for transactions not initiated by the owner.\n- Utilizes an internal handleMint function to abstract the minting process, streamlining the creation of tokens and emission of events upon minting.\n\nSecurity Considerations:\n- Adheres to the onlyOwner modifier for administrative actions, mitigating unauthorized alterations to the contract's critical parameters.\n- Ensures that minting cannot exceed the defined maximum supply, preserving the collection's exclusivity and integrity.\n- Protects against sending Ether to the contract inadvertently through controlled sale mechanisms and validated fund withdrawals.\n- Incorporates checks for non-zero addresses in minting and airdropping functions to prevent loss of tokens.\n"}, {"role": "assistant", "content": "contract ChubbyCherubs is ERC721, Ownable {\n    uint256 private mintCount = 0;\n\n    uint256 public constant MAX_CHUB = 1111;\n    uint256 public price = 70000000000000000; //0.07 Ether\n    string baseTokenURI;\n    bool public saleOpen;\n\n    event ChubMinted(uint256 totalMinted);\n\n    constructor(string memory baseURI) ERC721(\"Chubby Cherubs\", \"CHUB\") {\n        setBaseURI(baseURI);\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        baseTokenURI = baseURI;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return mintCount;\n    }\n\n    function setPrice(uint256 _newPrice) external onlyOwner {\n        price = _newPrice;\n    }\n\n    // Close sale if open, open sale if closed\n    function flipSaleState() external onlyOwner {\n        saleOpen = !saleOpen;\n    }\n\n    function withdrawAll() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function airdrop(address[] calldata _recipients) external onlyOwner {\n        uint256 supply = totalSupply();\n        require(\n            supply + _recipients.length <= MAX_CHUB,\n            \"Airdrop will exceed maximum supply of CHUB\"\n        );\n        require(_recipients.length != 0, \"Address not found\");\n        mintCount += _recipients.length;\n        for (uint256 i = 0; i < _recipients.length; i++) {\n            require(_recipients[i] != address(0), \"Airdrop to Null address\");\n            handleMint(_recipients[i], ++supply);\n        }\n    }\n\n    function mint(uint256 _count) external payable {\n        uint256 supply = totalSupply();\n        require(supply + _count <= MAX_CHUB, \"Exceeds maximum supply of CHUB\");\n        require(_count > 0, \"Minimum 1 CHUB has to be minted per transaction\");\n\n        if (msg.sender != owner()) {\n            require(saleOpen, \"Sale is not open yet\");\n            require(\n                _count <= 10,\n                \"Maximum 10 Chubby Cherubs can be minted per transaction\"\n            );\n            require(\n                msg.value >= price * _count,\n                \"Ether sent with this transaction is not correct\"\n            );\n        }\n\n        mintCount += _count;\n\n        for (uint256 i = 0; i < _count; i++) {\n            handleMint(msg.sender, ++supply);\n        }\n    }\n\n    function handleMint(address _to, uint256 tokenId) private {\n        _safeMint(_to, tokenId);\n        emit ChubMinted(tokenId);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a LionGame smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract for \"LionGame,\" an NFT collection based on the ERC721 standard, featuring mechanisms for free and public minting, owner-exclusive giveaways, and sale state management. This contract should allow for setting dynamic pricing, minting limits, and supply caps, alongside ensuring secure interactions through reentrancy guards.\n\nContract Structure Overview:\n- Inheritance and Key Features: Utilize ERC721Enum for token enumeration, Ownable for ownership privileges, and ReentrancyGuard for preventing reentrant calls.\n- Sale Configuration: Implement variables to manage the minting cost (cost), maximum supply (maxSupply), maximum mint amount per transaction (maxMint), and the sale status (status).\n\nFunctionality Requirements:\n1. Initialization and Metadata Management:\n    - Initialize the contract with collection name, symbol, and base URI for token metadata.\n    - Provide a function to set or update the base URI.\n2. Minting Functionality:\n    - Implement a freeMint function for minting without cost under certain conditions, like before sale activation.\n    - Create a mint function for public minting that charges Ether based on the specified cost and mint amount.\n    - Ensure minting functions respect the maximum supply and per-transaction mint limits.\n3. Administrative Functions:\n    - Allow the contract owner to mint tokens directly to a given address without cost (giveAway).\n    - Enable the owner to adjust minting cost, maximum mint amount, and the total supply cap.\n    - Provide a mechanism to toggle the sale status, enabling or disabling public minting.\n4. Withdrawal of Funds:\n    - Implement a withdrawal function for the contract owner to transfer collected Ether to their address.\n\nSafety Considerations:\n- Apply require statements to validate minting conditions, such as sale status, mint amount limits, supply caps, and sufficient payment.\n- Use the nonReentrant modifier to safeguard against reentrancy attacks in minting and withdrawal functions.\n\nImplementation Details:\n- Token URI Generation: Override the tokenURI function to concatenate the base URI with the token ID, ensuring a correct metadata endpoint for each NFT.\n- Dynamic Sale Parameters: Allow the owner to dynamically adjust key sale parameters (e.g., cost, max mint amount, sale status) to adapt to changing conditions or community feedback.\n- Supply and Minting Tracking: Utilize the totalSupply function from ERC721Enum to keep track of the current supply and ensure compliance with the minting limits and supply cap."}, {"role": "assistant", "content": "contract LionGame is ERC721Enum, Ownable, ReentrancyGuard {\n\tusing Strings for uint256;\n\tstring public baseURI;\n\n\tuint256 public cost = 0.05 ether;\n\tuint256 public maxSupply = 777;\n\tuint256 public maxMint = 25;\n\tbool public status = false;\n\n\tconstructor(string memory _name, string memory _symbol, string memory _initBaseURI) \n    \n    ERC721(_name, _symbol){\n        setBaseURI(_initBaseURI);\n\t}\n\n\tfunction _baseURI() internal view virtual returns (string memory) {\n\t    return baseURI;\n\t}\n\n    // free minting\n\tfunction freeMint(uint256 _mintAmount) public nonReentrant {\n        uint256 s = totalSupply();\n        require(!status, \"Off\" );\n        require(_mintAmount > 0, \"0\" );\n        require(_mintAmount <= maxMint, \"Too many\" );\n        require(s + _mintAmount <= maxSupply, \"Max\" );\n\n        for (uint256 i = 0; i < _mintAmount; ++i) {\n            _safeMint(msg.sender, s + i, \"\");\n\t    }\n\t    \n        delete s;\n\t}\n\n\t// public minting\n\tfunction mint(uint256 _mintAmount) public payable nonReentrant {\n        uint256 s = totalSupply();\n        require(status, \"Off\" );\n        require(_mintAmount > 0, \"0\" );\n        require(_mintAmount <= maxMint, \"Too many\" );\n        require(s + _mintAmount <= maxSupply, \"Max\" );\n        require(msg.value >= cost * _mintAmount);\n\n        for (uint256 i = 0; i < _mintAmount; ++i) {\n            _safeMint(msg.sender, s + i, \"\");\n        }\n\n        delete s;\n\t}\n\n\t// admin minting\n\tfunction giveAway(address recipient) external onlyOwner {\n        uint256 s = totalSupply();\n        require(s <= maxSupply, \"Max\" );\n        _safeMint(recipient, s, \"\" );\n        delete s;\t\n\t}\n\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: Nonexistent token\");\n        string memory currentBaseURI = _baseURI();\n        return bytes(currentBaseURI).length > 0\t? string(abi.encodePacked(currentBaseURI, tokenId.toString())) : \"\";\n\t}\n\n\tfunction setCost(uint256 _newCost) public onlyOwner {\n\t    cost = _newCost;\n\t}\n\n\tfunction setMaxMintAmount(uint256 _newMaxMintAmount) public onlyOwner {\n\t    maxMint = _newMaxMintAmount;\n\t}\n\n\tfunction setBaseURI(string memory _newBaseURI) public onlyOwner {\n\t    baseURI = _newBaseURI;\n\t}\n\n\tfunction setSaleStatus(bool _status) public onlyOwner {\n\t    status = _status;\n\t}\n\n\tfunction withdraw() public onlyOwner {\n\t    payable(msg.sender).call{value: address(this).balance}(\"\");\n\t}\n\n    function setmaxSupply(uint256 _newMaxSupply) public onlyOwner {\n\t    maxSupply = _newMaxSupply;\n\t}\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a PACFounder smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The PACFounder contract is an ERC721 token designed to mint \"PACDAO FOUNDER\" tokens with an increasing minting price mechanism, where the minimum price adjusts based on the transaction value and a predefined formula. It incorporates a unique feature where, for the first 20 tokens minted, an additional token is minted and sent to a beneficiary address, alongside the capability for the beneficiary to withdraw accumulated funds, update the beneficiary address, set individual and default token URIs. This smart contract uses a combination of payable, nonpayable, and admin functions to manage minting, pricing, and token metadata, ensuring dynamic pricing and exclusive control over key contract parameters by the beneficiary.\n\nContract Structure Overview:\n- Core Features: Leverage ERC721 for NFT functionalities, with additional logic to adjust minting price dynamically and to mint a token to a beneficiary for every public mint until a specified limit.\n- Dynamic Pricing and Minting Limit: Implement variables for the minimum minting price (minPrice), the beneficiary address (beneficiary), and a counter for the current token ID (currentId).\n\nFunctionality Requirements:\n1. Initialization and Base URI Setting:\n    - Initialize the contract with the DAO's name and symbol, and set the beneficiary address and base URI for token metadata.\n2. Minting with Dynamic Pricing:\n    - Create a mint function that allows public minting if the sent value meets or exceeds the current minimum price. Adjust the minting price based on the total amount sent by minters.\n    - Automatically mint an additional token to the beneficiary address for early mints, up to a defined limit.\n3. Administrative and Beneficiary Controls:\n    - Allow the beneficiary to withdraw contract balance, update the beneficiary address, set individual token URIs, and update the default metadata URI.\n4. Pricing Adjustment Logic:\n    - Implement logic within the minting function to increase the minimum price based on the amount sent by the minters and a predefined increment strategy.\n\nSafety Considerations:\n- Validate that the minting price meets the required minimum and adjust it based on a transparent and fair mechanism.\n- Ensure that the contract's balance withdrawal and metadata management functionalities are restricted to the beneficiary address.\n\nImplementation Details:\n- Automatic Beneficiary Minting: For the initial mints, alongside every public mint, automatically issue a token to the beneficiary address, ensuring that the beneficiary receives a portion of the total minted tokens.\n- Dynamic Price Calculation: Adjust the minting price dynamically to reflect the demand and participation in the minting process, ensuring the price is rounded to prevent fractional Wei issues.\n- Token Metadata Management: Provide functionality for the beneficiary to update the default metadata URI for new mints and to set or update metadata URIs for individual tokens.\n- Balance Withdrawal: Implement a secure withdrawal function that allows the beneficiary to transfer the contract's Ether balance to their address."}, {"role": "assistant", "content": "contract PACFounder is ERC721 {\n    uint256 public minPrice = 100000000000000;\n    address payable private beneficiary;\n    uint256 public currentId;\n    string defaultMetadata = \"QmcnEZQiGVzPonWS2MENbdY8DkwhWcCW7YBQNk5yHYF112\";\n\n    constructor (address payable _beneficiary) public ERC721 (\"PACDAO FOUNDER\", \"PAC-F\") {\n        beneficiary = _beneficiary;\n        _setBaseURI(\"ipfs://\");\n    }\n\n    function mint() public payable {\n\t\trequire(msg.value >= minPrice, \"Must pay more\");\n\t\tcurrentId += 1;\n\t\t_safeMint(msg.sender, currentId);\n\t\t_setTokenURI(currentId, defaultMetadata);\n\t\tuint _target = minPrice * 1075000000000000000 / 1e18;\n\t\tif (_target - minPrice < 1e14) {\n\t\t\t_target = minPrice + 1e14;\n\t\t}\n\n\t\tif (currentId < 20) {\n\t\t\tcurrentId += 1;\n\t\t\t_safeMint(beneficiary, currentId);\n\t\t\t_setTokenURI(currentId, defaultMetadata);\n\t\t}\n\n\t\tif (msg.value > _target) {\n\t\t\tminPrice = msg.value + 1e14;\n\t\t} else {\n\t\t\tminPrice = _target;\n\t\t}\n\n\t\tminPrice = minPrice / 1e14 * 1e14;\n\t}\n\n\t// Nonpayable Functions\n\tfunction withdraw() public {\n\t\tbeneficiary.transfer(address(this).balance);\n\t}\n\n\t// Admin Functions\n\tfunction updateBeneficiary(address payable _newBeneficiary) public {\t\t\n\t\trequire(msg.sender == beneficiary);\n\t\tbeneficiary = _newBeneficiary;\n\t}\n\n\tfunction setTokenUri(uint256 _tokenId, string memory _newUri) public {\n\t\trequire(msg.sender == beneficiary);\n\t\t_setTokenURI(_tokenId, _newUri);\n\t}\n\n\tfunction setDefaultMetadata(string memory _newUri) public {\n\t\trequire(msg.sender == beneficiary);\n\t\tdefaultMetadata = _newUri;\n\t}\n\n\t// Fallback Functions\n\treceive() external payable {}\n\tfallback() external payable {}\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a SupernerdsMeta smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The SupernerdsMeta contract is an ERC721 token that incorporates several advanced features such as enumerable functionality for easy tracking of token ownership, access control for role-based permissions, and contract-wide royalties following the ERC2981 standard. It is designed with a capped total supply of 5555 tokens, from which a specific number is reserved for special holders, and it supports minting operations controlled by roles, specifically a MINTER_ROLE for issuing new tokens both for general sale and reserved allocations. The contract allows for dynamic setting of base token URI for metadata, and it includes functionality to set and update royalty information, ensuring creators or specified addresses receive a percentage of sales from secondary market transactions.\n\nContract Structure Overview:\n- Core Features: Utilize ERC721Enumerable for token enumeration, AccessControl for role-based permissions, and ERC2981ContractWideRoyalties for handling royalties.\n- Supply Management: Define variables for total supply cap (_totalCap), tokens available for sale (_availableForSale), and reserved tokens (_reserveTokens).\n- Royalty Configuration: Implement variables and functions to manage royalty information, including the recipient address and the royalty percentage.\n\nFunctionality Requirements:\n1. Initialization and Role Setup:\n    - Initialize the contract with collection name and symbol.\n    - Assign the DEFAULT_ADMIN_ROLE and MINTER_ROLE to the contract deployer.\n2. Royalty Management:\n    - Provide a function to set or update the royalty recipient and value, ensuring only an admin can execute this action.\n3. Base URI Management:\n    - Allow for setting and updating the base URI for token metadata, restricted to admin role holders.\n4. Minting Operations:\n    - Enable minting to specified addresses, with checks to prevent exceeding the total supply cap and distinguish between general sale minting and reserved minting.\n    - Ensure mint functions are accessible only by holders of the MINTER_ROLE.\n5. Supply and Cap Checks:\n    - Enforce the total supply cap and individual caps on sale and reserved tokens during the minting process.\n6. Safety Considerations:\n    - Apply require statements to enforce role permissions, non-zero addresses, and supply limits in minting functions.\n    - Use counters to safely increment token IDs and manage mint counts for both sale and reserved tokens.\n\nImplementation Details:\n- Royalty Configuration and Enforcement: Implement ERC2981 standards to set and enforce royalties on secondary sales, ensuring a fair distribution of proceeds.\n- Dynamic Minting Limits: Dynamically manage minting based on the defined caps for total supply, sale-available tokens, and reserved tokens, adjusting mint availability as necessary.\n- Interface Support: Override supportsInterface to accurately reflect the support for ERC721, AccessControl, and ERC2981 interfaces.\n- Access Control for Administrative Actions: Secure sensitive contract interactions such as setting base URI and configuring royalties behind admin and minter role checks."}, {"role": "assistant", "content": "contract SupernerdsMeta is ERC721Enumerable, AccessControl, ERC2981ContractWideRoyalties {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    string public _baseTokenURI = \"\";\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    uint256 public _totalCap = 5555; //total number of tokens\n    uint256 public _availableForSale = 5154; // _totalCap - _availableForSale\n    uint256 public _reserveTokens = 401; //reserve tokens for Alpha Holders\n\n    uint256 public royaltyValue = 60000000000000000; // Royalty 6% in eth decimals\n    address public royaltyRecipient; // Royalty Recipient Main wallet (OpenSea)\n\n    uint256 public _mintedSale; // token minted in the all the sales\n    uint256 public _mintedReserved; // token minted for the alpha nerd hodlers\n\n    constructor() ERC721(\"Supernerds Meta\", \"Supernerds Meta\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(MINTER_ROLE, _msgSender());\n    }\n\n    // Sets the royalty value and recipient\n    function setRoyalties(address recipient, uint256 value) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"only admin allowed\");\n        require(\n            recipient != 0x0000000000000000000000000000000000000000,\n            \"S16NFT: Royalty recipient address cannot be Zero Address\"\n        );\n        require(value > 0, \"S16NFT: invalid royalty percentage\");\n        _setRoyalties(recipient, value);\n\n        royaltyRecipient = recipient;\n        royaltyValue = value;\n    }\n\n    function cap() external view returns (uint256) {\n        return _totalCap;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, AccessControl, ERC2981Base) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    function setBaseURI(string memory baseURI) public {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\n            \"Caller is not a admin\"\n        );\n\n        _baseTokenURI = baseURI;\n    }\n\n    function mint(address _mintTo) external returns (bool) {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Caller is not a minter\");\n        require(_mintTo != address(0), \"ERC721: mint to the zero address\");\n        _tokenIds.increment();\n        uint256 totalSupply = totalSupply();\n        require(_mintedSale <= _availableForSale, \"sale minting completed\");\n        require(\n            totalSupply + 1 <= _totalCap,\n            \"Cap reached, maximum 5555 mints possible\"\n        );\n\n        _safeMint(_mintTo, _tokenIds.current());\n        _mintedSale++;\n\n        return true;\n    }\n\n    function mintReserve(address _mintTo) external returns (bool) {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Caller is not a minter\");\n        require(_mintTo != address(0), \"ERC721: mint to the zero address\");\n        _tokenIds.increment();\n        uint256 totalSupply = totalSupply();\n        require(_mintedReserved <= _reserveTokens, \"reserved sale completed\");\n        require(\n            totalSupply + 1 <= _totalCap,\n            \"Cap reached, maximum 5555 mints possible\"\n        );\n        _safeMint(_mintTo, _tokenIds.current());\n\n        _mintedReserved++;\n\n        return true;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Poolboys smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The Poolboys contract is an ERC721 token featuring a collection of 4444 uniquely identifiable tokens, with built-in mechanisms for public sale control, price setting, and withdrawal of contract funds by the owner. It incorporates a non-fungible token minting system that allows for the minting of a specified number of tokens per transaction, subject to a maximum purchase limit and the total supply cap, alongside a public sale toggle function for starting or pausing token sales. Additionally, the contract includes advanced features like setting a base URI for token metadata, reserving tokens for giveaways, and dynamically establishing a collection starting index post-sale, coupled with the ability to set a provenance hash to ensure the authenticity and origin of the artwork.\n\nContract Structure Overview:\n- Core Features: Leverage ERC721 for NFT functionalities, Ownable for ownership privileges, and ReentrancyGuard for preventing reentrant calls.\n- Sale and Collection Parameters: Implement variables for NFT price (pboyPrice), maximum purchase amount (maxPurchase), total NFTs (MAX_PBOYS), and sale state (publicSaleActive).\n- Provenance and Starting Index: Define variables for storing the collection's provenance hash (PBOY_PROVENANCE) and for calculating the starting index (collectionStartingIndex, collectionStartingIndexBlock) post-sale.\n\nFunctionality Requirements:\n1. Initial Setup and Metadata Management:\n    - Initialize the contract with the collection's name and symbol.\n    - Allow the contract owner to set the base URI for token metadata.\n2. Minting Operations:\n    - Facilitate NFT minting to a specified address, ensuring adherence to the maximum purchase limit and total supply cap.\n    - Enable public minting during the active sale period, with Ether payment validation.\n    - Reserve a specified number of NFTs for giveaways or promotional purposes by the contract owner.\n3. Sale Management:\n    - Provide a function to toggle the public sale state, enabling or disabling minting.\n4. Withdrawal of Contract Funds:\n    - Implement a secure withdrawal function for transferring the contract's Ether balance to the owner's address.\n5. Collection Starting Index and Provenance:\n    - After the sale begins, calculate the collection's starting index based on blockchain data to ensure fairness and unpredictability.\n    - Set and update the collection's provenance hash as an immutable record of the NFTs' metadata integrity.\n6. Safety Considerations:\n    - Apply require statements to enforce maximum purchase limits, total supply constraints, correct Ether payments, and valid operational states.\n    - Use the nonReentrant modifier on functions involving Ether transfers to protect against reentrancy attacks.\n\nImplementation Details:\n- Dynamic Starting Index Calculation: Calculate the starting index for the collection in a manner that remains unpredictable until after sales commence, ensuring equitable distribution.\n- Provenance Hash Setting: Securely record the provenance of the collection to maintain transparency and trust regarding the originality and integrity of the NFT metadata.\n- Base URI for Metadata: Override the _baseURI function to return the set base URI, ensuring correct resolution of NFT metadata."}, {"role": "assistant", "content": "contract Poolboys is ERC721, Ownable, ReentrancyGuard {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    uint256 private collectionStartingIndexBlock;\n    uint256 public collectionStartingIndex;\n    string public PBOY_PROVENANCE = \"\";\n\n    uint256 public pboyPrice = 10000000000000000; // 0.01 ETH\n    uint256 public constant maxPurchase = 30;\n    uint256 public constant MAX_PBOYS = 4444;\n\n    bool public publicSaleActive = false;\n\n    string private _baseURIextended;\n\n    constructor() ERC721(\"Poolboys\", \"PBOY\") {}\n\n    function withdraw() external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function setPrice(uint256 newPrice) external onlyOwner {\n        pboyPrice = newPrice;\n    }\n\n    // Set base for the reveal\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\n        _baseURIextended = baseURI_;\n    }\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    // Returns the total current supply\n    function totalSupply() external view returns (uint256) {\n        return _tokenIdCounter.current();\n    }\n\n    // Pause sale if active, make active if paused\n    function flipSaleState() external onlyOwner {\n        publicSaleActive = !publicSaleActive;\n    }\n\n    function _mintToken(address _to, uint numberOfTokens) private {\n        require(numberOfTokens <= maxPurchase, \"Can only mint 30 tokens at a time\");\n        require(_tokenIdCounter.current() + numberOfTokens <= MAX_PBOYS, \"Purchase would exceed max supply\");\n\n        for (uint256 i; i < numberOfTokens; i++) {\n            uint256 tokenId = _tokenIdCounter.current();\n            if (tokenId < MAX_PBOYS) {\n                _tokenIdCounter.increment();\n                _safeMint(_to, tokenId);\n            }\n        }\n    }\n\n    // Set Poolboys aside for giveaways\n    function reserveToken(address _to, uint numberOfTokens) external onlyOwner {\n        _mintToken(_to,numberOfTokens);\n    }\n\n    // Mint Poolboys\n    function mintToken(uint numberOfTokens) external payable nonReentrant {\n        require(publicSaleActive, \"Public sale is not active\");\n        require(pboyPrice * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n        _mintToken(msg.sender,numberOfTokens);\n        if (collectionStartingIndex == 0) {\n            collectionStartingIndexBlock = block.number;\n        }\n\n    }\n\n    // Set the starting index for the collection\n    function setStartingIndices() external onlyOwner {\n\n        require(collectionStartingIndexBlock != 0, \"Starting index block must be set\");\n        require(collectionStartingIndex == 0, \"Starting index is already set\");\n\n        collectionStartingIndex = uint256(blockhash(collectionStartingIndexBlock)) % MAX_PBOYS;\n\n        if ((block.number - collectionStartingIndexBlock) > 255) {\n            collectionStartingIndex = uint256(blockhash(collectionStartingIndexBlock - 1)) % MAX_PBOYS;\n        }\n\n        if (collectionStartingIndex == 0) {\n            collectionStartingIndex++;\n        }\n    }\n\n    // Set provenance once it's calculated\n    function setProvenanceHash(string memory provenanceHash) external onlyOwner {\n        PBOY_PROVENANCE = provenanceHash;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a ChromiaToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Design a smart contract named \"ChromiaToken\" that implements basic ERC20 token functionalities including ownership, balance tracking, transfers, allowances, and approvals. This contract should include mechanisms for managing the total supply of tokens, querying account balances, transferring tokens between accounts, setting spending allowances, and executing transfers on behalf of other accounts.\n\nContract Structure Overview:\n- Token Attributes: Implement core ERC20 properties such as total supply (_totalSupply), account balances (balances), and allowances (allowed).\n- Ownership: Define an owner variable to identify the contract's owner.\n- Event Declarations: Include Transfer and Approval events to notify external subscribers of token transfers and approval updates.\n\nFunctionality Requirements:\n1. Total Supply Management:\n    - Provide a function to report the total supply of tokens.\n2. Account Balance Query:\n    - Enable querying the token balance of a specific account.\n3. Transfers and Approvals:\n    - Implement a function to transfer tokens from the caller's account to another account.\n    - Allow token holders to approve a spender to transfer up to a specified number of tokens on their behalf.\n    - Facilitate transfers from an approved account to another account, ensuring the spender does not exceed their allowed limit.\n4. Allowance Checking:\n    - Provide a function to check the amount of tokens that an owner has allowed a spender to transfer.\n5. Safety Considerations:\n    - Ensure transfer and transferFrom functions check for overflows.\n    - Validate that transfer and approval amounts are greater than zero.\n    - Confirm that the transferFrom function does not allow transferring more than the allowed balance.\n\nImplementation Details:\n- Balance and Allowance Mappings: Utilize mappings to track the balance of each account and the allowance set by each token holder for approved spenders.\n- Transfer and Approval Logic: Ensure that the transfer logic accounts for sufficient balances and that the approval logic updates the allowed mapping accurately.\n- Event Logging: Emit Transfer and Approval events to log these actions on the blockchain, providing transparency and traceability."}, {"role": "assistant", "content": "contract ChromiaToken {\n    mapping(address => uint256) private balances;\n    mapping(address => mapping (address => uint256)) private allowed;\n    uint256 private _totalSupply = 100000000;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\n        require(balances[msg.sender] >= _amount, \"ERC20: transfer amount exceeds balance\");\n        require(_amount > 0 && balances[_to] + _amount > balances[_to], \"ERC20: Invalid amount\");\n\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\n        require(_from != address(0) && _to != address(0), \"ERC20: transfer from or to the zero address\");\n        require(balances[_from] >= _amount, \"ERC20: transfer amount exceeds balance\");\n        require(allowed[_from][msg.sender] >= _amount, \"ERC20: transfer amount exceeds allowance\");\n        require(_amount > 0 && balances[_to] + _amount > balances[_to], \"ERC20: Invalid amount\");\n\n        balances[_from] -= _amount;\n        balances[_to] += _amount;\n        allowed[_from][msg.sender] -= _amount;\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a POCTOKEN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract for \"POCTOKEN,\" an ERC20-like token with added functionality for burning tokens both by the token holder and on behalf of another account. This contract should include ERC20 standard functions such as transferring tokens, approving spenders, and checking balances and allowances, with an initial supply set at deployment.\n\nContract Structure Overview:\n- Token Attributes: Define core properties including token name, symbol, decimals, and the total supply of tokens.\n- Balance and Allowance Tracking: Implement mappings to track the token balances of each address and allowances granted to spenders.\n- Event Declarations: Include Transfer, Approval, and Burn events for logging these actions on the blockchain.\n\nFunctionality Requirements:\n1. Initial Setup:\n    - Initialize the contract with a specified initial supply, token name, and symbol.\n    - Assign the entire initial supply to the contract creator's balance.\n2. Token Transfers:\n    - Allow token holders to transfer a specified amount of their tokens to another address.\n3. Approval Mechanisms:\n    - Enable token holders to approve another address to spend a specified amount of tokens on their behalf.\n    - Implement a function for the approved spender to transfer an approved amount of tokens from the token holder's account to another account.\n4. Burning Tokens:\n    - Provide functionalities for token holders to burn (destroy) a specified amount of tokens from their own balance and for an approved spender to burn a specified amount of tokens on behalf of the token holder, reducing the total supply.\n5. Query Functions:\n    - Implement functions to query the total supply of tokens, the balance of a specific account, and the allowance a token holder has given to a spender.\n6. Safety Considerations:\n    - Validate all input parameters to prevent common contract vulnerabilities (e.g., checks for zero addresses).\n    - Ensure that token transfers, approvals, and burns only proceed under appropriate conditions (e.g., sufficient balances and allowances).\n\nImplementation Details:\n- Internal Transfer Function: Utilize an internal function to handle the logic common to both direct transfers and transfers on behalf of a spender, ensuring code reuse and simplification.\n- Adjusting Allowances: Carefully manage allowances to prevent the double-spending problem in the approval mechanism.\n- Burning and Total Supply: Accurately decrease the total supply of tokens when burning actions are executed to reflect the removal of tokens from circulation.\n\nExamples and Resources:\n- Reference the ERC20 token standard for function signatures and expected behaviors to ensure compatibility with wallets and exchanges.\n- Consult Solidity documentation for best practices on mapping usage, event logging, and function visibility to secure and optimize the contract.\n"}, {"role": "assistant", "content": "contract POCTOKEN {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 8;\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    // Initializes contract with initial supply tokens to the creator of the contract\n    constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    // Internal transfer, only can be called by this contract\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != address(0x0));\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    // Send `_value` tokens to `_to` from your account\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    // Send `_value` tokens to `_to` on behalf of `_from`\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    // Set allowance for other address\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    // Set allowance for other address and notify\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n\n    // Destroy tokens\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    // Destroy tokens from other account\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        emit Burn(_from, _value);\n        return true;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a SmartGold smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract named \"SmartGold,\" simulating a simple token system. This contract should include basic functionalities such as initializing with an initial supply, assigning token metadata (name, symbol, decimals), and enabling token transfers between accounts. The contract is designed to prevent accidental Ether transfers.\n\nContract Structure Overview:\n- Token Attributes: Define properties like token standard, name, symbol, decimals, initial supply, and total supply.\n- Balance Tracking: Utilize a mapping to keep track of each address's token balance.\n- Transfer Functionality: Implement a function to allow token holders to transfer tokens to another address.\n\nFunctionality Requirements:\n1. Contract Initialization:\n    - Set initial token properties (name, symbol, decimals) and allocate the entire initial supply to the contract creator's address.\n2. Token Transfer:\n    - Enable token holders to transfer a specified amount of tokens to another address, ensuring sufficient balance and checking for overflow conditions.\n3. Prevent Ether Transfers:\n    - Reject any incoming Ether transfers to the contract to avoid accidental Ether loss.\n4. Safety Considerations:\n    - Validate transfer conditions, such as the sender's balance being sufficient and preventing overflows in the recipient's balance.\n    - Use checks to ensure that token transfers and other contract operations proceed under correct conditions.\n\nImplementation Details:\n- Token Supply Management: Accurately reflect changes in token balances and total supply as transfers occur.\n- Error Handling: Properly handle cases where operations cannot proceed, for instance, by reverting transactions when a sender has insufficient balance.\n- Ether Transfer Prevention: Implement a fallback function to reject all incoming Ether transfers, safeguarding against mistaken transactions."}, {"role": "assistant", "content": "contract SmartGold {\n    // Public variables of the token\n    string public standard = 'Token 0.1';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public initialSupply;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n  \n    // Initializes contract with initial supply tokens to the creator of the contract\n    function SmartGold() {\n        initialSupply = 10000;\n        name =\"SmartGold\";\n        decimals = 2;\n        symbol = \"SMTG\";\n        \n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n        totalSupply = initialSupply;                        // Update total supply      \n    }\n\n    // Send coins\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n    }\n\n    // Called whenever someone tries to send ether to it\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a BunnyIceCream smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract named \"BunnyIceCream\" utilizing the ERC721 standard for minting unique NFTs, with integrated charity donation features, dynamic pricing, and store operational status. The contract should enable batch minting of NFTs with part of the proceeds automatically directed to specified charity wallets.\n\nContract Structure Overview:\n- Token Properties and Minting Control: Define token attributes, a counter for token IDs, and control mechanisms for batch minting.\n- Pricing and Charity Contributions: Establish variables for the public sale price and specify charity wallet addresses with corresponding donation percentages.\n- Operational Flags and Metadata Management: Implement flags to manage the store's operational status and functions to set dynamic properties such as URI prefix and pricing.\n\nFunctionality Requirements:\n1. Initialization and Configuration:\n    - Set initial parameters including token name, symbol, charity wallet addresses, charity percentages, URI prefix, initial price, and store status during contract deployment.\n2. Public Minting with Charity Donations:\n    - Allow public users to mint a specified number of NFTs within set limits, automatically transferring a portion of the proceeds to charity wallets based on defined percentages.\n3. Administrative Functions:\n    - Provide owner-exclusive functions to withdraw contract balance, adjust minting price, toggle the store's operational status, update URI prefix, and set charity wallet addresses and percentages.\n4. DAO Minting:\n    - Enable batch minting by the contract owner, bypassing public sale restrictions for promotional or operational needs.\n5. Safety Considerations:\n    - Validate operational and financial conditions before minting, such as the store being open and sufficient ETH sent with the transaction.\n    - Cap the number of NFTs mintable in a single transaction to prevent excessive gas costs and ensure equitable access during sales.\n    - Securely manage contract funds and ensure only the contract owner can modify critical settings or withdraw funds.\n\nImplementation Details:\n- Dynamic Property Management: Allow the owner to dynamically update sale prices, charity information, and operational flags to adapt to changing conditions or objectives.\n- Charity Donation Mechanism: Automatically calculate and distribute specified percentages of minting proceeds to charity wallets during the public minting process.\n- Token Metadata Customization: Utilize a base URI prefix combined with token ID and extension to dynamically generate token metadata URLs."}, {"role": "assistant", "content": "contract BunnyIceCream is Ownable, ERC721 {\n    uint32 public currentTokenId;             // increments with each new message\n    string private _uriPrefix;                  // uri prefix\n    uint256 public publicPrice;                 // price in utility token 1e18 units\n    address public charityWallet1;\n    address public charityWallet2;\n    uint8 public charityPercentage1;\n    uint8 public charityPercentage2;\n    bool public isStoreOpen;\n\n    constructor(uint256 _initialPrice, string memory _initURIPrefix, address _charityWallet1, uint8 _charityPercentage1, address _charityWallet2, uint8 _charityPercentage2, bool _isStoreOpen) ERC721(\"Bunny Ice Cream\", \"BIC\") Ownable() {\n        currentTokenId = 0;\n        charityWallet1 = _charityWallet1;\n        charityWallet2 = _charityWallet2;\n        charityPercentage1 = _charityPercentage1;\n        charityPercentage2 = _charityPercentage2;\n        _uriPrefix = _initURIPrefix;\n        publicPrice = _initialPrice;\n        isStoreOpen = _isStoreOpen;\n    }\n\n    function mintBunnyIceCream(uint8 _number) external payable {\n        require(isStoreOpen == true, \"STORE_CLOSED\");\n        require(_number <= 10, \"TOO_MANY_MINTS\");\n\n        require(publicPrice * _number <= msg.value, \"INSUFFICIENT_ETH\");\n\n        for (uint8 i = 0; i < _number; i++) {\n            _mintBunnyIceCream();\n        }\n        payable(charityWallet1).transfer(charityPercentage1*publicPrice/100*_number);\n        payable(charityWallet2).transfer(charityPercentage2*publicPrice/100*_number);\n    }\n\n    function _mintBunnyIceCream() internal {\n        uint256 nextTokenId = _getNextTokenId();\n        _safeMint(_msgSender(), nextTokenId);\n        _incrementTokenId();\n    }\n\n    function withdraw() external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _uriPrefix;\n    }\n\n    function _getNextTokenId() private view returns (uint256) {\n        return currentTokenId + 1;\n    }\n\n    function _incrementTokenId() private {\n        currentTokenId++;\n    }\n\n    function daoMint(uint8 _number) external onlyOwner {\n        require(_number <= 10, \"TOO_MANY_MINTS\");\n\n        for (uint8 i = 0; i < _number; i++) {\n            _mintBunnyIceCream();\n        }\n    }\n\n    function setPrice(uint256 _newPrice) external onlyOwner {\n        publicPrice = _newPrice;\n    }     \n\n    function setStoreOpen(bool _newStatus) external onlyOwner {\n        isStoreOpen = _newStatus;\n    }     \n\n    function setURIPrefix(string calldata _newURIPrefix) external onlyOwner {\n        _uriPrefix = _newURIPrefix;\n    }\n\n    function setCharity1(address _newCharityAddress, uint8 _percentage) external onlyOwner {\n        charityWallet1 = _newCharityAddress;\n        charityPercentage1 = _percentage;\n    }\n\n    function setCharity2(address _newCharityAddress, uint8 _percentage) external onlyOwner {\n        charityWallet2 = _newCharityAddress;\n        charityPercentage2 = _percentage;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a ZipflaxToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Construct a smart contract named \"ZipflaxToken\" that implements the ERC20 token standard. The contract includes functionalities for token distribution, balance management, token transfers, approval mechanisms, and enhanced approval operations. The initial supply is predefined, and the contract prevents accidental ETH transfers.\n\nContract Structure Overview:\n- Token Attributes: Define properties such as token symbol, name, decimal units, and the total supply of tokens.\n- Balance and Allowance Management: Utilize mappings to track the balance of each address and allowances for delegated token spending.\n- Event Declarations: Include events for transfers, approvals, and changes in approval amounts to notify external observers of significant activities.\n\nFunctionality Requirements:\n1. Initialization:\n    - Upon deployment, initialize the contract with token details (symbol, name, decimals) and allocate the entire initial supply to a specified address.\n2. Token Transfer:\n    - Enable holders to transfer a specified amount of their tokens to another address, ensuring the sender has a sufficient balance.\n3. Spending Approval:\n    - Allow token holders to authorize another address to spend a specific amount of tokens on their behalf.\n    - Implement transfer operations from an approved spender's perspective, checking against the set allowances.\n4. Approval Adjustment:\n    - Facilitate increasing or decreasing the approved amount for a spender without requiring a reset, enhancing user experience and security.\n5. Accidental ETH Transfer Prevention:\n    - Reject any direct ETH transfers to the contract, preventing accidental loss of ETH.\n6. Safety Considerations:\n    - Ensure comprehensive input validation to avoid unauthorized token creation, transfers to the zero address, and other common security pitfalls.\n    - Implement checks to prevent overflow and underflow scenarios in token arithmetic operations.\n    - Secure sensitive contract operations (like approval adjustments) against potential misuse while providing flexibility for token holders.\n\nImplementation Details:\n- ERC20 Compliance: Adhere to the ERC20 standard's specifications for token contracts, ensuring compatibility with the broader Ethereum ecosystem.\n- Enhanced Approval Logic: Incorporate functions to safely adjust allowances, addressing common pitfalls in ERC20 token contracts related to approval double-spending.\n- Operational Security: Use the Ownable contract pattern to restrict certain administrative actions to the contract owner, enhancing control and security."}, {"role": "assistant", "content": "contract ZipflaxToken is ERC20Interface {\n    using SafeMath for uint;\n\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    \n    // Constructor\n    function ZipflaxToken() public {\n        symbol = \"ZIX\";\n        name = \"Zipflax\";\n        decimals = 8;\n        _totalSupply = 280000000;\n        _totalSupply = _totalSupply.mul(10 ** uint(decimals));\n        balances[0xBF2B073fF018F6bF1Caee6cE716B833271C159ee] = _totalSupply;\n        emit Transfer(address(0), 0xBF2B073fF018F6bF1Caee6cE716B833271C159ee, _totalSupply);\n    }\n    \n    // Reject when someone sends ethers to this contract\n    function() public payable {\n        revert();\n    }\n    \n    // Total supply\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    // Transfer the balance from token owner's account to `to` account\n    function transfer(address to, uint tokens) public returns (bool success) {\n        require(to != address(0));\n        require(tokens > 0);\n        require(balances[msg.sender] >= tokens);\n        \n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    function approve(address spender, uint tokens) public returns (bool success) {\n        require(spender != address(0));\n        require(tokens > 0);\n        \n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        require(from != address(0));\n        require(to != address(0));\n        require(tokens > 0);\n        require(balances[from] >= tokens);\n        require(allowed[from][msg.sender] >= tokens);\n        \n        balances[from] = balances[from].sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    // Returns the amount of tokens approved by the owner that can be\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n    // Increase the amount of tokens that an owner allowed to a spender.\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        require(_spender != address(0));\n        \n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n    \n    // Decrease the amount of tokens that an owner allowed to a spender.\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        require(_spender != address(0));\n        \n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a RMBT smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a comprehensive smart contract named \"RMBT\" based on the ERC20 token standard. This contract incorporates advanced functionalities such as supply top-up, admin roles, and owner-exclusive operations. It utilizes SafeMath for arithmetic operations to ensure security against overflow and underflow vulnerabilities.\n\nContract Structure Overview:\n- Token Attributes and Ownership: Establish token characteristics like symbol, name, decimals, and total supply. Define owner and admin roles with distinct permissions.\n- Balance and Allowance Management: Implement mappings to track each address's token balance and another for managing spending allowances between addresses.\n- Event Declarations: Include events for administrative actions, supply adjustments, admin changes, and ETH withdrawals to facilitate tracking and auditing of significant contract activities.\n\nFunctionality Requirements:\n1. Initialization:\n    - On deployment, set initial token attributes and allocate the total supply to the admin address.\n2. Supply Management:\n    - Implement a function allowing the admin to increase the token supply, updating both the total supply and the admin's balance.\n3. Admin and Owner Operations:\n    - Allow the contract owner to change the admin address and withdraw ETH from the contract.\n    - Enable the admin to transfer tokens from any address back to the admin's balance, reflecting emergency or corrective actions.\n4. ERC20 Standard Compliance:\n    - Provide standard ERC20 functionalities including balance querying, token transfers, spending approvals, and transfer on behalf.\n5. Safety Considerations:\n    - Use isOwner and isAdmin modifiers to restrict access to sensitive functions, ensuring that only authorized addresses can execute specific operations.\n    - Validate input parameters and state conditions to prevent unauthorized or unintended actions, such as transfers to the zero address or exceeding balance allowances.\n\nImplementation Details:\n- The constructor initializes the contract by setting the owner, admin, and allocating the entire initial supply to the admin's balance.\n- The topupSupply function, restricted to admin and owner, increases the total supply and admin's balance, emitting relevant events for transparency.\n- withdrawFrom allows the admin or owner to decrease a specified address's balance and increase the admin's balance by the same amount, with event logging for accountability.\n- Implements a changeAdmin function to transfer administrative privileges and the associated token balance to a new address.\n- Includes mechanisms to handle incoming Ether transactions and to allow the owner to withdraw Ether from the contract.\n\nSecurity Considerations:\n- Adopts isOwner and isAdmin modifiers to enforce function access controls, preventing unauthorized use of sensitive functionalities.\n- The use of SafeMath for all arithmetic operations mitigates potential vulnerabilities related to integer overflow and underflow.\n- Requires thorough validation of address inputs to prevent erroneous or malicious interactions, particularly in administrative functions."}, {"role": "assistant", "content": "contract RMBT is ERC20Interface {\n    using SafeMath for uint;\n\n    string public symbol = \"RMBT\";\n    string public name = \"RMBT\";\n    uint8  public decimals = 18;\n    uint _totalSupply = 1000000000000e18;\n\n    address payable owner;\n    address admin;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    modifier isOwner() {\n        require(msg.sender == owner, \"must be contract owner\");\n        _;\n    }\n\n    modifier isAdmin() {\n        require(msg.sender == admin || msg.sender == owner, \"must be admin\");\n        _;\n    }\n\n    event Topup(address indexed _admin, uint tokens, uint _supply);\n    event ChangeAdmin(address indexed from, address indexed to);\n    event AdminTransfer(address indexed from, uint tokens);\n\n    constructor(address _admin) public {\n        owner = msg.sender;\n        admin = _admin;\n        balances[admin] = _totalSupply;\n        emit Transfer(address(0x0), admin, _totalSupply);\n    }\n\n    function topupSupply(uint tokens) external isAdmin returns (uint newSupply) {\n        _totalSupply = _totalSupply.add(tokens);\n        balances[admin] = balances[admin].add(tokens);\n        newSupply = _totalSupply;\n\n        emit Transfer(address(0x0), admin, tokens);\n        emit Topup(msg.sender, tokens, _totalSupply);\n    }\n\n    function withdrawFrom(address _address, uint tokens) external isAdmin returns(uint, uint) {\n        balances[_address] = balances[_address].sub(tokens);\n        balances[admin] = balances[admin].add(tokens);\n        emit Transfer(_address, admin, tokens);\n        emit AdminTransfer(_address, tokens);\n\n        return (balances[_address], balances[msg.sender]);\n    }\n\n    function changeAdmin(address _address) external isOwner {\n        uint _tokens = balances[admin];\n        balances[admin] = balances[admin].sub(_tokens);\n        balances[_address] = balances[_address].add(_tokens);\n\n        emit Transfer(admin, _address, _tokens);\n        emit ChangeAdmin(admin, _address);\n\n        admin = _address;\n    }\n\n    function withdrawEther(uint _amount) external isOwner {\n        owner.transfer(_amount);\n    }\n\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    // Transfer the balance from token owner's account to `to` account\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[to]         = balances[to].add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from]            = balances[from].sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        balances[to]              = balances[to].add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    // Returns the amount of tokens approved by the owner that can be transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n    // accept ETH\n    function () external payable {\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a PixelHat smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The PixelHat contract is an ERC721 token that integrates with an ERC20 token (PIXL) for minting operations, allowing users to mint \"PixelHat\" NFTs in exchange for PIXL tokens. It sets a finite total supply of NFTs that can be minted and requires users to have enough PIXL tokens for the minting price, which is specified in the contract. Administrative functions included allow the contract owner to update the base URI for the NFT metadata, withdraw PIXL or any ERC20 tokens sent to the contract by mistake, and adjust the total supply and mint price, ensuring flexibility and control over the contract's operations and assets.\n\nContract Structure Overview:\n- Token and Supply Management: Utilize a counter for tracking NFT IDs and set parameters for total supply and minting price in PIXL tokens.\n- PIXL Token Integration: Define an interface for interacting with the PIXL ERC20 token, allowing users to mint NFTs by spending PIXL tokens.\n- Base URI for Metadata: Implement a base URI that points to the NFT metadata stored on IPFS, providing a method to update it.\n- Withdrawal and Supply Adjustment Functions: Offer administrative functions to withdraw PIXL and other ERC20 tokens, as well as to update the NFT total supply and mint price.\n\nFunctionality Requirements:\n1. ERC20 Token-based Minting: Allows users to mint NFTs by paying with PIXL tokens, requiring users to approve the PixelHat contract to transfer PIXL on their behalf.\n2. Supply Tracking: Dynamically tracks the number of tokens minted and available for sale, enforcing a cap on the total supply to maintain exclusivity.\n3. Base URI Management: Supports updating the base URI for token metadata, facilitating flexibility in managing and updating the assets' storage locations.\n4. Withdrawal Operations: Provides mechanisms for the contract owner to withdraw collected PIXL tokens and other ERC20 tokens from the contract, ensuring control over the contract's finances.\n5. Supply and Price Adjustment: Allows the owner to adjust the total supply and the minting price in PIXL, adapting to changing demands or economic conditions.\n\nImplementation Details:\n- The constructor initializes key contract parameters including the PIXL token address, total supply, mint price, and base URI.\n- The mint function handles the ERC20 token transfer from the minter to the contract as payment, mints a new NFT to the minter, and updates the token ID counter.\n- Incorporates view functions amountMinted and amountUnsold to provide insights into the contract's minting progress and remaining supply.\n- Overrides the _baseURI function to return the set base URI, ensuring consistent resolution of metadata URLs.\n- Implements withdrawPixl, withdrawAllPixl, and withdrawErc20 functions for the owner to manage collected assets and maintain operational flexibility.\n\nSecurity Considerations:\n- Employs the onlyOwner modifier to restrict sensitive actions, like withdrawing funds and adjusting contract parameters, to the contract owner.\n- Utilizes SafeMath (implicitly through Solidity 0.8.x or as a library in earlier versions) to prevent arithmetic overflow and underflow.\n- Ensures that the minting function checks for sufficient PIXL balance and approval, mitigating the risk of unauthorized or failed transactions.\n- Validates that minting does not exceed the total supply limit, preserving the collection's exclusivity and value."}, {"role": "assistant", "content": "contract PixelHat is ERC721, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n    \n    IERC20 pixlToken;\n\n    uint256 public mintPriceInPixl;\n    uint256 public totalSupply;\n    string public baseURI;\n\n    constructor(IERC20 pixlTokenAddress) ERC721(\"PixelHat\", \"PHAT\") Ownable() {\n        pixlToken = pixlTokenAddress;\n        totalSupply = 10;\n        mintPriceInPixl = 25000 * 1e18;\n        baseURI = \"https://ipfs.io/ipfs/QmXUUXRSAJeb4u8p4yKHmXN1iAKtAV7jwLHjw35TNm5jN7/\";\n    }\n\n    // Client UI will have the user approve the ERC20 contract in order to let PixelHat transfer PIXL tokens for minting.\n    function mint() public returns (uint) {\n        uint256 pixlBalance = pixlToken.balanceOf(msg.sender);\n        require(pixlBalance >= mintPriceInPixl, \"Insufficient funds: not enough PIXL\");\n        require(_tokenIds.current() < totalSupply, \"Supply Exceeded: sold out\");\n        pixlToken.transferFrom(msg.sender, address(this), mintPriceInPixl);\n\n        _tokenIds.increment();\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(msg.sender, newItemId);\n\n        return newItemId;\n    }\n\n    function amountMinted() public view returns (uint) {\n        return _tokenIds.current();\n    }\n\n    function amountUnsold() public view returns (uint) {\n        return totalSupply - _tokenIds.current();\n    }\n\n    function _baseURI() internal view virtual override returns (string memory){\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newURI) public onlyOwner {\n        baseURI = _newURI;\n    }\n\n    function withdrawPixl(uint256 _amount) public onlyOwner {\n        uint256 pixlBalance = pixlToken.balanceOf(address(this));\n        require(pixlBalance >= _amount, \"Insufficient funds: not enough PIXL\");\n        pixlToken.transfer(msg.sender, _amount);\n    }\n\n    function withdrawAllPixl() public onlyOwner {\n        uint256 pixlBalance = pixlToken.balanceOf(address(this));\n        require(pixlBalance > 0, \"No PIXL within this contract\");\n        pixlToken.transfer(msg.sender, pixlBalance);\n    }\n\n    function withdrawErc20(address erc20Contract, uint256 _amount) public onlyOwner {\n        uint256 erc20Balance = pixlToken.balanceOf(address(this));\n        require(erc20Balance >= _amount, \"Insufficient funds: not enough ERC20\");\n        IERC20(erc20Contract).transfer(msg.sender, _amount);\n    }\n\n    // Only use if adding more PixelHats to Pixelverse, followed by an extra push to IPFS\n    function updateTotalSupply(uint256 _supply) public onlyOwner {\n        totalSupply = _supply;\n    }\n\n    function updateMintPrice(uint256 _priceInPixl) public onlyOwner {\n        mintPriceInPixl = _priceInPixl;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a CrowdsaleToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a detailed smart contract named \"CrowdsaleToken\" that extends the functionality of a standard token with crowdsale capabilities. This contract allows for tokens to be sold during a crowdsale event, managed by a specific crowdsale address. It includes mechanisms for token allocation, release, and rejection, incorporating SafeMath for arithmetic operations to ensure security.\n\nContract Structure Overview:\n- Inherits StandardToken for basic ERC20 functionality and Ownable for ownership control.\n- Introduces a variable to track the crowdsale contract address, allowing sales to be conducted through a designated crowdsale mechanism.\n- Implements a mapping to hold tokens purchased in the crowdsale but not yet released to the purchaser, facilitating a vetting process before final allocation.\n- Tracks the total number of tokens sold in the crowdsale to ensure the owner's balance is not oversubscribed.\n\nKey Functionalities:\n1. Crowdsale Management: Enables the contract owner to set and update the address of the crowdsale contract that is allowed to sell tokens.\n2. Token Sale Process: Supports the sale of tokens by the crowdsale contract, temporarily storing purchased tokens in a waiting state until they are either released to the purchaser or rejected.\n3. Token Release and Rejection: Allows the owner to release waiting tokens to purchasers or reject the sale, returning the tokens to the owner's balance.\n4. Safe Sale Execution: Ensures that token sales do not exceed the owner's available balance, and that tokens are only sold to valid addresses (not the zero address).\n\nImplementation Details:\n- The setCrowdsale function updates the crowdsale contract address, restricted to the contract owner, to designate or change the crowdsale mechanism.\n- Utilizes a onlyCrowdsale modifier to restrict certain actions, like initiating a sale, exclusively to the crowdsale contract.\n- The sale function, callable only by the crowdsale contract, registers a pending sale, incrementing the total sold tokens and the waiting balance for a purchaser.\n- Implements release and reject functions for the owner to manage pending token allocations post-sale, adjusting balances as necessary and managing the total tokens sold.\n\nSecurity Considerations:\n- Employs SafeMath to prevent arithmetic overflow and underflow, ensuring that token operations are executed safely.\n- Protects critical functions with onlyOwner and onlyCrowdsale modifiers, preventing unauthorized access and ensuring that operations such as token releases and sales are properly authenticated.\n- Asserts conditions to safeguard against improper token allocations, ensuring that sales do not exceed the owner's balance and that operations are not conducted with the zero address."}, {"role": "assistant", "content": "contract CrowdsaleToken is StandardToken, Ownable {\n    using SafeMath for uint256;\n    address public crowdsale;\n    mapping (address => uint256) public waiting;\n    uint256 public saled;\n\n    event Sale(address indexed to, uint256 value);\n    event Release(address indexed to);\n    event Reject(address indexed to);\n    event SetCrowdsale(address indexed addr);\n\n    function setCrowdsale(address _addr) onlyOwner public {\n        crowdsale = _addr;\n        SetCrowdsale(_addr);\n    }\n\n    modifier onlyCrowdsale() {\n        require(crowdsale != address(0));\n        require(crowdsale == msg.sender);\n        _;\n    }\n\n    function sale(address _to, uint256 _value) public onlyCrowdsale returns (bool) {\n        require(_to != address(0));\n        assert(saled.add(_value) <= balances[owner]);\n\n        saled = saled.add(_value);\n        waiting[_to] = waiting[_to].add(_value);\n        Sale(_to, _value);\n        return true;\n    }\n\n    // send waiting tokens to customer's balance\n    function release(address _to) external onlyOwner {\n        require(_to != address(0));\n\n        uint256 val = waiting[_to];\n        waiting[_to] = 0;\n        balances[owner] = balances[owner].sub(val);\n        balances[_to] = balances[_to].add(val);\n        Release(_to);\n    }\n\n    // reject waiting token\n    function reject(address _to) external onlyOwner {\n        require(_to != address(0));\n\n        saled = saled.sub(waiting[_to]);\n        waiting[_to] = 0;\n\n        Reject(_to);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a BadBabies smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Generate an Ethereum smart contract named \"BadBabies\" utilizing the ERC721Enumerable and Ownable extensions. This contract is designed to manage a collection of unique digital assets represented as NFTs, featuring functionalities for minting, whitelist minting, transferring, and burning tokens. Additionally, the contract includes features for price setting, supply management, and base URI adjustments for metadata storage.\n\nContract Structure Overview:\n- Inherits ERC721Enumerable for token enumeration and Ownable for ownership privileges.\n- Utilizes SafeMath and EnumerableSet for safe arithmetic operations and efficient storage of owned token IDs, respectively.\n- Defines variables for mint prices, sale dates, total supply, base URI, and an authorizer address for whitelist verification.\n- Implements a dual-phase minting process with distinct conditions and pricing for whitelist and public sales.\n\nKey Functionalities:\n1. Whitelist Minting: Enables minting at a special price for users verified through a signature, ensuring exclusive access prior to the public sale.\n2. Public Sale Minting: Opens minting to the general public post-whitelist phase, with a different pricing structure.\n3. Dynamic Supply and Pricing: Allows the contract owner to adjust the total supply and minting price, adapting to demand or strategic needs.\n4. Owner Token Mapping: Tracks which tokens are owned by which addresses, facilitating easy retrieval and management of owned tokens.\n5. Base URI Management: Supports updating the base URI for token metadata, useful for revealing hidden or encrypted metadata post-mint.\n\nImplementation Details:\n- The mintOnWhitelist function checks for valid signature verification against the authorizer address, ensuring that only pre-approved users can mint during the whitelist phase.\n- Utilizes ECDSA.recover for signature verification, tying mint eligibility to off-chain authorization.\n- The mint function opens up token creation to the public post-whitelist phase, with a standard minting price.\n- Overrides the _beforeTokenTransfer function from ERC721 to update the custom owner mappings upon token transfers.\n- Incorporates a gift function for the owner to mint tokens directly to specified addresses, bypassing the minting price.\n\nSecurity Considerations:\n- Employs onlyOwner modifier for functions that alter critical contract parameters or withdraw funds, ensuring that only the contract owner can execute these operations.\n- Validates addresses and enforces minting limits within the mint and mintOnWhitelist functions to prevent over-minting or minting to the zero address.\n- Implements checks within the decreaseSupply function to ensure the total supply cannot be reduced below the number of already minted tokens, preserving integrity."}, {"role": "assistant", "content": "contract BadBabies is ERC721Enumerable, Ownable{\n    using Counters for Counters.Counter;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using Strings for uint256;\n\n    uint256 private _price = 0.04 ether;\n    uint256 private _supply = 10000;\n    uint256 private _whitelistPrice = 0.03 ether;\n    uint256 private _whitelistDate;\n    uint256 private _publicSaleDate;\n    string private _uri;\n    address private _authorizer = 0x7ACa8b1e3D01F52DF81bDD154319DB3D445cbD35;\n    mapping (address => EnumerableSet.UintSet) private _ownerBabies;\n    Counters.Counter private _babiesId;\n    \n    // Modifier check if address can buy, if public sale is open allows everyone if not checks whitelist   \n    constructor (string memory uri_) ERC721(\"Bad Babies\", \"BAD\")  {\n        _uri = uri_;\n        _whitelistDate = 1639771200;\n        _publicSaleDate = 1639771200 + 24 hours;\n        _babiesId.increment();\n    }\n    \n    function mintOnWhitelist(bytes memory signature) external payable {\n        require(recov(keccak256(abi.encodePacked(msg.sender)), signature) == _authorizer, \"Bad Babies: Invalid whitelist singature\");\n        require(msg.value >= _whitelistPrice, \"Bad Babies: msg.value less than price\");\n        require(_whitelistDate <= block.timestamp, \"Bad Babies: Mintin not allowed\");\n        require(_publicSaleDate > block.timestamp, \"Bad Babies: Only public sale\");\n        mint_(msg.sender);\n    }\n\n    function recov(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        return ECDSA.recover(hash, signature);\n    }\n\n    function mint() external payable {\n        require(_publicSaleDate <= block.timestamp, \"Bad Babies: Only whitelist\");\n        require(msg.value >= _price, \"Bad Babies: msg.value less than price\");\n        mint_(msg.sender);\n    }\n\n    function transfer(address to, uint256 tokenId) external {\n        _transfer(msg.sender, to, tokenId);\n    }\n\n    // Mint new token and maps to receiver    \n    function mint_(address to) private {\n        require(_babiesId.current() <= _supply, \"Bad Babies: All NFTs minted\");\n        _ownerBabies[to].add(_babiesId.current());\n        _mint(to, _babiesId.current());\n        _babiesId.increment();\n    }\n    \n    function getTokenByOwnerIndex(address owner, uint256 index) public view returns(uint256) {\n        return _ownerBabies[owner].at(index);\n    }\n\n    // Overrides ERC721 function to change owner on _ownerBabies map   \n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) override internal virtual {\n        _ownerBabies[from].remove(tokenId);\n        _ownerBabies[to].add(tokenId);\n    }\n \n    function _baseURI() override internal view virtual returns (string memory) {\n        return _uri;\n    }\n\n    // get token URI by token ID, adds .json extension     \n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), \".json\")) : \"\";\n    }\n\n    // Mint a new token and gift it\n    function gift(address to) external onlyOwner {\n        mint_(to);\n    }\n\n    // Burn a token\n    function burn(uint256 tokenId) external onlyOwner {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n\n    // Change Base URI can be used to reveal NFTs\n    function changeBaseURI(string memory uri_) external onlyOwner {\n        _uri = uri_;\n    }\n\n    // Withdraw ETH balance to the owner\n    function withdraw() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    // Decreases NFT supply.\n    function decreaseSupply(uint256 amount) external onlyOwner {\n        require((_supply-=amount) >= _babiesId.current());\n        _supply-=amount;\n    }\n\n    // Change token price\n    function changePrice(uint256 price_) external onlyOwner {\n        _price = price_;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a WIN12 smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a Ethereum smart contract named \"WIN12 GAME - GIGO Fair Token\" utilizing the ERC20Detailed standard. This contract aims to introduce unique mechanisms such as token burn percentages tied to transfers, special rules for specific wallets, and multi-address transfers.\n\nContract Structure Overview:\n- Inherits ERC20Detailed for token details (name, symbol, decimals).\n- Sets an initial total supply of 12 trillion tokens with 12 decimal places for precision.\n- Establishes specific wallets (Uniswap and liquidity wallets) with unique transaction rules.\n- Implements a burning percentage for transactions not involving the designated wallets, reducing the supply with each transaction.\n\nKey Functionalities:\n1. Special Wallet Transactions: Transactions involving the Uniswap or liquidity wallets bypass the burning mechanism, allowing for standard transfers.\n2. Burning Mechanism: Applies a token burn on transfers not involving the designated special wallets, effectively reducing the total supply with each applicable transaction.\n3. Multi-Transfer Capability: Enables a sender to distribute tokens to multiple addresses in a single transaction, streamlining the token distribution process.\n4. Token Minting and Burning: Allows for the creation of new tokens to the initial sender's address and the burning of tokens to reduce the total supply.\n5. Allowance Management: Supports increasing or decreasing the approved amount a spender can transfer, providing flexibility in delegated token spending.\n\nImplementation Details:\n- Utilizes the burnPercent variable to determine the percentage of tokens to burn for each applicable transaction, automatically adjusting the total supply.\n- The transfer and transferFrom functions incorporate conditional logic to apply the burning mechanism based on the transaction participants.\n- The multiTransfer function iterates over arrays of receiver addresses and amounts, calling the transfer function for each pair.\n- Minting is performed initially in the constructor to the deployer's address, with the _mint internal function facilitating this process.\n- Burning can be initiated by the token holder or an approved spender, with the _burn internal function ensuring the safe reduction of supply.\n\nSecurity Considerations:\n- Adopts SafeMath for all arithmetic operations to prevent overflow and underflow vulnerabilities.\n- Incorporates checks to ensure non-zero transaction values and valid recipient addresses, preventing token loss and ensuring the integrity of transactions.\n- Enforces burning rules uniformly across transactions, with exceptions for designated wallets, maintaining the token's deflationary policy while accommodating essential liquidity operations."}, {"role": "assistant", "content": "contract WIN12 is ERC20Detailed {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    address uniswapWallet = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address liquidityWallet = 0xFC8B42aC9133EF1E9e6645b9b023f15A060f167B;\n\n    string constant tokenName = \"WIN12 GAME - GIGO Fair Token\";\n    string constant tokenSymbol = \"WIN12\";\n    uint8  constant tokenDecimals = 12;\n    uint256 _totalSupply = 12000000000000;\n    uint256 public burnPercent = 1200;\n  \n    constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function getburningPercent(uint256 value) public view returns (uint256)  {\n        uint256 roundValue = value.ceil(burnPercent);\n        uint256 burningPercent = roundValue.mul(burnPercent).div(10000);\n        return burningPercent;\n    }\n \n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[msg.sender]);\n        require(to != address(0));\n        if (msg.sender == uniswapWallet || msg.sender == liquidityWallet || to == liquidityWallet || to == uniswapWallet) {\n            uint256 tokenTransfer = value;\n            \n            _balances[msg.sender] = _balances[msg.sender].sub(value);\n            _balances[to] = _balances[to].add(tokenTransfer);\n            \n            emit Transfer(msg.sender, to, tokenTransfer);\n            return true;\n        } else {\n            if (value > 1200000000000) {\n                revert();\n            }\n\n            uint256 tokensToBurn = getburningPercent(value);\n            uint256 tokensForTransfer = value.sub(tokensToBurn);\n\n            _balances[msg.sender] = _balances[msg.sender].sub(value);\n            _balances[to] = _balances[to].add(tokensForTransfer);\n\n            _totalSupply = _totalSupply.sub(tokensToBurn);\n\n            emit Transfer(msg.sender, to, tokensForTransfer);\n            emit Transfer(msg.sender, address(0), tokensToBurn);\n            return true;\n        }\n    }\n\n    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n        for (uint256 i = 0; i < receivers.length; i++) {\n            transfer(receivers[i], amounts[i]);\n        }\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n     \n        if  (msg.sender == liquidityWallet || from == liquidityWallet) {\n            _balances[from] = _balances[from].sub(value);\n                uint256 tokenTransfer = value;\n            _balances[to] = _balances[to].add(tokenTransfer);\n\n            _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n            emit Transfer(from, to, tokenTransfer);\n\n            return true;\n        } else {\n            _balances[from] = _balances[from].sub(value);\n            uint256 tokensToBurn = getburningPercent(value);\n                uint256 tokensForTransfer = value.sub(tokensToBurn);\n\n            _balances[to] = _balances[to].add(tokensForTransfer);\n\n            _totalSupply = _totalSupply.sub(tokensToBurn);\n\n            _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n            emit Transfer(from, to, tokensForTransfer);\n            emit Transfer(from, address(0), tokensToBurn);\n\n            return true;\n        }\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(amount != 0);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= _balances[account]);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[account] = _balances[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external {\n        require(amount <= _allowed[account][msg.sender]);\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);\n        _burn(account, amount);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a HighwayBumsCollectiveGenesis smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The HighwayBumsCollectiveGenesis contract is an ERC721A-based NFT collection with mechanisms for minting, revealing, and managing ownership. It features customizable settings for mint cost, supply caps, and per-wallet limits, alongside toggles for pausing and starting public sales. Additional functionalities include setting base URIs for revealed and unrevealed states, adjusting minting parameters, and withdrawing contract balances, making it highly adaptable for different phases of an NFT project lifecycle.\n\nContract Structure Overview:\n- Inherits ERC721A for optimized batch minting and Ownable for administrative control.\n- Implements variables for base URI, not-revealed URI, minting cost, maximum supply, per-wallet maximum, and transaction size limit.\n- Introduces booleans to manage the state of the contract, including pause, reveal, and public sale status.\n\nKey Functionalities:\n1. Public Minting: Allows users to mint tokens during an active public sale, with checks on the number of tokens per transaction, per-wallet limits, and the total supply.\n2. Gifting Tokens: Enables the contract owner to mint tokens directly to specified addresses, bypassing the cost requirement.\n3. Reveal Mechanism: Supports toggling between revealed and not-revealed states for token metadata, facilitating surprise elements in token distribution.\n4. Metadata Management: Provides functionalities to update the base URI for revealed tokens, set a unique extension for metadata files, and manage the URI for not-revealed tokens.\n5. Sale and Minting Configuration: Allows the owner to adjust critical parameters such as minting cost, maximum supply, transaction size limit, and per-wallet purchase limit.\n6. Ownership Enumeration: Offers a function to list all token IDs owned by a specific address, enhancing user engagement and interaction with the collection.\n\nImplementation Details:\n- Utilizes the ERC721A constructor to initialize the token name, symbol, and maximum batch size for minting operations.\n- The mint function enforces various checks to ensure compliance with the contract's rules regarding sale status, minting cost, and supply limits before minting tokens to the caller.\n- The tokenURI function returns the appropriate metadata URI based on the token's revealed status, with a fallback to a not-revealed URI if applicable.\n- Implements onlyOwner-protected functions for contract management, including toggling the public sale, setting sale parameters, and withdrawing contract balance.\n\nSecurity Considerations:\n- Adopts the onlyOwner modifier for administrative actions to restrict sensitive operations to the contract owner, mitigating unauthorized access risks.\n- Ensures that the contract can be paused/unpaused by the owner to address potential issues or suspend minting during unforeseen circumstances.\n- Incorporates input validation and state checks across public functions to prevent unauthorized actions and ensure contract integrity."}, {"role": "assistant", "content": "contract HighwayBumsCollectiveGenesis is ERC721A, Ownable {\n  using Strings for uint256;\n\n  string public baseURI;\n  string public baseExtension = \".json\";\n  string public notRevealedUri;\n  uint256 public cost = 0.06 ether;\n  uint256 public maxSupply = 10000;\n  uint256 public MaxperWallet = 20;\n  uint256 public maxsize = 10 ; // max mint per tx\n  bool public paused = false;\n  bool public revealed = false;\n  bool public publicSale = false;\n\n  constructor(string memory _initBaseURI, string memory _initNotRevealedUri) ERC721A(\"Highway Bums Collective Genesis\", \"HWBC\", maxsize) {\n    setBaseURI(_initBaseURI);\n    setNotRevealedURI(_initNotRevealedUri);\n  }\n\n  // internal\n  function _baseURI() internal view virtual override returns (string memory) {\n    return baseURI;\n  }\n\n  // public\n  function mint(uint256 tokens) public payable {\n    require(!paused, \"HWBC: oops contract is paused\");\n    require(publicSale, \"HWBC: Sale Hasn't started yet\");\n    uint256 supply = totalSupply();\n    uint256 ownerTokenCount = balanceOf(_msgSender());\n    require(tokens > 0, \"HWBC: need to mint at least 1 NFT\");\n    require(tokens <= maxsize, \"HWBC: max mint amount per tx exceeded\");\n    require(supply + tokens <= maxSupply, \"HWBC: We Soldout\");\n    require(ownerTokenCount + tokens <= MaxperWallet, \"HWBC: Max NFT Per Wallet exceeded\");\n    require(msg.value >= cost * tokens, \"HWBC: insufficient funds\");\n\n    _safeMint(_msgSender(), tokens);\n  }\n  \n  function gift(uint256 _mintAmount, address destination) public onlyOwner {\n    require(_mintAmount > 0, \"need to mint at least 1 NFT\");\n    uint256 supply = totalSupply();\n    require(supply + _mintAmount <= maxSupply, \"max NFT limit exceeded\");\n\n    _safeMint(destination, _mintAmount);\n  }\n\n  function walletOfOwner(address _owner) public view returns (uint256[] memory) {\n    uint256 ownerTokenCount = balanceOf(_owner);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    \n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\n    }\n    \n    return tokenIds;\n  }\n\n  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    require(_exists(tokenId), \"ERC721AMetadata: URI query for nonexistent token\");\n    \n    if (revealed == false) {\n      return notRevealedUri;\n    }\n\n    string memory currentBaseURI = _baseURI();\n    return bytes(currentBaseURI).length > 0\n      ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\n      : \"\";\n  }\n\n  //only owner\n  function reveal(bool _state) public onlyOwner {\n    revealed = _state;\n  }\n\n  function setMaxPerWallet(uint256 _limit) public onlyOwner {\n    MaxperWallet = _limit;\n  }\n\n  function setmaxsize(uint256 _maxsize) public onlyOwner {\n    maxsize = _maxsize;\n  }\n\n  function setCost(uint256 _newCost) public onlyOwner {\n    cost = _newCost;\n  }\n\n  function setMaxsupply(uint256 _newsupply) public onlyOwner {\n    maxSupply = _newsupply;\n  }\n\n  function setBaseURI(string memory _newBaseURI) public onlyOwner {\n    baseURI = _newBaseURI;\n  }\n\n  function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\n    baseExtension = _newBaseExtension;\n  }\n  \n  function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {\n    notRevealedUri = _notRevealedURI;\n  }\n\n  function pause(bool _state) public onlyOwner {\n    paused = _state;\n  }\n\n  function togglepublicSale(bool _state) external onlyOwner {\n    publicSale = _state;\n  }\n  \n  function withdraw() public payable onlyOwner {\n    (bool success, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n    require(success);\n  }\n}\n"}]}