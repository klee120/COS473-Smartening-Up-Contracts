[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a XYZZ smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: You are tasked with generating an Ethereum smart contract for a token named XYZZ. This token is an ERC20 compliant digital asset with added functionalities to support initial coin offering (ICO) stages, including bonus periods, a soft cap, and account freezing capabilities for security.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nContract Structure Overview:\n- Token Information: Your contract should declare basic token attributes such as symbol, name, description, and decimals.\n- ICO Stages: Include variables to manage ICO stages, like `_startDate`, `_bonusEnds`, `_endDate`, `_internalCap`, and `_softCap`.\n- State Variables: Define mappings for storing balances (`_balances`), allowances (`_allowed`), and account freeze states (`_freezeState`).\n\nFunctionality Requirements:\n1. Constructor: Initialize the contract with token information, ICO parameters, and allocate initial tokens to the minter's account.\n2. ICO Constraints: Implement a modifier IcoSuccessful to check conditions for certain functions (e.g., token transfers post-ICO completion and achieving the soft cap).\n3. Balance and Transfers: Include functions for querying balances (balanceOf), transferring tokens (transfer, transferFrom), and managing allowances (approve, allowance).\n4. Freezing Accounts: Provide functionality to freeze and unfreeze accounts to prevent transfers during the ICO or due to security reasons.\n5. Token Minting and Burning: Allow the contract owner to mint new tokens or burn existing tokens from their balance or specified accounts.\n6. Bonus Mechanism: During the ICO, implement a method for purchasing tokens that awards bonus tokens if purchased during the bonus period.\n7. ERC20 Compliance: Ensure the contract adheres to the ERC20 standard for token contracts.\n\nSafety Considerations:\n- Use SafeMath for all arithmetic operations to protect against overflow and underflow.\n- Ensure only the contract owner can mint, burn, freeze, or unfreeze tokens.\n- Validate all user inputs and enforce checks on token transfers, especially when modifying allowances or executing transfers from and to accounts.\n\nImplementation Details:\n- Token Initialization: Start with defining the contract's metadata and ICO parameters within the constructor.\n- Function Implementations: Carefully implement each function, adhering to the ERC20 standard and custom business logic as outlined. Pay attention to security checks, such as verifying ICO success or account freeze status before proceeding with certain operations.\n- Event Logging: Emit appropriate events for token transfers, approval changes, and other significant actions for transparency and traceability.\n\nExamples and Resources:\n- Refer to OpenZeppelin contracts for secure implementation examples, especially for ERC20 functionality and SafeMath operations.\n- Consult the Ethereum EIP-20 token standard documentation for compliance requirements and function specifications.\n"}, {"role": "assistant", "content": "\ncontract XYZZ is ERC20Interface, Owned, SafeMath {\n    string public symbol;\n    string public name;\n    string public description;\n    uint8 public decimals;    \n    uint private _startDate;\n    uint private _bonusEnds;\n    uint private _endDate;\n    \n    uint256 private _internalCap;\n    uint256 private _softCap;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) _balances;\n    mapping(address => mapping(address => uint256)) _allowed;\n    mapping(address => bool) _freezeState;\n\n\n    // Constructor\n    constructor(\n        address payable minter) public {\n        \n        name   = \"VGNA Token\";\n        description = \"Virtual Geospatial Networking Asset\";\n        symbol = \"VGNA\";\n        decimals = 18;\n        _internalCap = 25000000;\n        _softCap     = 50000000;\n        \n        _bonusEnds = now + 3 days;\n        _endDate = now + 1 weeks;\n            \n        _owner = minter;\n        _balances[_owner] = _internalCap;  \n        _totalSupply = _internalCap;\n        emit Transfer(address(0), _owner, _internalCap);\n    }\n\n    modifier IcoSuccessful {\n        require(now >= _endDate);\n        require(_totalSupply >= _softCap);\n        _;\n    }\n\n\n    // Total supply\n    function totalSupply() public view returns (uint) {\n        return _totalSupply - _balances[address(0)];\n    }\n\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return _balances[tokenOwner];\n    }\n    \n    function isFreezed(address tokenOwner) public view returns (bool freezed) {\n        return _freezeState[tokenOwner];\n    }\n\n\n    // Transfer the balance from token owner's account to `to` account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    function transfer(address to, uint256 tokens) public IcoSuccessful returns (bool success) {\n        require(_freezeState[msg.sender] == false);\n        \n        _balances[msg.sender] = safeSub(_balances[msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    \n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account\n    function approve(address spender, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    //\n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the `from` account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    function transferFrom(address from, address to, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[from] == false && _freezeState[to] == false);\n        \n        _balances[from] = safeSub(_balances[from], tokens);\n        _allowed[from][msg.sender] = safeSub(_allowed[from][msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        require(_freezeState[spender] == false);\n        return _allowed[tokenOwner][spender];\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account. The `spender` contract function\n    // `receiveApproval(...)` is then executed\n    function approveAndCall(address spender, uint tokens, bytes memory data) public IcoSuccessful returns (bool success) {\n        require(_freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, _owner, data);\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // 1 VGNA Tokens per 1 Wei\n    function buy() public payable {\n    \n        require(msg.value >= 1 finney);\n        require(now >= _startDate && now <= _endDate);\n\n        uint256 weiValue = msg.value;\n        uint256 tokens = 0;\n        \n        if (now <= _bonusEnds) {\n            tokens = safeMul(weiValue, 2);\n        } else {\n            tokens = safeMul(weiValue, 1);\n        }\n        \n        _freezeState[msg.sender] = true;\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        _owner.transfer(msg.value);\n    }\n    \n    function () payable external {\n        buy();\n    }\n\n    function burn(uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[msg.sender] >= tokens);   // Check if the sender has enough\n        address burner = msg.sender;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function burnFrom(address account, uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[account] >= tokens);   // Check if the sender has enough\n        address burner = account;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function freeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = true;\n        return true;\n    }\n    \n    function unfreeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = false;\n        return true;\n    }\n    \n    function mint(uint256 tokens) public onlyOwner returns (bool success)\n    {\n        require(now >= _startDate && now <= _endDate);\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        return true;\n    }\n\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(_owner, tokens);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a AquaTools smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: This smart contract, named AquaTools, is an ERC1155 token with integrated ownership and supply tracking features, designed for both presale and public sale phases of unique digital assets with a capped quantity. It initializes with a predefined price, maximum supply, and a reserved quantity for the contract's owner, allowing adjustments to sale statuses, price, and token metadata via owner-exclusive functions. Additionally, it supports secure presale participation through a Merkle proof verification mechanism for whitelisted addresses, and governs the minting process with constraints on the number of tokens mintable per transaction, ensuring adherence to the overall supply limit.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nContract Structure Overview:\n- Token Attributes: Include ERC1155 token metadata and define attributes such as price, maxSupply, supplyLeft, reservedSupply, presaleActive, saleActive, presaleMaxMintsPerTrans, and publicMaxMintsPerTrans.\n- Merkle Whitelisting: Incorporate a merkleRoot for validating presale eligibility through Merkle proofs, ensuring a secure and transparent whitelist mechanism.\n- Whitelist Tracking: Use a mapping (whitelistClaimed) to track addresses that have claimed their presale tokens.\n\nFunctionality Requirements:\n1. Initialization: Initialize the contract by minting reserved tokens to the owner and updating the supply accordingly.\n2. Presale and Sale Management: Methods to toggle the status of the presale and the public sale, allowing the contract owner to start or stop token sales.\n3. Pricing and Metadata: Functions for the owner to update the token price, the URI for token metadata, and the Merkle root for presale eligibility verification.\n4. Withdrawal: Enable the contract owner to withdraw the contract's balance, ensuring secure handling of funds collected from token sales.\n5. Token Queries: Include view functions to retrieve the contract's balance, token price, remaining supply, and the total supply of tokens.\n\nSafety Considerations:\n- Implement access control for administrative functions (onlyOwner) to prevent unauthorized modifications.\n- Validate sale states (presaleActive, saleActive) and enforce minting limits (presaleMaxMintsPerTrans, publicMaxMintsPerTrans) during token purchase to uphold sale rules.\n- Use require statements to check for correct ETH amounts sent, presale whitelist eligibility, and supply constraints to ensure transactions meet all conditions for minting.\n\nImplementation Details:\n- Presale Minting: Detail the process for presale minting, including verifying the Merkle proof against the merkleRoot, ensuring the account hasn't already claimed, and enforcing the presale minting limit.\n- Public Minting: Describe the minting function accessible during the public sale phase, checking for active sale status, positive minting amounts, and compliance with the public minting limit.\n- Token Transfer Hooks: Incorporate necessary overrides for ERC1155's _beforeTokenTransfer to accommodate supply tracking and any additional token transfer logic.\n- ERC1155 Compatibility: Ensure the contract properly implements required ERC1155 and ERC1155Supply functions for compatibility with ERC1155 token standards and utilities.\n\nExamples and Resources:\n- Suggest referencing OpenZeppelin's ERC1155 and ERC1155Supply contracts for secure and standard-compliant implementations.\n- Recommend tools and platforms like Hardhat or Truffle for development, testing, and deployment, facilitating a smooth workflow for contract creation and management.\n"}, {"role": "assistant", "content": "contract AquaTools is ERC1155, Ownable, ERC1155Supply {\n    uint256 public price = 0.1 ether;\n    uint16 public maxSupply = 3000;\n    uint16 public supplyLeft = maxSupply;\n    uint8 public reservedSupply = 200;\n    bool public presaleActive;\n    bool public saleActive;\n    uint8 public presaleMaxMintsPerTrans = 1;\n    uint8 public publicMaxMintsPerTrans = 3;\n    uint8 public passIndex = 0;\n    bytes32 public merkleRoot =\n        0x9492a15aa69d55a18e1181ac3b84b971ef9799e23b284f144961474af08621d9;\n\n    mapping(address => bool) public whitelistClaimed;\n\n    constructor()\n        ERC1155(\"ipfs://QmTF8cSSv5Ewexo4TMU8Wg1MqEwXHfLVxYkuhy7GzwSU6U\")\n    {\n        _mint(msg.sender, passIndex, reservedSupply, \"\");\n\n        supplyLeft -= reservedSupply;\n    }\n\n    // Write functions\n\n    function setPresaleStatus(bool _presaleActive) public onlyOwner {\n        presaleActive = _presaleActive;\n    }\n\n    function setSaleStatus(bool _saleActive) public onlyOwner {\n        saleActive = _saleActive;\n    }\n\n    function setPrice(uint256 _price) public onlyOwner {\n        price = _price;\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    function setURI(string memory newuri) public onlyOwner {\n        _setURI(newuri);\n    }\n\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    // Read functions\n\n    function hasToken(address account) public view returns (bool) {\n        return balanceOf(account, passIndex) > 0;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return price;\n    }\n\n    function getSupplyLeft() public view returns (uint16) {\n        return supplyLeft;\n    }\n\n    function getMaxSupply() public view returns (uint16) {\n        return maxSupply;\n    }\n\n    function getMerkleRoot() public view returns (bytes32) {\n        return merkleRoot;\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // Mint\n\n    function mintPresale(\n        address account,\n        uint8 amount,\n        bytes32[] calldata _merkleProof\n    ) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(presaleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(!whitelistClaimed[msg.sender], \"Address has already claimed\");\n        require(amount <= presaleMaxMintsPerTrans, \"Only 1 mint allowed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(account));\n        require(\n            MerkleProof.verify(_merkleProof, merkleRoot, leaf),\n            \"Invalid proof\"\n        );\n\n        _mint(account, passIndex, amount, \"\");\n        whitelistClaimed[msg.sender] = true;\n\n        supplyLeft -= amount;\n    }\n\n    function mint(address account, uint8 amount) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(saleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(amount <= publicMaxMintsPerTrans, \"Only 3 mints allowed\");\n\n        _mint(account, passIndex, amount, \"\");\n\n        supplyLeft -= amount;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155, ERC1155Supply) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a KOK_Contract smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The KOK_Contract is an Ethereum-based ERC20 token with a predefined total supply of 5 billion units (accounting for 18 decimal places), named \"KOK Coin,\" featuring mechanisms for owner-driven airdrops, contract operational control, and blacklist management. It allows the contract owner to initiate or halt token transfers, manage a blacklist to prevent certain addresses from participating in transactions, and distribute tokens via airdrop to a specified list of recipients under operational conditions. Essential ERC20 functions are implemented with added checks against a blacklist for both senders and receivers, and operations can be paused or resumed by the owner, underlining a layer of administrative control over the contract's functionality.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nContract Structure Overview:\n- Token Information: Define immutable properties like symbol, name, decimals, and totalSupply.\n- Operational Control: Implement a boolean stopped to manage the contract's operational state (e.g., paused or active).\n- Blacklisting Mechanism: Introduce a mapping (blackList) to track blacklisted addresses, which are restricted from participating in transactions.\n- Balance and Allowances: Utilize mappings for tracking balances (balances) and allowances (allowed).\n\nFunctionality Requirements:\n1. Initialization: Initialize the contract by assigning the total supply to the deployer's balance.\n2. Airdrop Functionality: Develop an airdrop function to distribute tokens to multiple addresses, ensuring no address receives tokens more than once.\n3. Blacklist Management: Provide functions to add or remove addresses from the blacklist (blacklisting, deleteFromBlacklist), emitting corresponding events.\n4. Operational Control: Implement methods to stop (stop) and start (start) contract operations, affecting all transactional functions.\n5. Transaction Restrictions: Modify standard ERC20 transfer and transferFrom functions to reject transactions involving blacklisted addresses, with appropriate event logging.\n6. ERC20 Compliance: Ensure full compliance with the ERC20 standard, implementing balanceOf, transfer, approve, allowance, and their corresponding events.\n\nSafety Considerations:\n- Use require statements to enforce function preconditions like sufficient balances, non-blacklisted addresses, and operational status.\n- Protect critical functions (airdrop, blacklisting, deleteFromBlacklist, stop, start) with the onlyOwner modifier to restrict access to the contract owner.\n- Validate array lengths and ensure consistency in the airdrop function to prevent indexing errors.\n\nImplementation Details:\n- Airdrop Implementation: Iterate through recipient addresses, checking for prior token receipt before transferring the specified amounts.\n- Blacklist Checks: In transfer and transferFrom, add checks against blackList to either proceed with the transaction or reject and emit an appropriate event.\n- Operational Pause/Resume: Use the notStopped modifier for transactional functions to check the stopped state, allowing actions only when the contract is active.\n- Event Logging: Define and emit events (Blacklisted, DeleteFromBlacklist, RejectedPaymentToBlacklistedAddr, RejectedPaymentFromBlacklistedAddr) to provide transparency and traceability for blacklist-related actions and rejected transactions.\n\nExamples and Resources:\n- Consult OpenZeppelin's libraries for secure and tested implementations of ERC20 functions and access control patterns.\n- Reference Ethereum's ERC20 token standard documentation for details on function specifications and event definitions.\n"}, {"role": "assistant", "content": "contract KOK_Contract is ERC20Interface, Owned {\r\n\tstring public constant symbol = \"KOK\";\r\n\tstring public constant name = \"KOK Coin\";\r\n\tuint8 public constant decimals = 18;\r\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\r\n\r\n\tbool public stopped;\r\n\r\n\tmapping (address => int8) public blackList;\r\n\r\n\tmapping (address => uint256) public balances;\r\n\tmapping (address => mapping (address => uint256)) public allowed;\r\n\r\n\r\n    event Blacklisted(address indexed target);\r\n    event DeleteFromBlacklist(address indexed target);\r\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\r\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\r\n\r\n\r\n\tmodifier notStopped {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n\r\n// constructor\r\n\tfunction KOKContract() public {\r\n\t\tbalances[msg.sender] = totalSupply;\r\n\t}\r\n\t\r\n// function made for airdrop\r\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\r\n\t    for(uint256 i = 0; i < _to.length; i++){\r\n\t        if(balances[_to[i]] > 0){\r\n\t            continue;\r\n\t        }\r\n\t        transfer(_to[i], _value[i]);\r\n\t    }\r\n\t}\r\n\r\n// blacklist management\r\n    function blacklisting(address _addr) onlyOwner public {\r\n        blackList[_addr] = 1;\r\n        emit Blacklisted(_addr);\r\n    }\r\n    function deleteFromBlacklist(address _addr) onlyOwner public {\r\n        blackList[_addr] = -1;\r\n        emit DeleteFromBlacklist(_addr);\r\n    }\r\n\r\n// stop the contract\r\n\tfunction stop() onlyOwner {\r\n        stopped = true;\r\n    }\r\n    function start() onlyOwner {\r\n        stopped = false;\r\n    }\r\n\t\r\n// ERC20 functions\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\r\n\t\treturn balances[_owner];\r\n\t}\r\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\r\n\t\trequire(balances[msg.sender] >= _value);\r\n\r\n\t\tif(blackList[msg.sender] > 0){\r\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(blackList[_to] > 0){\r\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[msg.sender] -= _value;\r\n\t\tbalances[_to] += _value;\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\r\n\t\trequire(balances[_from] >= _value\r\n\t\t\t&& allowed[_from][msg.sender] >= _value);\r\n\r\n\t\tif(blackList[_from] > 0){\r\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(blackList[_to] > 0){\r\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[_from] -= _value;\r\n\t\tallowed[_from][msg.sender] -= _value;\r\n\t\tbalances[_to] += _value;\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Minttk smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The Minttk contract is an ERC20 token named \"Minttk\" with a symbol \"MNT,\" total supply of 500 million tokens, and subdivides its allocation across different sectors such as crowd sale, POS mining, corporate reserve, promotion, and bounty, leaving a specific amount for remaining tokens. It includes functionalities for minting additional tokens to users' balances based on predefined criteria, such as holding period, and incorporates standard ERC20 functions with an added layer of conditions to ensure the minting process adheres to the contract's rules. Ownership controls are in place for administrative actions, including token minting and emergency contract drainage, emphasizing a centralized control mechanism over the contract's critical operations.\n\nContract Structure Overview:\n- Token Properties: Define constants for name, symbol, decimals, _totalsupply, along with variable allocations for different purposes such as crowdSale, posMining, corporateReserve, promotionBounty, and remainingToken.\n- Ownership: Utilize an owner variable to identify the contract owner.\n- Minting Mechanism: Introduce a mapping (mintingDate) to track the last minting date for each address.\n- Balance Management: Implement mappings for storing balances and allowed allowances between addresses.\n- Operational Control: Implement a stopped boolean flag to enable or disable minting.\n\nFunctionality Requirements:\n1. Initialization: Allocate the remainingToken amount to the contract deployer and establish the contract's owner.\n2. Minting Bonus: Create a mint function that allows token holders to receive a bonus percentage of their holdings if they have not minted in the last 7 days.\n3. ERC20 Standard Compliance: Ensure the contract includes standard ERC20 functions such as transfer, transferFrom, approve, and allowance, with modifications to support the minting mechanism.\n4. Blacklist Prevention: Incorporate checks in token transfer functions to prevent transactions to blacklisted addresses (0x0 address in this case).\n5. Withdrawal Mechanism: Enable the contract owner to withdraw Ethereum stored in the contract.\n\nSafety Considerations:\n- Protect sensitive functions with onlyOwner modifier to restrict access to the contract's owner.\n- Utilize SafeMath for all arithmetic operations to prevent overflow and underflow vulnerabilities.\n- Implement input validation in functions (e.g., non-zero addresses, sufficient balances) to prevent erroneous transactions and enforce minting rules.\n"}, {"role": "assistant", "content": "\ncontract Minttk is ERC20 { \n    using SafeMath for uint256;\n    string public constant name     = \"Minttk\";                    // Name of the token\n    string public constant symbol   = \"MNT\";                       // Symbol of token\n    uint8 public constant decimals  = 18;                           // Decimal of token\n    uint public _totalsupply        = 500000000 * 10 ** 18;         // 500 million total supply // muliplies dues to decimal precision\n    uint public crowdSale           = 60000000 * 10 ** 18;          // 60 million in Crowd Sale\n    uint public posMining           = 350000000 * 10 ** 18;         // 350 million in POS Mining\n    uint public corporateReserve    = 80000000 * 10 ** 18;          // 80 million in Corporate Reserve\n    uint public promotionBounty     = 10000000 * 10 ** 18;          // 10 million in Promotion & Bounty\n    uint public remainingToken      = 150000000 * 10 ** 18;         // 150 million in Remaining Token | Total Supply - POS\n    address public owner;                                           // Owner of this contract\n    mapping(address => uint256) internal mintingDate;\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    \n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    function Minttk() public {\n        balances[msg.sender] = remainingToken;\n        Transfer(0, msg.sender, remainingToken);\n    }\n    \n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalsupply;\n    }\n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    \n    // Token minting function\n    function mint() public {\n        address _customerAddress = msg.sender;\n        uint256 userBalance = balances[_customerAddress];\n        uint256 currentTs = now;\n        uint256 userMintingDate = mintingDate[_customerAddress] + 7 days;\n        require (userBalance > 0);\n        require (currentTs > userMintingDate);\n        mintingDate[_customerAddress] = currentTs;\n        uint256 _bonusAmount = SafeMath.percent(userBalance,2,100,18);\n        balances[_customerAddress] = (uint256)(balances[_customerAddress]).add(_bonusAmount);\n    }\n    \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount ) public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n  \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        \n        address _customerAddress = msg.sender;\n        uint256 currentTs = now;\n        uint256 userMintingDate = mintingDate[_customerAddress] + 7 days;\n        require (currentTs > userMintingDate);\n        \n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    // Transfer the balance from owner's account to another account\n    function transferTokens(address _to, uint256 _amount) private returns (bool success) {\n        require( _to != 0x0);       \n        require(balances[address(this)] >= _amount && _amount > 0);\n        balances[address(this)] = (balances[address(this)]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(address(this), _to, _amount);\n        return true;\n    }\n \n    function drain() external onlyOwner {\n        owner.transfer(this.balance);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a TattooSkullzSociety smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The TattooSkullzSociety smart contract is an NFT collection based on the Ethereum blockchain, adhering to ERC721 standards for unique digital assets, with a capped supply of 5000 tokens and a provision for special allowances through an allowlist mechanism. It features mechanisms to activate or deactivate public sales and allowlist sales, set prices, reserve tokens for specific purposes, and manage NFT metadata, ensuring a controlled distribution process and customizable ownership experience. Additionally, it includes administrative functions to adjust sale states, withdraw contract balances, and set provenance and base URI data, highlighting owner-exclusive controls over the contract's operational aspects.\n\nContract Structure Overview:\n- Core Properties: Implement ERC721 and ERC721Enumerable for NFT standards, along with Ownable for ownership management.\n- Sale Mechanics: Define booleans isAllowListActive and saleIsActive to manage presale and public sale states.\n- Token Limits and Pricing: Set constants for MAX_SUPPLY, MAX_PUBLIC_MINT, RESERVE_MINT, and PRICE_PER_TOKEN to control minting limits and pricing.\n- Allowlist Mechanism: Utilize a mapping (_allowList) to manage the number of tokens addresses on the allowlist can mint.\n\nFunctionality Requirements:\n1. Initialization: Initialize the NFT collection with a name and symbol upon deployment.\n2. Allowlist Management:\n    - Enable the contract owner to activate/deactivate the allowlist and set allowed mint amounts per address.\n    - Provide a function to check the number of tokens an address is eligible to mint from the allowlist.\n3. Minting Functions:\n    - Implement mintAllowList for allowlisted addresses to mint a specified number of tokens, adhering to allowlist and public minting restrictions.\n    - Create a mint function for the public sale, allowing any user to mint tokens within defined limits during the active sale period.\n4. Reserved Tokens and Withdrawal:\n    - Offer a reserve function for the owner to mint reserved tokens to the owner's address.\n    - Include a withdraw function for the owner to transfer the contract's balance (Ether) to their personal address.\n\nSafety Considerations:\n- Apply onlyOwner modifier to protect administrative functions like toggling sale states, modifying allowlist, and withdrawing funds.\n- Use require statements for validation checks in minting functions to enforce rules about sale state, mint limits, and Ether sent.\n- Ensure ERC721 and ERC721Enumerable compatibility in token transfers and interface support functions.\n\nImplementation Details:\n- Provenance Record: Incorporate a PROVENANCE variable to store a provenance hash, representing the authenticity and origin of the art collection.\n- Base URI Management: Allow the owner to update _baseURIextended for dynamic metadata storage locations, overriding the _baseURI function for token URI computations.\n- Overriding Functions:\n    - Override _beforeTokenTransfer from ERC721 and ERC721Enumerable to maintain token enumeration during transfers.\n    - Ensure supportsInterface accurately reports contract capabilities, considering both ERC721 and ERC721Enumerable.\n\nExamples and Resources:\n- Reference OpenZeppelin's contracts for ERC721, ERC721Enumerable, and Ownable to ensure secure and standard-compliant implementation.\n- Utilize development frameworks like Hardhat or Truffle for testing, deploying, and verifying the smart contract.\n"}, {"role": "assistant", "content": "\ncontract TattooSkullzSociety is ERC721, ERC721Enumerable, Ownable {\n    string public PROVENANCE;\n    string private _baseURIextended;\n\n    bool public isAllowListActive = false;\n    bool public saleIsActive = false;\n    \n    uint256 public constant MAX_SUPPLY = 5000;\n    uint256 public constant MAX_PUBLIC_MINT = 22;\n    uint256 public constant RESERVE_MINT = 222;\n    uint256 public constant PRICE_PER_TOKEN = 0.08 ether;\n\n    mapping(address => uint8) private _allowList;\n\n    constructor() ERC721(\"TattooSkullzSociety\", \"SKULLZ\") {\n    }\n\n    // Whitelist\n    function setIsAllowListActive(bool _isAllowListActive) external onlyOwner {\n        isAllowListActive = _isAllowListActive;\n    }\n\n    function setAllowList(address[] calldata addresses, uint8 numAllowedToMint) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            _allowList[addresses[i]] = numAllowedToMint;\n        }\n    }\n\n    function numAvailableToMint(address addr) external view returns (uint8) {\n        return _allowList[addr];\n    }\n\n    function mintAllowList(uint8 numberOfTokens) external payable {\n        uint256 ts = totalSupply();\n        require(isAllowListActive, \"Allow list is not active\");\n        require(numberOfTokens <= _allowList[msg.sender], \"Exceeded max available to purchase\");\n        require(numberOfTokens <= MAX_PUBLIC_MINT, \"Exceeded max token purchase\");\n        require(ts + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max tokens\");\n        require(PRICE_PER_TOKEN * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n\n        _allowList[msg.sender] -= numberOfTokens;\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, ts + i);\n        }\n    }\n\n    // Mint\n    function setSaleState(bool newState) public onlyOwner {\n        saleIsActive = newState;\n    }\n\n    function mint(uint numberOfTokens) public payable {\n        uint256 ts = totalSupply();\n        require(saleIsActive, \"Sale must be active to mint tokens\");\n        require(numberOfTokens <= MAX_PUBLIC_MINT, \"Exceeded max token purchase\");\n        require(ts + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max tokens\");\n        require(PRICE_PER_TOKEN * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, ts + i);\n        }\n    }\n\n    // Utils\n    function reserve(uint numberOfTokens) public onlyOwner {\n      uint supply = totalSupply();\n      uint i;\n      for (i = 0; i < numberOfTokens; i++) {\n          _safeMint(msg.sender, supply + i);\n      }\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function setProvenance(string memory provenance) public onlyOwner {\n        PROVENANCE = provenance;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\n        _baseURIextended = baseURI_;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a TomoeGozen smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The TomoeGozen contract, built on Ethereum, integrates ERC721A for efficient batch minting, allowing for a maximum supply of 8000 unique tokens with specific minting limits set for public and presale phases. It employs a Merkle proof verification system to securely manage whitelist access during the presale phase, ensuring only eligible addresses can mint up to a predetermined limit, and it facilitates public minting with a separate limit, alongside owner-specific minting without restrictions. Additionally, the contract features a withdraw function that divides the contract's balance among predefined roles including community multisig, owners, marketing, developers, and artists, highlighting a structured revenue distribution model.\n\nContract Structure Overview:\n- Inheritance and Utilities: Implement Ownable for ownership management, ERC721A for NFT functionalities, and ReentrancyGuard for security against re-entrancy attacks.\n- Sale Phases and Limits: Define constants for MAX_SUPPLY, PUBLIC_MINT_LIMIT, PRESALE_MINT_LIMIT, and MINT_PRICE to manage minting conditions and pricing.\n- Merkle Proof Allowlist: Utilize a merkleRoot for validating presale participants and a mapping (whitelistMints) to track individual presale mintings.\n- Sale State: Employ a saleFlag variable to toggle between inactive, presale, and public sale states.\n\nFunctionality Requirements:\n1. Base URI Management: Allow the owner to set a baseURI for metadata resolution.\n2. Sale Phase Control: Provide functions for the owner to switch between different sale phases (inactive, presale, public) using the saleFlag.\n3. Merkle Root Configuration: Enable the owner to update the merkleRoot for the presale allowlist.\n4. Public and Presale Minting:\n    - Implement a mint function for public sale phase, enforcing public mint limits and sale activation.\n    - Create a mintWhitelist function for the presale phase, requiring valid Merkle proof for participation and adhering to presale mint limits.\n5. Owner Minting: Facilitate minting directly to any address by the owner, bypassing sale phase checks and mint limits.\n6. Funds Withdrawal and Allocation:\n    - Design a withdraw function to distribute contract Ether balance among predefined addresses according to specific percentages for different roles (e.g., community, owners, marketing).\n\nSafety Considerations:\n- Protect sensitive functions with onlyOwner and nonReentrant modifiers to ensure that only the contract owner can execute them and guard against re-entrancy attacks.\n- Use require statements for validations, such as sale state, mint quantity limits, Ether sent for minting, and total supply constraints.\n\nImplementation Details:\n- Merkle Proof Verification: Utilize MerkleProof library for verifying allowlist eligibility during the presale mint phase.\n- Dynamic Sale Management: Use the saleFlag to dynamically manage which minting functions are available, depending on the sale phase.\n- Efficient Batch Minting: Leverage ERC721A's batch minting capabilities for efficient gas usage during mint operations.\n- Precise Funds Allocation: Calculate and execute Ether transfers to designated roles based on the contract's balance, ensuring accurate distribution according to the specified percentages.\n\nExamples and Resources:\n- Suggest consulting OpenZeppelin's contracts for Ownable, ReentrancyGuard, and other secure base contract implementations.\n- Recommend using tools like Hardhat for development, testing, and deployment, ensuring a robust and secure deployment process.\n"}, {"role": "assistant", "content": "\ncontract TomoeGozen is Ownable, ERC721A, ReentrancyGuard {\n    using MerkleProof for bytes32[];\n\n    uint256 public constant MAX_SUPPLY = 8000;\n    uint256 public constant PUBLIC_MINT_LIMIT = 3;\n    uint256 public constant PRESALE_MINT_LIMIT = 2;\n\n    uint256 public constant MINT_PRICE = 0.08 ether;\n\n    /// Inactive = 0; Presale = 1; Public = 2\n    uint256 public saleFlag;\n\n    bytes32 public merkleRoot;\n    string public baseURI;\n    \n    mapping(address => uint256) private whitelistMints;\n\n    constructor() ERC721A(\"Tomoe Gozen\", \"TOMOE_GOZEN\", 50, MAX_SUPPLY) {}\n\n    function verifyProof(bytes32[] calldata _proof) internal view returns (bool) {\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        return _proof.verify(merkleRoot, leaf);\n    }\n\n    function setBaseURI(string calldata _base) external onlyOwner {\n        baseURI = _base;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    function setSaleFlag(uint256 _flag) external onlyOwner {\n        saleFlag = _flag;\n    }\n\n    function setMerkleRoot(bytes32 _new) external onlyOwner {\n        merkleRoot = _new;\n    }\n\n    function mint(uint256 _quantity) external payable {\n        require(totalSupply() + _quantity <= MAX_SUPPLY, \"MINT_EXCEEDS_TOTAL_SUPPLY\");\n\n        require(saleFlag == 2, \"MINTING_PAUSED\");\n        require(_quantity > 0 && _quantity <= PUBLIC_MINT_LIMIT, \"MINT_EXCEEDS_LIMIT_ALLOWED_PER_TRANSACTION\");\n        require(MINT_PRICE * _quantity <= msg.value, \"AMOUNT_TOO_LOW\");\n        require(tx.origin == msg.sender, \"SENDER_IS_NOT_AN_EOA\");\n\n        _safeMint(msg.sender, _quantity);\n    }\n\n    function mintWhitelist(uint256 _quantity, bytes32[] calldata _proof) external payable {\n        require(totalSupply() + _quantity <= MAX_SUPPLY, \"MINT_EXCEEDS_TOTAL_SUPPLY\");\n\n        require(saleFlag == 1, \"MINTING_PAUSED\");\n        require(verifyProof(_proof), \"INVALID_MERKLE_PROOF\");\n        require(whitelistMints[msg.sender] + _quantity <= PRESALE_MINT_LIMIT, \"MINT_EXCEEDS_LIMIT_ALLOWED_FOR_WHITELIST\");\n        require(_quantity > 0 && _quantity <= PRESALE_MINT_LIMIT, \"MINT_EXCEEDS_LIMIT_ALLOWED_PER_TRANSACTION\");\n        require(MINT_PRICE * _quantity <= msg.value, \"AMOUNT_TOO_LOW\");\n\n        whitelistMints[msg.sender] += _quantity;\n\n        _safeMint(msg.sender, _quantity);\n    }\n\n    function mintOwner(uint256 _quantity, address _to) external onlyOwner {\n        require(totalSupply() + _quantity <= MAX_SUPPLY, \"MINT_EXCEEDS_TOTAL_SUPPLY\");\n\n        _safeMint(_to, _quantity);\n    }\n\n    /** ALLOCATIONS:\n     *  - Community Multisig: 30% (Signers: Bitquence, sOwner1, sOwner2 / 2 of 2 signatures)\n     *  - Owners: 33.75%\n     *  - Marketing: 11.25%\n     *  - Developpers: 22.50%\n     *  - Artist: 2.5%\n     */\n    function withdraw() external onlyOwner nonReentrant {\n        uint256 balanceDividend = address(this).balance / 100000;\n\n        (bool sComm,) = address(0x18B94d7dac879511B0f2Ee2947073b57fa11Fb08).call{value: balanceDividend * 30000}(\"\");\n        (bool sOwner1,) = address(0xEC4f373A70d5Bb5371df8A33951B898B7219f82C).call{value: balanceDividend * 16875}(\"\");\n        (bool sOwner2,) = address(0x4494949245C3C432177C66adf32e272477D6aaFc).call{value: balanceDividend * 16875}(\"\");\n        (bool sMark,) = address(0x39680E7090002731b306A8EE8Fae28072b84E586).call{value: balanceDividend * 11250}(\"\");\n        (bool sDev1,) = address(0x6e1af0E043C18eAd53A5B9886D4901Dd6B67a22f).call{value: balanceDividend * 11250}(\"\");\n        (bool sDev2,) = address(0xe0C5123B0FD1A7D94bB8D84bBAF1026B699C6dC6).call{value: balanceDividend * 11250}(\"\");\n        (bool sArt,) = address(0x62A6958E4FBff46C0ECc64E2eFDE83F75D609DD2).call{value: balanceDividend * 2500}(\"\");\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a EDE smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract for \"EDE,\" utilizing ERC20 standards with additional features supporting a token sale event, including presale and public sale phases with a hard and soft cap. The contract incorporates whitelist functionality, a time-based sale phase system, and unique token distribution mechanisms. The EDE contract is an ERC20 token with a unique ICO phase structure, designed to raise funds through a presale and two subsequent public sales, featuring a built-in whitelist mechanism for eligible participants. It includes a comprehensive fundraising mechanism that adjusts token pricing and bonuses dynamically based on the sale phase, with hard and soft cap targets predefined to guide the overall funding strategy. Additionally, the contract allocates tokens for different purposes such as ICO, team reserves, and airdrops, and implements functions for purchasing tokens, transferring ownership, and redistributing unsold tokens if the hard cap is not reached, ensuring a structured and conditional token distribution process.\n\nContract Structure Overview:\n- Core Token Attributes: Leverage ERC20Interface for token functionalities, setting symbol, name, decimals, and managing _totalSupply.\n- Sale Configuration: Define variables to manage sale phases (presaleopeningtime, firstsaleopeningtime, etc.), caps (HardCap, SoftCap, maximumCap), and track fundsRaised.\n- Access Control and Utilities: Use Owned for ownership management and SafeMath for safe arithmetic operations.\n- Whitelist and Holder Tracking: Implement mappings for whitelist eligibility and dynamically track holders for future distributions.\n\nFunctionality Requirements:\n1. Initialization: Initialize token properties, allocate initial token distributions (ICO, reserve, team, airdrop), and set the sale timeline.\n2. Whitelist Management: Enable the owner to add addresses to the whitelist, allowing them to participate in the token sale.\n3. Sale Phases and Conditions: Control token purchasing through different sale phases, with checks for opening times, funding caps, and whitelist status.\n4. Token Purchasing:\n    - Implement a function (buyTokens) to handle ETH contributions in exchange for tokens, considering the current sale phase and individual contribution limits.\n    - Utilize onlyWhileOpen modifier to restrict purchases to active sale periods and within the maximum cap.\n5. Fund Withdrawal: Create a mechanism for the owner to withdraw collected funds post-sale.\n6. Post-Sale Token Distribution: Facilitate a function to distribute remaining tokens if the hard cap is not reached, proportionally to holders or specific allocations.\n\nSafety Considerations:\n- Enforce contribution minimums and maximums to ensure fair participation and avoid spamming the sale.\n- Use require statements extensively to validate conditions like sale phase, whitelist status, contribution amounts, and total supply limits.\n- Protect sensitive functions with onlyOwner to restrict execution to the contract owner.\n\nImplementation Details:\n- Dynamic Sale Phases: Dynamically manage the sale's active phase based on the current timestamp and predefined phase start and end times.\n- Contribution Tracking: Accurately track contributions in ETH, converting them to token amounts based on the current rate and applying any applicable bonuses.\n- Token Delivery: Ensure tokens are correctly minted or transferred to contributors immediately upon purchase validation.\n- Hard and Soft Cap Logic: Implement logic to handle scenarios where the sale does not meet the hard cap, including redistributing remaining tokens.\n\nExamples and Resources:\n- Suggest referencing OpenZeppelin's contracts for secure and standard-compliant implementations of ERC20 functionalities and ownership management.\n- Highlight the importance of testing with frameworks like Hardhat or Truffle, especially for complex functionalities such as sale phase management and token distribution algorithms.\n"}, {"role": "assistant", "content": "\ncontract EDE is ERC20Interface, Owned {\n    using SafeMath for uint;\n\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n    uint private _teamsTokens;\n    uint private _reserveTokens;\n    uint256 public fundsRaised;\n    uint private maximumCap;\n    address payable wallet;\n    address [] holders;\n\n    uint256 private presaleopeningtime;\n    uint256 private firstsaleopeningtime;\n    uint256 private secondsaleopeningtime;\n    uint256 private secondsaleclosingtime;\n\n\tstring public HardCap;\n\tstring public SoftCap;\n\n\n    mapping(address => uint) balances;\n    mapping(address => bool) whitelist;\n    mapping(address => mapping(address => uint)) allowed;\n\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    modifier onlyWhileOpen {\n        require((now >= presaleopeningtime && now <= secondsaleclosingtime) && fundsRaised != maximumCap); // should be open\n        _;\n    }\n\n    // Constructor\n    constructor() public {\n        symbol = \"EDE\";\n        name = \"eden.best\";\n        decimals = 0;\n        _totalSupply = 45e7;\n        balances[address(this)] = 3375e5 * 10**uint(decimals); // 75% to ICO\n        emit Transfer(address(0),address(this), 3375e5 * 10**uint(decimals));\n        balances[address(0x687abe81c44c982394EED1b0Fc6911e5338A6421)] = 66150000 * 10**uint(decimals); // 14,7% to reserve\n        emit Transfer(address(0),address(0x687abe81c44c982394EED1b0Fc6911e5338A6421), 66150000 * 10**uint(decimals));\n        balances[address(0xd903846cF43aC9046CAE50C36ac1Aa18e630A1bB)] = 45000000 * 10**uint(decimals); // 10% to Team\n        emit Transfer(address(0),address(0xd903846cF43aC9046CAE50C36ac1Aa18e630A1bB), 45000000 * 10**uint(decimals));\n        balances[address(0x7341459eCdABC42C7493D923F5bb0992616d30A7)] = 1350000 * 10**uint(decimals); // 0,3% to airdrop\n        emit Transfer(address(0),address(0x7341459eCdABC42C7493D923F5bb0992616d30A7), 1350000 * 10**uint(decimals));\n        owner = address(0xEfA2CcE041aEB143678F8f310F3977F3EB61251E);\n        wallet = address(0xEfA2CcE041aEB143678F8f310F3977F3EB61251E);\n\t\t    HardCap = \"16875 ETH\";\n        SoftCap = \"300 ETH\";\n        maximumCap = 16875000000000000000000; // 16875 eth, written in wei here\n        presaleopeningtime = 1554120000; // 1st april 2019, 12pm\n        firstsaleopeningtime = 1555329601; // 15 april 2019, 12:00:01pm\n        secondsaleopeningtime = 1559304001; // 31 may 2019, 12:00:01pm\n        secondsaleclosingtime = 1561896001; // 30 june 2019, 12:00:01pm\n    }\n\n    // Accepts ETH\n    function () external payable {\n        buyTokens(msg.sender);\n    }\n\n    function buyTokens(address _beneficiary) public payable onlyWhileOpen {\n        _preValidatePurchase(_beneficiary, msg.value);\n        _continueTokenPurchase(_beneficiary, msg.value);\n    }\n\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view{\n        require(_beneficiary != address(0));\n        require(_weiAmount != 0);\n        require(_weiAmount >= 50000000000000000 && _weiAmount <= 1000000000000000000000); // min 0.05 ETH, max 1000 ETH\n        require(whitelist[_beneficiary]);\n    }\n\n    function _insertWhitelist(address[] memory _beneficiary) public onlyOwner{\n        for(uint256 i = 0; i< _beneficiary.length; i++)\n        {\n            if(whitelist[_beneficiary[i]] == false)\n                whitelist[_beneficiary[i]] = true;\n        }\n    }\n\n    function _continueTokenPurchase(address _beneficiary, uint256 _weiAmount) internal{\n        uint256 _tokens = _getTokenAmount(_weiAmount).div(1e18);\n        uint256 bonus = _calculateBonus();\n        _tokens = _tokens.add((_tokens.mul(bonus.mul(100))).div(10000));\n\n        fundsRaised = fundsRaised.add(_weiAmount);\n\n        _processPurchase(_beneficiary, _tokens);\n\n        wallet.transfer(_weiAmount);\n        emit TokenPurchase(address(this), _beneficiary, _weiAmount, _tokens);\n    }\n\n    function _getTokenAmount(uint256 _weiAmount) internal pure returns (uint256) {\n        uint256 rate = 2e4; // 1 eth = 20,000T\n        return _weiAmount.mul(rate);\n    }\n\n    function _calculateBonus() internal view returns (uint256){\n        if(now >= presaleopeningtime && now < firstsaleopeningtime){\n            return 30;\n        } else if(now >=firstsaleopeningtime && now <secondsaleopeningtime){\n            return 20;\n        } else if(now >= secondsaleopeningtime && now <secondsaleclosingtime){\n            return 0;\n        }\n    }\n\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n        _deliverTokens(_beneficiary, _tokenAmount);\n    }\n\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n        _transfer(_beneficiary, _tokenAmount);\n    }\n\n    function totalSupply() public view returns (uint){\n       return _totalSupply* 10**uint(decimals);\n    }\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    // Transfer the balance from token owner's account to `to` account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    function transfer(address to, uint tokens) public returns (bool success) {\n        // prevent transfer to 0x0, use burn instead\n        require(to != address(0));\n        require(whitelist[to]);\n        require(balances[msg.sender] >= tokens );\n        require(balances[to] + tokens >= balances[to]);\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        if(balances[to] == 0)\n            holders.push(to);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(msg.sender,to,tokens);\n        return true;\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account\n    function approve(address spender, uint tokens) public returns (bool success){\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender,spender,tokens);\n        return true;\n    }\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    function transferFrom(address from, address to, uint tokens) public returns (bool success){\n        require(tokens <= allowed[from][msg.sender]); //check allowance\n        require(balances[from] >= tokens);\n        require(whitelist[to]);\n        balances[from] = balances[from].sub(tokens);\n        if(balances[to] == 0)\n            holders.push(to);\n        balances[to] = balances[to].add(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        emit Transfer(from,to,tokens);\n        return true;\n    }\n    // Returns the amount of tokens approved by the owner that can be transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n    function _transfer(address to, uint tokens) internal returns (bool success) {\n        // prevent transfer to 0x0, use burn instead\n        require(to != address(0));\n        require(balances[address(this)] >= tokens );\n        require(balances[to] + tokens >= balances[to]);\n        balances[address(this)] = balances[address(this)].sub(tokens);\n        if(balances[to] == 0)\n            holders.push(to);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(address(this),to,tokens);\n        return true;\n    }\n\n    function _hardCapNotReached() external onlyOwner {\n        uint eightyPercent = (balances[address(this)].mul(80)).div(100); // 80% of remaining tokens\n        uint twentyPercent = balances[address(this)].sub(eightyPercent); // 20% of remaining tokens\n        uint share = eightyPercent.div(holders.length);\n\n        for(uint i = 0; i<holders.length; i++ ){\n            address holder = holders[i];\n            balances[holder] = balances[holder].add(share);\n            emit Transfer(address(this),holder,share);\n        }\n\n        balances[address(0x687abe81c44c982394EED1b0Fc6911e5338A6421)] = twentyPercent;\n        emit Transfer(address(this),address(0x687abe81c44c982394EED1b0Fc6911e5338A6421),twentyPercent);\n\n        balances[address(this)] = 0;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ERC721PresetMinterPauserAutoId smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create an Ethereum smart contract named \"ERC721PresetMinterPauserAutoId\" that extends ERC721 token functionality. This contract includes role-based permissions for minting and pausing token transfers, an automatic ID assignment for tokens, and a mechanism to limit and track base URI changes.\n\nContract Structure Overview:\n- Inheritance and Functionality: Leverage AccessControlEnumerable for role-based access control, ERC721Enumerable for token enumeration, ERC721Burnable for token burning, and ERC721Pausable for pausing token transfers.\n- Role Management: Define roles MINTER_ROLE and PAUSER_ROLE for minting and pausing functionalities, respectively.\n- Token ID Management: Utilize Counters.Counter for automatic token ID tracking.\n- Base URI Management: Implement logic to set and manage a base token URI with a limit on the number of times it can be reset.\n\nFunctionality Requirements:\n1. Role-Based Access Control:\n    - Grant DEFAULT_ADMIN_ROLE, MINTER_ROLE, and PAUSER_ROLE to the deployer.\n    - Ensure only accounts with MINTER_ROLE can mint new tokens and those with PAUSER_ROLE can pause or unpause the contract.\n2. Automatic Token ID Assignment:\n    - Automatically assign token IDs using a counter to maintain uniqueness, even in cases of token burning.\n3. Base URI Management:\n    - Provide a function setBaseURI to set the base URI for token metadata, restrictable to a predefined number of resets and only by those with MINTER_ROLE.\n4. Minting Functionality:\n    - Implement a mint function allowing users with MINTER_ROLE to mint new tokens to a specified address.\n5. Pause Functionality:\n    - Enable pausing and unpausing of all token transfers through pause and unpause functions, accessible only by users with PAUSER_ROLE.\n\nSafety Considerations:\n- Use require statements to enforce role permissions and operational conditions, such as base URI reset limitations.\n- Incorporate checks to ensure the contract is not paused during token transfers, minting, or other sensitive operations.\n\nImplementation Details:\n- Role-Based Permission Checks: Utilize AccessControl's role checking functions (hasRole) to guard against unauthorized actions.\n- Token ID Incrementation: Ensure token IDs are incremented correctly upon each mint to maintain sequential order and uniqueness.\n- Base URI Resets: Track the number of times the base URI has been reset and enforce a cap on this action to prevent abuse or accidental changes.\n- Overriding ERC721 Functions: Properly override functions from ERC721, ERC721Enumerable, and ERC721Pausable to integrate the contract's custom logic with inherited functionalities.\n\nExamples and Resources:\n- Reference OpenZeppelin's contracts and documentation for secure and efficient implementations of ERC721 standards and role-based access control.\n- Highlight the importance of thorough testing, especially for functions involving role permissions and token ID management, to ensure contract security and integrity.\n"}, {"role": "assistant", "content": "\ncontract ERC721PresetMinterPauserAutoId is\n    Context,\n    AccessControlEnumerable,\n    ERC721Enumerable,\n    ERC721Burnable,\n    ERC721Pausable\n{\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    Counters.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n    \n    uint8 private constant MAX_URI_RESETS_ALLOWED = 1;\n    uint8 public uriResetCount = 0;\n\n    // Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the account that deploys the contract.\n    constructor(\n        string memory name,\n        string memory symbol\n    ) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n    \n    \n    // Sets `_baseTokenURI`. Resets allowed only `MAX_URI_RESETS_ALLOWED` no of times\n    function setBaseURI(string memory baseTokenURI) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"You don't have permission to do this.\");\n        require(uriResetCount <= MAX_URI_RESETS_ALLOWED, \"Max resets allowed is breached now\");\n        _baseTokenURI = baseTokenURI;\n        uriResetCount++;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    // Creates a new token for `to`. Its token ID will be automatically assigned (and available on the emitted {IERC721-Transfer} event), and the token URI autogenerated based on the base URI passed at construction.\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    // Pauses all token transfers.\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    //  Unpauses all token transfers.\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Wallstreetbets smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The Wallstreetbets contract is an ERC20 token named \"Wallstreetbets stocks and Options trading,\" with a total supply of 65 million tokens, including 18 decimal places for fractional values. It incorporates basic ERC20 functions such as token transfers, allowances, and balance checks, alongside owner-specific functions like the ability to burn tokens to reduce the total supply and transfer contract ownership. The contract uses SafeMath for mathematical operations to prevent overflow errors, emphasizing security in token transactions and ownership management within the Ethereum blockchain ecosystem.\n\nContract Structure Overview:\n- Core Attributes: Utilize ERC20 for token functionality, setting properties like symbol, name, decimals, and _totalSupply.\n- Ownership Management: Introduce an owner address to identify the contract's owner and provide mechanisms to transfer ownership.\n- Token Balances and Allowances: Implement mappings for balances and allowed to track token distribution and delegated transfer permissions.\n\nFunctionality Requirements:\n1. Initialization:\n    - Set the contract's creator as the initial owner and allocate the entire token supply to their balance.\n    - Emit a transfer event from address 0 to the owner upon contract creation.\n2. Owner-Only Functions:\n    - Include a burntokens function to reduce the total supply, accessible only by the contract owner.\n    - Provide a transferOwnership function allowing the current owner to transfer their role and token balance to a new address.\n3. ERC20 Standard Operations:\n    - Implement totalSupply, balanceOf, transfer, transferFrom, approve, and allowance functions according to the ERC20 standard.\n    - Ensure all transfers and approvals check for valid addresses (non-zero) and sufficient balances or allowances.\n\nSafety Considerations:\n- Use SafeMath library to prevent integer overflows and underflows across all arithmetic operations.\n- Apply a onlyOwner modifier to restrict sensitive actions like burning tokens and transferring ownership to the current owner only.\n- Validate input parameters for functions, especially for address parameters, to avoid transfers to the zero address (0x0).\n\nImplementation Details:\n- Token Burning: Allow the owner to permanently remove a specified amount of tokens from the total supply, decreasing the circulating amount.\n- Ownership Transfer: Safely transfer the entire token balance of the current owner to the new owner and update the owner state variable.\n- ERC20 Compliance: Ensure the contract fully adheres to the ERC20 token standard, facilitating interoperability with wallets, exchanges, and other contracts.\n"}, {"role": "assistant", "content": "\ncontract Wallstreetbets is ERC20 {\n    using SafeMath for uint256;\n    string public constant symbol = \"Wallstreetbets\";\n    string public constant name = \"Wallstreetbets stocks and Options trading\";\n    uint public constant decimals = 18;\n    uint256 _totalSupply = 65999999 * 10 ** 18; // 65 million Total Supply including 18 decimal\n\n    // Owner of this contract\n    address public owner;\n     \n    // Balances for each account\n    mapping(address => uint256) balances;\n\n    // Owner of account approves the transfer of an amount to another account\n    mapping(address => mapping (address => uint256)) allowed;\n\n    // Functions with this modifier can only be executed by the owner\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    // Constructor\n    constructor () public {\n        owner = msg.sender;\n        balances[owner] = _totalSupply;\n        emit Transfer(0, owner, _totalSupply);\n    }\n    \n    function burntokens(uint256 tokens) public onlyOwner {\n        _totalSupply = (_totalSupply).sub(tokens);\n    }\n\n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalSupply;\n    }\n    function balanceOf(address _owner)public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount)public returns (bool ok) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n         \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount )public returns (bool ok) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    // If this function is called again it overwrites the current allowance with _value.\n    function approve(address _spender, uint256 _amount)public returns (bool ok) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n     }\n  \n    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n        \n     // In case the ownership needs to be transferred\n\tfunction transferOwnership(address newOwner) external onlyOwner\t{\n\t    uint256 x = balances[owner];\n\t    require( newOwner != 0x0);\n\t    balances[newOwner] = (balances[newOwner]).add(balances[owner]);\n\t    balances[owner] = 0;\n\t    owner = newOwner;\n\t    emit Transfer(msg.sender, newOwner, x);\n\t}\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ChubbyCherubs smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The ChubbyCherubs contract is an ERC721 token with a maximum supply limit of 1111 tokens, designed for minting and managing digital collectibles named \"Chubby Cherubs\". It features mechanisms for setting the minting price, toggling the sale state, conducting airdrops to specific addresses, and withdrawing all collected Ether to the owner's address, with price adjustments and sale status changes restricted to the contract owner. The contract includes public functions for minting tokens up to a set maximum per transaction, with safeguards to prevent exceeding the total supply and ensuring the sale is open, alongside an airdrop function for the owner to distribute tokens without payment.\n\nContract Structure Overview:\n- Inheritance and Key Properties: Utilize ERC721 for NFT functionality and Ownable for ownership management. Define constants and variables for maximum supply (MAX_CHUB), minting price, base URI, and sale state.\n- Minting and Supply Tracking: Implement a counter (mintCount) to track the number of tokens minted and enforce the collection's maximum supply limit.\n\nFunctionality Requirements:\n1. Initialization and Base URI Management:\n    - Initialize the contract with a base token URI.\n    - Provide an onlyOwner function to update the base URI as needed.\n2. Minting Price and Sale State:\n    - Allow the contract owner to set and adjust the minting price.\n    - Implement a function to toggle the sale's open/closed state, enabling or disabling public minting.\n3. Public Minting Functionality:\n    - Enable users to mint a specified number of tokens within set limits per transaction, provided the sale is open and the maximum supply has not been reached.\n    - Charge the correct amount of Ether for the number of tokens minted and enforce a maximum mint limit per transaction for non-owner minters.\n4. Airdrop Functionality:\n    - Offer an onlyOwner function to airdrop tokens to a list of addresses, ensuring the operation does not exceed the maximum supply or mint tokens to the null address.\n5. Withdrawal of Contract Funds:\n    - Implement an onlyOwner function to withdraw all Ether collected by the contract through minting operations.\n\nSafety Considerations:\n- Apply require statements to validate function inputs, such as ensuring non-zero recipient addresses, adherence to minting limits, and sufficient payment for minted tokens.\n- Prevent minting beyond the maximum supply to maintain the collection's exclusivity.\n\nImplementation Details:\n- Supply and Minting Limit Checks: Incorporate checks to ensure minting operations do not exceed MAX_CHUB and comply with per-transaction mint limits.\n- Base URI for Metadata: Override the _baseURI function to return the set base URI for token metadata resolution.\n- Event Emission: Emit an event (ChubMinted) upon successful minting of each token to facilitate tracking and verification of mint operations.\n\nExamples and Resources:\n- Reference OpenZeppelin's implementations of ERC721 and Ownable for secure and standard-compliant contract development.\n- Emphasize the importance of testing, especially for functions that handle Ether transactions and modify contract state, to ensure the contract operates securely and as intended under various scenarios.\n"}, {"role": "assistant", "content": "\ncontract ChubbyCherubs is ERC721, Ownable {\n    uint256 private mintCount = 0;\n\n    uint256 public constant MAX_CHUB = 1111;\n    uint256 public price = 70000000000000000; //0.07 Ether\n    string baseTokenURI;\n    bool public saleOpen;\n\n    event ChubMinted(uint256 totalMinted);\n\n    constructor(string memory baseURI) ERC721(\"Chubby Cherubs\", \"CHUB\") {\n        setBaseURI(baseURI);\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        baseTokenURI = baseURI;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return mintCount;\n    }\n\n    function setPrice(uint256 _newPrice) external onlyOwner {\n        price = _newPrice;\n    }\n\n    // Close sale if open, open sale if closed\n    function flipSaleState() external onlyOwner {\n        saleOpen = !saleOpen;\n    }\n\n    function withdrawAll() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function airdrop(address[] calldata _recipients) external onlyOwner {\n        uint256 supply = totalSupply();\n        require(\n            supply + _recipients.length <= MAX_CHUB,\n            \"Airdrop will exceed maximum supply of CHUB\"\n        );\n        require(_recipients.length != 0, \"Address not found\");\n        mintCount += _recipients.length;\n        for (uint256 i = 0; i < _recipients.length; i++) {\n            require(_recipients[i] != address(0), \"Airdrop to Null address\");\n            handleMint(_recipients[i], ++supply);\n        }\n    }\n\n    // mint CHUB\n    function mint(uint256 _count) external payable {\n        uint256 supply = totalSupply();\n        require(supply + _count <= MAX_CHUB, \"Exceeds maximum supply of CHUB\");\n        require(_count > 0, \"Minimum 1 CHUB has to be minted per transaction\");\n\n        if (msg.sender != owner()) {\n            require(saleOpen, \"Sale is not open yet\");\n            require(\n                _count <= 10,\n                \"Maximum 10 Chubby Cherubs can be minted per transaction\"\n            );\n            require(\n                msg.value >= price * _count,\n                \"Ether sent with this transaction is not correct\"\n            );\n        }\n\n        mintCount += _count;\n\n        for (uint256 i = 0; i < _count; i++) {\n            handleMint(msg.sender, ++supply);\n        }\n    }\n\n    function handleMint(address _to, uint256 tokenId) private {\n        _safeMint(_to, tokenId);\n        emit ChubMinted(tokenId);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a LionGame smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract for \"LionGame,\" an NFT collection based on the ERC721 standard, featuring mechanisms for free and public minting, owner-exclusive giveaways, and sale state management. This contract should allow for setting dynamic pricing, minting limits, and supply caps, alongside ensuring secure interactions through reentrancy guards.\n\nContract Structure Overview:\n- Inheritance and Key Features: Utilize ERC721Enum for token enumeration, Ownable for ownership privileges, and ReentrancyGuard for preventing reentrant calls.\n- Sale Configuration: Implement variables to manage the minting cost (cost), maximum supply (maxSupply), maximum mint amount per transaction (maxMint), and the sale status (status).\n\nFunctionality Requirements:\n1. Initialization and Metadata Management:\n    - Initialize the contract with collection name, symbol, and base URI for token metadata.\n    - Provide a function to set or update the base URI.\n2. Minting Functionality:\n    - Implement a freeMint function for minting without cost under certain conditions, like before sale activation.\n    - Create a mint function for public minting that charges Ether based on the specified cost and mint amount.\n    - Ensure minting functions respect the maximum supply and per-transaction mint limits.\n3. Administrative Functions:\n    - Allow the contract owner to mint tokens directly to a given address without cost (giveAway).\n    - Enable the owner to adjust minting cost, maximum mint amount, and the total supply cap.\n    - Provide a mechanism to toggle the sale status, enabling or disabling public minting.\n4. Withdrawal of Funds:\n    - Implement a withdrawal function for the contract owner to transfer collected Ether to their address.\n\nSafety Considerations:\n- Apply require statements to validate minting conditions, such as sale status, mint amount limits, supply caps, and sufficient payment.\n- Use the nonReentrant modifier to safeguard against reentrancy attacks in minting and withdrawal functions.\n\nImplementation Details:\n- Token URI Generation: Override the tokenURI function to concatenate the base URI with the token ID, ensuring a correct metadata endpoint for each NFT.\n- Dynamic Sale Parameters: Allow the owner to dynamically adjust key sale parameters (e.g., cost, max mint amount, sale status) to adapt to changing conditions or community feedback.\n- Supply and Minting Tracking: Utilize the totalSupply function from ERC721Enum to keep track of the current supply and ensure compliance with the minting limits and supply cap.\n\nExamples and Resources:\n- Reference OpenZeppelin's contracts for implementations of ERC721, Ownable, and ReentrancyGuard to ensure secure and standard-compliant contract functionality.\n- Highlight the importance of thorough testing for all contract functions, especially those involving Ether transfers, minting logic, and state changes, to ensure the contract performs reliably under various scenarios.\n"}, {"role": "assistant", "content": "\ncontract LionGame is ERC721Enum, Ownable, ReentrancyGuard {\n\tusing Strings for uint256;\n\tstring public baseURI;\n\t// sale settings\n\tuint256 public cost = 0.05 ether;\n\tuint256 public maxSupply = 777;\n\tuint256 public maxMint = 25;\n\tbool public status = false;\n\n\tconstructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _initBaseURI\n    ) \n    \n    ERC721(_name, _symbol){\n        setBaseURI(_initBaseURI);\n\t}\n\n\t// internal\n\tfunction _baseURI() internal view virtual returns (string memory) {\n\t    return baseURI;\n\t}\n\n    // free minting\n\tfunction freeMint(uint256 _mintAmount) public nonReentrant {\n        uint256 s = totalSupply();\n        require(!status, \"Off\" );\n        require(_mintAmount > 0, \"0\" );\n        require(_mintAmount <= maxMint, \"Too many\" );\n        require(s + _mintAmount <= maxSupply, \"Max\" );\n\n        for (uint256 i = 0; i < _mintAmount; ++i) {\n            _safeMint(msg.sender, s + i, \"\");\n\t    }\n\t    \n        delete s;\n\t}\n\n\t// public minting\n\tfunction mint(uint256 _mintAmount) public payable nonReentrant {\n        uint256 s = totalSupply();\n        require(status, \"Off\" );\n        require(_mintAmount > 0, \"0\" );\n        require(_mintAmount <= maxMint, \"Too many\" );\n        require(s + _mintAmount <= maxSupply, \"Max\" );\n        require(msg.value >= cost * _mintAmount);\n\n        for (uint256 i = 0; i < _mintAmount; ++i) {\n            _safeMint(msg.sender, s + i, \"\");\n        }\n\n        delete s;\n\t}\n\n\t// admin minting\n\tfunction giveAway(address recipient) external onlyOwner {\n        uint256 s = totalSupply();\n        require(s <= maxSupply, \"Max\" );\n        _safeMint(recipient, s, \"\" );\n        delete s;\t\n\t}\n\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: Nonexistent token\");\n        string memory currentBaseURI = _baseURI();\n        return bytes(currentBaseURI).length > 0\t? string(abi.encodePacked(currentBaseURI, tokenId.toString())) : \"\";\n\t}\n\n\tfunction setCost(uint256 _newCost) public onlyOwner {\n\t    cost = _newCost;\n\t}\n\n\tfunction setMaxMintAmount(uint256 _newMaxMintAmount) public onlyOwner {\n\t    maxMint = _newMaxMintAmount;\n\t}\n\n\tfunction setBaseURI(string memory _newBaseURI) public onlyOwner {\n\t    baseURI = _newBaseURI;\n\t}\n\n\tfunction setSaleStatus(bool _status) public onlyOwner {\n\t    status = _status;\n\t}\n\n\tfunction withdraw() public onlyOwner {\n\t    payable(msg.sender).call{value: address(this).balance}(\"\");\n\t}\n\n    function setmaxSupply(uint256 _newMaxSupply) public onlyOwner {\n\t    maxSupply = _newMaxSupply;\n\t}\n}\n"}]