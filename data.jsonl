[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ZCDistribution smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Used to distribute rewards to consumers\n  \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow). \n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function multisend(address[] dests, uint256[] values) public onlyOwner returns (uint256): \n- Distributes the rewards to the consumers. Returns the amount of customers that received tokens. Can only be called by Owner\n- Parameter: dests: Array of cosumer addresses\n- Parameter: values: Array of token amounts to distribute to each client\n \n2. function getSentAmount() external view returns (uint256): \n- Returns the Amount of tokens issued to consumers \n"}, {"role": "assistant", "content": "contract ZCDistribution is Claimable {\r\n\r\n    // Total amount of airdrops that happend\r\n    uint256 public numDrops;\r\n    // Total amount of tokens dropped\r\n    uint256 public dropAmount;\r\n    // Address of the Token\r\n    address public tokenAddress;\r\n\r\n    /**\r\n     * @param _tokenAddr The Address of the Token\r\n     */\r\n    constructor(address _tokenAddr) public {\r\n        assert(_tokenAddr != address(0));\r\n        tokenAddress = _tokenAddr;\r\n    }\r\n\r\n    /**\r\n    * @dev Event when reward is distributed to consumer\r\n    * @param receiver Consumer address\r\n    * @param amount Amount of tokens distributed\r\n    */\r\n    event RewardDistributed(address receiver, uint amount);\r\n\r\n    /**\r\n    * @dev Distributes the rewards to the consumers. Returns the amount of customers that received tokens. Can only be called by Owner\r\n    * @param dests Array of cosumer addresses\r\n    * @param values Array of token amounts to distribute to each client\r\n    */\r\n    function multisend(address[] dests, uint256[] values) public onlyOwner returns (uint256) {\r\n        assert(dests.length == values.length);\r\n        uint256 i = 0;\r\n        while (i < dests.length) {\r\n            assert(ERC20Basic(tokenAddress).transfer(dests[i], values[i]));\r\n            emit RewardDistributed(dests[i], values[i]);\r\n            dropAmount += values[i];\r\n            i += 1;\r\n        }\r\n        numDrops += dests.length;\r\n        return i;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Amount of tokens issued to consumers \r\n     */\r\n    function getSentAmount() external view returns (uint256) {\r\n        return dropAmount;\r\n    }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a AbstractToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Abstract Token Smart Contract that could be used as a base contract forERC-20 token contracts.\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function balanceOf(address _owner) public view returns (uint256 balance): \n- Get number of tokens currently belonging to given owner.\n- Parameter: _owner is the address to get number of tokens currently belonging to the owner\n- Return: number of tokens currently belonging to the owner of given address\n \n2. function transfer(address _to, uint256 _value) public returns (bool success): \n- Transfer given number of tokens from message sender to given recipient.\n- Parameter: _to is the address to transfer tokens to the owner of\n- Parameter: _value is the number of tokens to transfer to the owner of given address\n- Return: true if tokens were transferred successfully, false otherwise accounts [_to] + _value > accounts [_to] for overflow check which is already in safeMath\n \n3. function transferFrom(address _from, address _to, uint256 _value) public returns (bool success): \n- Transfer given number of tokens from given owner to given recipient.\n- Parameter: _from is the address to transfer tokens from the owner of\n- Parameter: _to is the address to transfer tokens to the owner of\n- Parameter: _value is the number of tokens to transfer from given owner to given recipient\n- Return: true if tokens were transferred successfully, false otherwise accounts [_to] + _value > accounts [_to] for overflow check which is already in safeMath\n \n4. function approve (address _spender, uint256 _value) public returns (bool success): Allow given spender to transfer given number of tokens from message sender.\n- Parameter: _spender is the address to allow the owner of to transfer tokens from message sender\n- Parameter: _value is the number of tokens to allow to transfer\n- return true if token transfer was successfully approved, false otherwise\n \n5. function allowance(address _owner, address _spender) public view returns (uint256 remaining): \n- Tell how many tokens given spender is currently allowed to transfer from given owner.\n- Parameter: _owner is the address to get number of tokens allowed to be transferred from the owner of\n- Parameter: _spender is the address to get number of tokens allowed to be transferred by the owner of\n- Return: number of tokens given spender is currently allowed to transfer from given owner\n"}, {"role": "assistant", "content": "contract AbstractToken is Token, SafeMath {\r\n  /**\r\n   * Create new Abstract Token contract.\r\n   */\r\n  constructor () public {\r\n    // Do nothing\r\n  }\r\n  \r\n  /**\r\n   * Get number of tokens currently belonging to given owner.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n   *        owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return accounts [_owner];\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   * accounts [_to] + _value > accounts [_to] for overflow check\r\n   * which is already in safeMath\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {\r\n    require(_to != address(0));\r\n    if (accounts [msg.sender] < _value) return false;\r\n    if (_value > 0 && msg.sender != _to) {\r\n      accounts [msg.sender] = safeSub (accounts [msg.sender], _value);\r\n      accounts [_to] = safeAdd (accounts [_to], _value);\r\n    }\r\n    emit Transfer (msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n   *        recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   * accounts [_to] + _value > accounts [_to] for overflow check\r\n   * which is already in safeMath\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public\r\n  returns (bool success) {\r\n    require(_to != address(0));\r\n    if (allowances [_from][msg.sender] < _value) return false;\r\n    if (accounts [_from] < _value) return false; \r\n\r\n    if (_value > 0 && _from != _to) {\r\n\t  allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value);\r\n      accounts [_from] = safeSub (accounts [_from], _value);\r\n      accounts [_to] = safeAdd (accounts [_to], _value);\r\n    }\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Allow given spender to transfer given number of tokens from message sender.\r\n   * @param _spender address to allow the owner of to transfer tokens from message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   */\r\n   function approve (address _spender, uint256 _value) public returns (bool success) {\r\n    allowances [msg.sender][_spender] = _value;\r\n    emit Approval (msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Tell how many tokens given spender is currently allowed to transfer from\r\n   * given owner.\r\n   *\r\n   * @param _owner address to get number of tokens allowed to be transferred\r\n   *        from the owner of\r\n   * @param _spender address to get number of tokens allowed to be transferred\r\n   *        by the owner of\r\n   * @return number of tokens given spender is currently allowed to transfer\r\n   *         from given owner\r\n   */\r\n  function allowance(address _owner, address _spender) public view\r\n  returns (uint256 remaining) {\r\n    return allowances [_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * Mapping from addresses of token holders to the numbers of tokens belonging\r\n   * to these token holders.\r\n   */\r\n  mapping (address => uint256) accounts;\r\n\r\n  /**\r\n   * Mapping from addresses of token holders to the mapping of addresses of\r\n   * spenders to the allowances set by these token holders to these spenders.\r\n   */\r\n  mapping (address => mapping (address => uint256)) private allowances;\r\n  \r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a BasicToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Basic version of StandardToken, with no allowances.\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function transfer(address _to, uint256 _value) public returns (bool): \n- transfer token for a specified address\n- Parameter: _to is the address to transfer to.\n- Parameter: _value is the amount to be transferred.\n \n2. function balanceOf(address _owner) public constant returns (uint256 balance): \n- Gets the balance of the specified address. \n- Parameter: _owner is the address to query the the balance of. \n- Return: An uint256 representing the amount owned by the passed address. \n"}, {"role": "assistant", "content": "contract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]); \r\n    // SafeMath.sub will throw if there is not enough balance. \r\n    balances[msg.sender] = balances[msg.sender].sub(_value); \r\n    balances[_to] = balances[_to].add(_value); \r\n    Transfer(msg.sender, _to, _value); \r\n    return true; \r\n  } \r\n\r\n  /** \r\n   * @dev Gets the balance of the specified address. \r\n   * @param _owner The address to query the the balance of. \r\n   * @return An uint256 representing the amount owned by the passed address. \r\n   */ \r\n  function balanceOf(address _owner) public constant returns (uint256 balance) { \r\n    return balances[_owner]; \r\n  } \r\n}"}]
