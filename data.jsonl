{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ZCDistribution smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Used to distribute rewards to consumers\n  \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow). \n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function multisend(address[] dests, uint256[] values) public onlyOwner returns (uint256): \n- Distributes the rewards to the consumers. Returns the amount of customers that received tokens. Can only be called by Owner\n- Parameter: dests: Array of cosumer addresses\n- Parameter: values: Array of token amounts to distribute to each client\n \n2. function getSentAmount() external view returns (uint256): \n- Returns the Amount of tokens issued to consumers \n"}, {"role": "assistant", "content": "contract ZCDistribution is Claimable {\r\n\r\n    // Total amount of airdrops that happend\r\n    uint256 public numDrops;\r\n    // Total amount of tokens dropped\r\n    uint256 public dropAmount;\r\n    // Address of the Token\r\n    address public tokenAddress;\r\n\r\n    /**\r\n     * @param _tokenAddr The Address of the Token\r\n     */\r\n    constructor(address _tokenAddr) public {\r\n        assert(_tokenAddr != address(0));\r\n        tokenAddress = _tokenAddr;\r\n    }\r\n\r\n    /**\r\n    * @dev Event when reward is distributed to consumer\r\n    * @param receiver Consumer address\r\n    * @param amount Amount of tokens distributed\r\n    */\r\n    event RewardDistributed(address receiver, uint amount);\r\n\r\n    /**\r\n    * @dev Distributes the rewards to the consumers. Returns the amount of customers that received tokens. Can only be called by Owner\r\n    * @param dests Array of cosumer addresses\r\n    * @param values Array of token amounts to distribute to each client\r\n    */\r\n    function multisend(address[] dests, uint256[] values) public onlyOwner returns (uint256) {\r\n        assert(dests.length == values.length);\r\n        uint256 i = 0;\r\n        while (i < dests.length) {\r\n            assert(ERC20Basic(tokenAddress).transfer(dests[i], values[i]));\r\n            emit RewardDistributed(dests[i], values[i]);\r\n            dropAmount += values[i];\r\n            i += 1;\r\n        }\r\n        numDrops += dests.length;\r\n        return i;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Amount of tokens issued to consumers \r\n     */\r\n    function getSentAmount() external view returns (uint256) {\r\n        return dropAmount;\r\n    }\r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a AbstractToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Abstract Token Smart Contract that could be used as a base contract forERC-20 token contracts.\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function balanceOf(address _owner) public view returns (uint256 balance): \n- Get number of tokens currently belonging to given owner.\n- Parameter: _owner is the address to get number of tokens currently belonging to the owner\n- Return: number of tokens currently belonging to the owner of given address\n \n2. function transfer(address _to, uint256 _value) public returns (bool success): \n- Transfer given number of tokens from message sender to given recipient.\n- Parameter: _to is the address to transfer tokens to the owner of\n- Parameter: _value is the number of tokens to transfer to the owner of given address\n- Return: true if tokens were transferred successfully, false otherwise accounts [_to] + _value > accounts [_to] for overflow check which is already in safeMath\n \n3. function transferFrom(address _from, address _to, uint256 _value) public returns (bool success): \n- Transfer given number of tokens from given owner to given recipient.\n- Parameter: _from is the address to transfer tokens from the owner of\n- Parameter: _to is the address to transfer tokens to the owner of\n- Parameter: _value is the number of tokens to transfer from given owner to given recipient\n- Return: true if tokens were transferred successfully, false otherwise accounts [_to] + _value > accounts [_to] for overflow check which is already in safeMath\n \n4. function approve (address _spender, uint256 _value) public returns (bool success): Allow given spender to transfer given number of tokens from message sender.\n- Parameter: _spender is the address to allow the owner of to transfer tokens from message sender\n- Parameter: _value is the number of tokens to allow to transfer\n- return true if token transfer was successfully approved, false otherwise\n \n5. function allowance(address _owner, address _spender) public view returns (uint256 remaining): \n- Tell how many tokens given spender is currently allowed to transfer from given owner.\n- Parameter: _owner is the address to get number of tokens allowed to be transferred from the owner of\n- Parameter: _spender is the address to get number of tokens allowed to be transferred by the owner of\n- Return: number of tokens given spender is currently allowed to transfer from given owner\n"}, {"role": "assistant", "content": "contract AbstractToken is Token, SafeMath {\r\n  /**\r\n   * Create new Abstract Token contract.\r\n   */\r\n  constructor () public {\r\n    // Do nothing\r\n  }\r\n  \r\n  /**\r\n   * Get number of tokens currently belonging to given owner.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n   *        owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return accounts [_owner];\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   * accounts [_to] + _value > accounts [_to] for overflow check\r\n   * which is already in safeMath\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {\r\n    require(_to != address(0));\r\n    if (accounts [msg.sender] < _value) return false;\r\n    if (_value > 0 && msg.sender != _to) {\r\n      accounts [msg.sender] = safeSub (accounts [msg.sender], _value);\r\n      accounts [_to] = safeAdd (accounts [_to], _value);\r\n    }\r\n    emit Transfer (msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n   *        recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   * accounts [_to] + _value > accounts [_to] for overflow check\r\n   * which is already in safeMath\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public\r\n  returns (bool success) {\r\n    require(_to != address(0));\r\n    if (allowances [_from][msg.sender] < _value) return false;\r\n    if (accounts [_from] < _value) return false; \r\n\r\n    if (_value > 0 && _from != _to) {\r\n\t  allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value);\r\n      accounts [_from] = safeSub (accounts [_from], _value);\r\n      accounts [_to] = safeAdd (accounts [_to], _value);\r\n    }\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Allow given spender to transfer given number of tokens from message sender.\r\n   * @param _spender address to allow the owner of to transfer tokens from message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   */\r\n   function approve (address _spender, uint256 _value) public returns (bool success) {\r\n    allowances [msg.sender][_spender] = _value;\r\n    emit Approval (msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Tell how many tokens given spender is currently allowed to transfer from\r\n   * given owner.\r\n   *\r\n   * @param _owner address to get number of tokens allowed to be transferred\r\n   *        from the owner of\r\n   * @param _spender address to get number of tokens allowed to be transferred\r\n   *        by the owner of\r\n   * @return number of tokens given spender is currently allowed to transfer\r\n   *         from given owner\r\n   */\r\n  function allowance(address _owner, address _spender) public view\r\n  returns (uint256 remaining) {\r\n    return allowances [_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * Mapping from addresses of token holders to the numbers of tokens belonging\r\n   * to these token holders.\r\n   */\r\n  mapping (address => uint256) accounts;\r\n\r\n  /**\r\n   * Mapping from addresses of token holders to the mapping of addresses of\r\n   * spenders to the allowances set by these token holders to these spenders.\r\n   */\r\n  mapping (address => mapping (address => uint256)) private allowances;\r\n  \r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a BasicToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Basic version of StandardToken, with no allowances.\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function transfer(address _to, uint256 _value) public returns (bool): \n- transfer token for a specified address\n- Parameter: _to is the address to transfer to.\n- Parameter: _value is the amount to be transferred.\n \n2. function balanceOf(address _owner) public constant returns (uint256 balance): \n- Gets the balance of the specified address. \n- Parameter: _owner is the address to query the the balance of. \n- Return: An uint256 representing the amount owned by the passed address. \n"}, {"role": "assistant", "content": "contract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]); \r\n    // SafeMath.sub will throw if there is not enough balance. \r\n    balances[msg.sender] = balances[msg.sender].sub(_value); \r\n    balances[_to] = balances[_to].add(_value); \r\n    Transfer(msg.sender, _to, _value); \r\n    return true; \r\n  } \r\n\r\n  /** \r\n   * @dev Gets the balance of the specified address. \r\n   * @param _owner The address to query the the balance of. \r\n   * @return An uint256 representing the amount owned by the passed address. \r\n   */ \r\n  function balanceOf(address _owner) public constant returns (uint256 balance) { \r\n    return balances[_owner]; \r\n  } \r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a GrowthLockContract smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: Contract that vests 200K GRO then payout after every month for the next 24 months.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function depositToken(uint amount) public onlyOwner:\n- Admin can deposit the initial vested amount. You can only use this function once.\n2. function payToken() public onlyOwner:\n- Admin pays dev and management team.\n3. function getBalance() view public returns (uint):\n- Used to check contract balance.\n4. function updateOwner(address newOwner) public onlyOwner:\n- Updates the owner of the contract\n5. function updateManagement(address _mike, address _ghost, address _safe, address _dev) public onlyOwner:\n- Used incase management teams lost their wallet and needs to updated.\n6. function getOwner() view public returns (address):\n- Check who owner is. \n"}, {"role": "assistant", "content": "contract GrowthLockContract {\r\n    \r\n    address private owner; \r\n    address private safe;\r\n    address private mike;\r\n    address private ghost;\r\n    address private dev; \r\n    uint256 public time; \r\n    uint private constant devAmount = 4166.66 * 1 ether;\r\n    uint private constant managementAmount = 1388.88 * 1 ether;\r\n    \r\n    //2629743 = 30 days. \r\n    uint public constant locktime = 2629743; \r\n    \r\n    //0x09e64c2B61a5f1690Ee6fbeD9baf5D6990F8dFd0 is Growth Token address\r\n    ERC20Interface private constant token = ERC20Interface(0x09e64c2B61a5f1690Ee6fbeD9baf5D6990F8dFd0);\r\n    \r\n    \r\n    constructor () {\r\n        owner = msg.sender;\r\n        \r\n        time = block.timestamp; \r\n        \r\n        \r\n        mike = 0x70F5FB6BE943162545a496eD120495B05dC5ce07;\r\n        ghost = 0x6811101D884557Eba52DF3Ea0417A3036D5b9FCd;\r\n        safe = 0xC4faC8CA576B9c8B971fA36916aEE062d84b4901;\r\n        dev = 0xB0632a01ee778E09625BcE2a257e221b49E79696;\r\n        \r\n\r\n  \r\n    }\r\n    \r\n    //Modifier to prevent everyone except owner from using contract.  \r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner, \"Unauthorized to call. \");\r\n        _;\r\n    }\r\n    \r\n    //Admin can deposit the initial vested amount.  You can only use this function once.  \r\n    function depositToken(uint amount) public onlyOwner {\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        \r\n        require(token.transferFrom(msg.sender, address(this), amount) == true, \"Inefficient balance or Unauthorized to pay. \");\r\n\r\n    }\r\n    \r\n    \r\n    //Admin pays dev and management team.\r\n    function payToken() public onlyOwner {\r\n        //check if it's past the next payperiod.  \r\n        require(block.timestamp >= (time + locktime), \"Period not reached yet. \");\r\n\r\n        \r\n        //Sends dev payment. \r\n        require(token.transfer(dev, devAmount) == true, \"You don't have enough in balance. \");\r\n        \r\n        //sends management payments.\r\n        require(token.transfer(safe, managementAmount) == true, \"You don't have enough in balance. \");\r\n        require(token.transfer(mike, managementAmount) == true, \"You don't have enough in balance. \");\r\n        require(token.transfer(ghost, managementAmount) == true, \"You don't have enough in balance. \");\r\n        \r\n        time += locktime; \r\n        \r\n    }\r\n    \r\n    \r\n    //Used to check contract balance. \r\n    function getBalance() view public returns (uint) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n    \r\n    ///Updates the owner of the contract\r\n    function updateOwner(address newOwner) public onlyOwner {\r\n\r\n        owner = newOwner; \r\n    }\r\n    \r\n    //Used incase management teams lost their wallet and needs to updated.  \r\n    function updateManagement(address _mike, address _ghost, address _safe, address _dev) public onlyOwner {\r\n\r\n        mike = _mike;\r\n        ghost = _ghost;\r\n        safe = _safe;\r\n        dev = _dev;\r\n    }\r\n    \r\n    //Check who owner is. \r\n    function getOwner() view public returns (address) {\r\n        return owner; \r\n    }\r\n    \r\n    \r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a NotifyHelper smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Notify multiple reward pools about reward amounts, ensuring that the amount to be notified does not exceed the token balance in each pool.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function notifyPools(uint256[] memory amounts, address[] memory pools) public onlyGovernance: \n- Notifies all the pools, safe guarding the notification amount.\n"}, {"role": "assistant", "content": "contract NotifyHelper is Controllable {\r\n\r\n  constructor(address _storage)\r\n  Controllable(_storage) public {}\r\n\r\n  /**\r\n  * Notifies all the pools, safe guarding the notification amount.\r\n  */\r\n  function notifyPools(uint256[] memory amounts, address[] memory pools) public onlyGovernance {\r\n    require(amounts.length == pools.length, \"Amounts and pools lengths mismatch\");\r\n    for (uint i = 0; i < pools.length; i++) {\r\n      require(amounts[i] > 0, \"Notify zero\");\r\n      NoMintRewardPool pool = NoMintRewardPool(pools[i]);\r\n      IERC20 token = IERC20(pool.rewardToken());\r\n      uint256 limit = token.balanceOf(pools[i]);\r\n      require(amounts[i] <= limit, \"Notify limit hit\");\r\n      NoMintRewardPool(pools[i]).notifyRewardAmount(amounts[i]);\r\n    }\r\n  }\r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a MyFriendships smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: A contract for managing one's friendships.\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function MyFriendships() public:\n- Create a contract to keep track of my friendships.\n \n2. function becomeFriendsWithMe () public:\n- Start an exciting new friendship with me.\n \n3. function friendsWith (address addr) public view returns (bool):\n- Am I friends with this address?\n"}, {"role": "assistant", "content": "contract MyFriendships {\r\n    address public me;\r\n    uint public numberOfFriends;\r\n    address public latestFriend;\r\n    \r\n    mapping(address => bool) myFriends;\r\n\r\n    /**\r\n    * @dev Create a contract to keep track of my friendships.\r\n    */\r\n    function MyFriendships() public {\r\n        me = msg.sender;\r\n    }\r\n \r\n    /**\r\n    * @dev Start an exciting new friendship with me.\r\n    */\r\n    function becomeFriendsWithMe () public {\r\n        require(msg.sender != me); // I won't be friends with myself.\r\n        myFriends[msg.sender] = true;\r\n        latestFriend = msg.sender;\r\n        numberOfFriends++;\r\n    }\r\n    \r\n    /**\r\n    * @dev Am I friends with this address?\r\n    */\r\n    function friendsWith (address addr) public view returns (bool) {\r\n        return myFriends[addr];\r\n    }\r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a BasicToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Basic version of StandardToken, with no allowances. \n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function transfer(address _to, uint256 _value) returns (bool): \n- transfer token for a specified address\n- Parameter: _to is the address to transfer to.\n- Parameter: _value is the amount to be transferred.\n \n2. function balanceOf(address _owner) constant returns (uint256 balance) : \n- Gets the balance of the specified address.\n- Parameter: _owner is the address to query the the balance of. \n- Return: An uint256 representing the amount owned by the passed address.\n \n3. function transferFrom(address _from, address _to, uint256 _value) returns (bool) : \n- Transfer tokens from one address to another\n- Parameter: _from address is the address which you want to send tokens from\n- Parameter: _to address is the address which you want to transfer to\n- Parameter: _value uint256 the amout of tokens to be transfered\n \n4. function approve(address _spender, uint256 _value) returns (bool) : \n- Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n- Parameter: _spender is the address which will spend the funds.\n- Parameter: _value is the amount of tokens to be spent.\n \n5. function allowance(address _owner, address _spender) constant returns (uint256 remaining) : \n- Function to check the amount of tokens that an owner allowed to a spender.\n- Parameter: _owner address is the address which owns the funds.\n- Parameter: _spender address is the address which will spend the funds.\n- Return: A uint256 specifing the amount of tokens still available for the spender.\n \n6. function Ownable() : \n- The Ownable constructor sets the original `owner` of the contract to the sender account.\n \n7. function transferOwnership(address newOwner) onlyOwner : \n- Allows the current owner to transfer control of the contract to a newOwner.\n- Parameter: newOwner is the address to transfer ownership to.\n \n8. function burn(uint _value) public : \n- Burns a specific amount of tokens.\n- Parameter: _value is the amount of token to be burned.\n"}, {"role": "assistant", "content": "contract BasicToken is ERC20Basic {\r\n    \r\n  using SafeMath for uint256;\r\n \r\n  mapping(address => uint256) balances;\r\n \r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n \r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n \r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate an asktoken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function asktoken() public:\n- Constructor \n\n2. function totalSupply() public constant returns (uint):\n- Total supply \n\n3. function balanceOf(address tokenOwner) public constant returns (uint balance):\n- Get the token balance for account tokenOwner \n\n4. function transfer(address to, uint tokens) public returns (bool success):\n- Transfer the balance from token owner's account to to account. Owner's account must have sufficient balance to transfer. 0 value transfers are allowed.\n\n5. function approve(address spender, uint tokens) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. https:github.comethereumEIPsblobmasterEIPSeip20tokenstandard.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces  \n\n6. function transferFrom(address from, address to, uint tokens) public returns (bool success):\n- Transfer tokens from the \"from\" account to the \"to\" account. The calling account must already have sufficient tokens approve(...)d for spending from the \"from\" account and \"from\" account must have sufficient balance to transfer, spender must have sufficient allowance to transfer, and 0 value transfers are allowed \n\n7. function allowance(address tokenOwner, address spender) public constant returns (uint remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n\n8. function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. The spender contract function receiveApproval(...) is then executed \n\n9. function () public payable:\n- Don't accept ETH \n\n10. function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens \n"}, {"role": "assistant", "content": "contract asktoken is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function asktoken() public {\r\n        symbol = \"ask\";\r\n        name = \"asktoken\";\r\n        decimals = 18;\r\n        _totalSupply = 100000000000000000000000000;\r\n        balances[0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A] = _totalSupply;\r\n        Transfer(address(0), 0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Ownable smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n\n1. function owner() public view virtual returns (address): \n- Returns the address of the current owner.\n \n2. function renounceOwnership() public virtual onlyOwner: \n- Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\n \n3. function transferOwnership(address newOwner) public virtual onlyOwner: \n- Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\n \n\n"}, {"role": "assistant", "content": "contract asktoken is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function asktoken() public {\r\n        symbol = \"ask\";\r\n        name = \"asktoken\";\r\n        decimals = 18;\r\n        _totalSupply = 100000000000000000000000000;\r\n        balances[0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A] = _totalSupply;\r\n        Transfer(address(0), 0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ERC721Enumerable smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description:  This implements an optional extension of {ERC721} defined in the EIP that adds enumerability of all the token ids in the contract as well as all token ids owned by each account.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool): \n- See {IERC165supportsInterface}.\n \n2. function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256): \n- See {IERC721EnumerabletokenOfOwnerByIndex}.\n \n3. function totalSupply() public view virtual override returns (uint256): \n- See {IERC721EnumerabletotalSupply}.\n \n4. function tokenByIndex(uint256 index) public view virtual override returns (uint256): \n- See {IERC721EnumerabletokenByIndex}.\n \n5. function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override: \n- Hook that is called before any token transfer. This includes minting and burning. Calling conditions: When `from` and `to` are both nonzero, ``from``'s `tokenId` will be transferred to `to`. When `from` is zero, `tokenId` will be minted for `to`. When `to` is zero, ``from``'s `tokenId` will be burned. `from` cannot be the zero address. `to` cannot be the zero address. To learn more about hooks, head to xref:ROOT:extendingcontracts.adoc#usinghooks[Using Hooks].\n \n6. function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private: \n- Private function to add a token to this extension's ownershiptracking data structures.\n- Parameter:  to address representing the new owner of the given token ID\n- Parameter:  tokenId uint256 ID of the token to be added to the tokens list of the given address\n \n7. function _addTokenToAllTokensEnumeration(uint256 tokenId) private: \n- Private function to add a token to this extension's token tracking data structures.\n- Parameter:  tokenId uint256 ID of the token to be added to the tokens list\n \n8. function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private: \n- Private function to remove a token from this extension's ownershiptracking data structures. Note that while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for gas optimizations e.g. when performing a transfer operation (avoiding double writes). This has O(1) time complexity, but alters the order of the _ownedTokens array.\n- Parameter:  from address representing the previous owner of the given token ID\n- Parameter:  tokenId uint256 ID of the token to be removed from the tokens list of the given address\n \n9. function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private: \n- Private function to remove a token from this extension's token tracking data structures. This has O(1) time complexity, but alters the order of the _allTokens array.\n- Parameter:  tokenId uint256 ID of the token to be removed from the tokens list\n"}, {"role": "assistant", "content": "contract asktoken is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function asktoken() public {\r\n        symbol = \"ask\";\r\n        name = \"asktoken\";\r\n        decimals = 18;\r\n        _totalSupply = 100000000000000000000000000;\r\n        balances[0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A] = _totalSupply;\r\n        Transfer(address(0), 0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]}
{"messages": [{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a BLONDCOIN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function BLONDCOIN() public:\n- Constructor \n\n2. function totalSupply() public constant returns (uint):\n- Total supply \n\n3. function balanceOf(address tokenOwner) public constant returns (uint balance):\n- Get the token balance for account tokenOwner \n\n4. function transfer(address to, uint tokens) public returns (bool success):\n- Transfer the balance from token owner's account to to account  Owner's account must have sufficient balance to transfer  0 value transfers are allowed \n\n5. function approve(address spender, uint tokens) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. https:github.comethereumEIPsblobmasterEIPSeip20.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces  \n\n6. function transferFrom(address from, address to, uint tokens) public returns (bool success):\n- Transfer tokens from the 'from' account to the 'to' account  The calling account must already have sufficient tokens approve(...)d for spending from the 'from' account and 'from' account must have sufficient balance to transfer, spender must have sufficient allowance to transfer, and 0 value transfers are allowed.\n\n7. function allowance(address tokenOwner, address spender) public constant returns (uint remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n\n8. function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. The spender contract function receiveApproval(...) is then executed \n\n9. function () public payable:\n- Don't accept ETH \n\n10. function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens \n\n"}, {"role": "assistant", "content": "contract BLONDCOIN is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function BLONDCOIN() public {\r\n        symbol = \"BLO\";\r\n        name = \"BLONDCOIN\";\r\n        decimals = 18;\r\n        _totalSupply = 45000000000000000000000000;\r\n        balances[0xff72c65aa864774aa029114c0f15a44bfc6bc4e0] = _totalSupply;\r\n        Transfer(address(0), 0xff72c65aa864774aa029114c0f15a44bfc6bc4e0, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}, {"role": "user", "content": "\nGenerate a NFTCheese smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: ERC1155 token for NFT Cheese\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n\n1. function getPrice(uint256 amount) public  view returns (uint256): \n- retrieve price for multiple NFTs\n- Parameter:  amount the amount of NFTs to get price for\n \n2. function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256): \n- get price at position of the NFT token by ID\n- Parameter:  position positiong to check the price at\n \n3. function whitelistMint(uint256 amount) external payable whenNotPaused: \n- purchase NFTs during whitelist mint\n- Parameter:  amount the amount of cards to purchase\n \n4. function publicMint(uint256 amount) external payable whenNotPaused: \n- mint NFTs during public mint\n- Parameter:  amount the amount of tokens to mint\n \n5. function mint(uint256 amount) private: \n- global mint function used in early access and public sale\n- Parameter:  amount the amount of tokens to mint\n \n6. function editWindows(uint256 _publicWindowOpens, uint256 _whitelistWindowOpens) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit windows\n- Parameter:  _publicWindowOpens UNIX timestamp for purchasing public window time\n- Parameter:  _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\n \n7. function editMintSettings(uint256 _priceInc, uint256 _incrementNumber, uint256 _startingPrice) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit mint settings\n- Parameter:  _priceInc how much the price increments\n- Parameter:  _incrementNumber per how many tokens to increase price\n- Parameter:  _startingPrice starting price of the token\n \n8. function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE): \n- adds addresses into a whitelist\n- Parameter:  addresses an array of addresses to add to whitelist\n \n9. function isWhitelisted() external view returns (bool): \n- Return: true or false depending on whether it is whitelisted\n \n10 function uri(uint256 _id) public view override returns (string memory): \n- Return: the metadata uri for a given id\n- Parameter:  _id is the NFT id to return metadata for\n\n\n"}, {"role": "assistant", "content": "contract NFTCheese is AbstractERC1155Factory {\r\n\r\n    uint256 public constant ARTWORK = 0;\r\n    uint256 public _maxSupply = 333;\r\n    uint256 public _reserved = 33;\r\n\r\n    uint8 maxPerTx = 2;\r\n\r\n    uint256 public whitelistWindowOpens = 1644523200;\r\n    uint256 public publicWindowOpens    = 1644609600;\r\n\r\n    uint256 public priceInc = 100000000000000000;\r\n    uint256 public incrementNumber= 50;\r\n    uint256 public startingPrice = 50000000000000000;\r\n\r\n    mapping(address => bool) private whiteList; \r\n    mapping(address => uint256) public purchaseTxs;\r\n\r\n    constructor(\r\n        address[] memory _payees,\r\n        uint256[] memory _shares,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _uri\r\n        ) ERC1155(_uri) PaymentSplitter(_payees, _shares) {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(DEFAULT_ADMIN_ROLE, 0x5DeD00BE946085E7a523803596706593DbF9959b);\r\n        _mint(0x5DeD00BE946085E7a523803596706593DbF9959b, ARTWORK, 33, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice retrieve price for multiple NFTs\r\n    *\r\n    * @param amount the amount of NFTs to get price for\r\n    */\r\n    function getPrice(uint256 amount) public  view returns (uint256){\r\n        uint256 supply = totalSupply(ARTWORK) - _reserved;\r\n        uint totalCost = 0;\r\n        for (uint i = 0; i < amount; i++) {\r\n            totalCost += getCurrentPriceAtPosition(supply + i);\r\n        }\r\n        return totalCost;\r\n    }\r\n\r\n    /**\r\n    * @notice get price at position of the NFT token by ID\r\n    *\r\n    * @param position positiong to check the price at\r\n    */\r\n    function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256){\r\n        uint256 multiplier  = position/incrementNumber;\r\n        uint256 priceIncrease = multiplier * priceInc;\r\n        return priceIncrease + startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice purchase NFTs during whitelist mint\r\n    *\r\n    * @param amount the amount of cards to purchase\r\n    */\r\n    function whitelistMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= whitelistWindowOpens, \"Early access: window closed\");\r\n        require(whiteList[msg.sender], \"Sender not on the whitelist\");\r\n        require(purchaseTxs[msg.sender] + amount <= maxPerTx, \"Wallet mint limit\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice mint NFTs during public mint\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function publicMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= publicWindowOpens, \"Purchase: window closed\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice global mint function used in early access and public sale\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function mint(uint256 amount) private {\r\n        require(amount > 0, \"Need to request at least 1 NFT\");\r\n        require(totalSupply(ARTWORK) + amount <= _maxSupply, \"Exceeds maximum supply\");\r\n        require(msg.value >= getPrice(amount), \"Not enough ETH sent, check price\");\r\n\r\n        purchaseTxs[msg.sender] += amount;\r\n        _mint(msg.sender, ARTWORK, amount, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice edit windows\r\n    *\r\n    * @param _publicWindowOpens UNIX timestamp for purchasing public window time\r\n    * @param _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\r\n    */\r\n    function editWindows(\r\n        uint256 _publicWindowOpens,\r\n        uint256 _whitelistWindowOpens\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        require(\r\n            _publicWindowOpens > _whitelistWindowOpens,\r\n            \"window combination not allowed\"\r\n        );\r\n        publicWindowOpens = _publicWindowOpens;\r\n        whitelistWindowOpens = _whitelistWindowOpens;\r\n    }\r\n\r\n    /**\r\n    * @notice edit mint settings\r\n    *\r\n    * @param _priceInc how much the price increments\r\n    * @param _incrementNumber per how many tokens to increase price\r\n    * @param _startingPrice starting price of the token\r\n    */\r\n    function editMintSettings(\r\n        uint256 _priceInc,\r\n        uint256 _incrementNumber,\r\n        uint256 _startingPrice\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        priceInc = _priceInc;\r\n        incrementNumber = _incrementNumber;\r\n        startingPrice = _startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice adds addresses into a whitelist\r\n    *\r\n    * @param addresses an array of addresses to add to whitelist\r\n    */\r\n    function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            whiteList[addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice returns true or false depending on \r\n    */\r\n    function isWhitelisted() external view  returns (bool) {\r\n        return whiteList[msg.sender];\r\n    }\r\n\r\n    /**\r\n    * @notice returns the metadata uri for a given id\r\n    *\r\n    * @param _id the NFT id to return metadata for\r\n    */\r\n    function uri(uint256 _id) public view override returns (string memory) {\r\n        require(exists(_id), \"URI: nonexistent token\");\r\n\r\n        return string(abi.encodePacked(super.uri(_id), Strings.toString(_id), \".json\"));\r\n    }\r\n}"}]}