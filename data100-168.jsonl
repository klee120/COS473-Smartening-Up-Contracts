[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a BasicToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Basic version of StandardToken, with no allowances. \n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function transfer(address _to, uint256 _value) returns (bool): \n- transfer token for a specified address\n- Parameter: _to is the address to transfer to.\n- Parameter: _value is the amount to be transferred.\n \n2. function balanceOf(address _owner) constant returns (uint256 balance) : \n- Gets the balance of the specified address.\n- Parameter: _owner is the address to query the the balance of. \n- Return: An uint256 representing the amount owned by the passed address.\n \n3. function transferFrom(address _from, address _to, uint256 _value) returns (bool) : \n- Transfer tokens from one address to another\n- Parameter: _from address is the address which you want to send tokens from\n- Parameter: _to address is the address which you want to transfer to\n- Parameter: _value uint256 the amout of tokens to be transfered\n \n4. function approve(address _spender, uint256 _value) returns (bool) : \n- Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n- Parameter: _spender is the address which will spend the funds.\n- Parameter: _value is the amount of tokens to be spent.\n \n5. function allowance(address _owner, address _spender) constant returns (uint256 remaining) : \n- Function to check the amount of tokens that an owner allowed to a spender.\n- Parameter: _owner address is the address which owns the funds.\n- Parameter: _spender address is the address which will spend the funds.\n- Return: A uint256 specifing the amount of tokens still available for the spender.\n \n6. function Ownable() : \n- The Ownable constructor sets the original `owner` of the contract to the sender account.\n \n7. function transferOwnership(address newOwner) onlyOwner : \n- Allows the current owner to transfer control of the contract to a newOwner.\n- Parameter: newOwner is the address to transfer ownership to.\n \n8. function burn(uint _value) public : \n- Burns a specific amount of tokens.\n- Parameter: _value is the amount of token to be burned.\n"}, {"role": "assistant", "content": "contract BasicToken is ERC20Basic {\r\n    \r\n  using SafeMath for uint256;\r\n \r\n  mapping(address => uint256) balances;\r\n \r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n \r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n \r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate an asktoken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function asktoken() public:\n- Constructor \n\n2. function totalSupply() public constant returns (uint):\n- Total supply \n\n3. function balanceOf(address tokenOwner) public constant returns (uint balance):\n- Get the token balance for account tokenOwner \n\n4. function transfer(address to, uint tokens) public returns (bool success):\n- Transfer the balance from token owner's account to to account. Owner's account must have sufficient balance to transfer. 0 value transfers are allowed.\n\n5. function approve(address spender, uint tokens) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. https:github.comethereumEIPsblobmasterEIPSeip20tokenstandard.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces  \n\n6. function transferFrom(address from, address to, uint tokens) public returns (bool success):\n- Transfer tokens from the \"from\" account to the \"to\" account. The calling account must already have sufficient tokens approve(...)d for spending from the \"from\" account and \"from\" account must have sufficient balance to transfer, spender must have sufficient allowance to transfer, and 0 value transfers are allowed \n\n7. function allowance(address tokenOwner, address spender) public constant returns (uint remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n\n8. function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. The spender contract function receiveApproval(...) is then executed \n\n9. function () public payable:\n- Don't accept ETH \n\n10. function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens \n"}, {"role": "assistant", "content": "contract asktoken is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function asktoken() public {\r\n        symbol = \"ask\";\r\n        name = \"asktoken\";\r\n        decimals = 18;\r\n        _totalSupply = 100000000000000000000000000;\r\n        balances[0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A] = _totalSupply;\r\n        Transfer(address(0), 0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Ownable smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n\n1. function owner() public view virtual returns (address): \n- Returns the address of the current owner.\n \n2. function renounceOwnership() public virtual onlyOwner: \n- Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\n \n3. function transferOwnership(address newOwner) public virtual onlyOwner: \n- Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\n \n\n"}, {"role": "assistant", "content": "contract asktoken is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function asktoken() public {\r\n        symbol = \"ask\";\r\n        name = \"asktoken\";\r\n        decimals = 18;\r\n        _totalSupply = 100000000000000000000000000;\r\n        balances[0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A] = _totalSupply;\r\n        Transfer(address(0), 0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ERC721Enumerable smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description:  This implements an optional extension of {ERC721} defined in the EIP that adds enumerability of all the token ids in the contract as well as all token ids owned by each account.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool): \n- See {IERC165supportsInterface}.\n \n2. function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256): \n- See {IERC721EnumerabletokenOfOwnerByIndex}.\n \n3. function totalSupply() public view virtual override returns (uint256): \n- See {IERC721EnumerabletotalSupply}.\n \n4. function tokenByIndex(uint256 index) public view virtual override returns (uint256): \n- See {IERC721EnumerabletokenByIndex}.\n \n5. function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override: \n- Hook that is called before any token transfer. This includes minting and burning. Calling conditions: When `from` and `to` are both nonzero, ``from``'s `tokenId` will be transferred to `to`. When `from` is zero, `tokenId` will be minted for `to`. When `to` is zero, ``from``'s `tokenId` will be burned. `from` cannot be the zero address. `to` cannot be the zero address. To learn more about hooks, head to xref:ROOT:extendingcontracts.adoc#usinghooks[Using Hooks].\n \n6. function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private: \n- Private function to add a token to this extension's ownershiptracking data structures.\n- Parameter:  to address representing the new owner of the given token ID\n- Parameter:  tokenId uint256 ID of the token to be added to the tokens list of the given address\n \n7. function _addTokenToAllTokensEnumeration(uint256 tokenId) private: \n- Private function to add a token to this extension's token tracking data structures.\n- Parameter:  tokenId uint256 ID of the token to be added to the tokens list\n \n8. function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private: \n- Private function to remove a token from this extension's ownershiptracking data structures. Note that while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for gas optimizations e.g. when performing a transfer operation (avoiding double writes). This has O(1) time complexity, but alters the order of the _ownedTokens array.\n- Parameter:  from address representing the previous owner of the given token ID\n- Parameter:  tokenId uint256 ID of the token to be removed from the tokens list of the given address\n \n9. function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private: \n- Private function to remove a token from this extension's token tracking data structures. This has O(1) time complexity, but alters the order of the _allTokens array.\n- Parameter:  tokenId uint256 ID of the token to be removed from the tokens list\n"}, {"role": "assistant", "content": "contract asktoken is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function asktoken() public {\r\n        symbol = \"ask\";\r\n        name = \"asktoken\";\r\n        decimals = 18;\r\n        _totalSupply = 100000000000000000000000000;\r\n        balances[0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A] = _totalSupply;\r\n        Transfer(address(0), 0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a BLONDCOIN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function BLONDCOIN() public:\n- Constructor \n\n2. function totalSupply() public constant returns (uint):\n- Total supply \n\n3. function balanceOf(address tokenOwner) public constant returns (uint balance):\n- Get the token balance for account tokenOwner \n\n4. function transfer(address to, uint tokens) public returns (bool success):\n- Transfer the balance from token owner's account to to account  Owner's account must have sufficient balance to transfer  0 value transfers are allowed \n\n5. function approve(address spender, uint tokens) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. https:github.comethereumEIPsblobmasterEIPSeip20.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces  \n\n6. function transferFrom(address from, address to, uint tokens) public returns (bool success):\n- Transfer tokens from the 'from' account to the 'to' account  The calling account must already have sufficient tokens approve(...)d for spending from the 'from' account and 'from' account must have sufficient balance to transfer, spender must have sufficient allowance to transfer, and 0 value transfers are allowed.\n\n7. function allowance(address tokenOwner, address spender) public constant returns (uint remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n\n8. function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. The spender contract function receiveApproval(...) is then executed \n\n9. function () public payable:\n- Don't accept ETH \n\n10. function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens \n\n"}, {"role": "assistant", "content": "contract BLONDCOIN is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function BLONDCOIN() public {\r\n        symbol = \"BLO\";\r\n        name = \"BLONDCOIN\";\r\n        decimals = 18;\r\n        _totalSupply = 45000000000000000000000000;\r\n        balances[0xff72c65aa864774aa029114c0f15a44bfc6bc4e0] = _totalSupply;\r\n        Transfer(address(0), 0xff72c65aa864774aa029114c0f15a44bfc6bc4e0, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}, {"role": "user", "content": "\nGenerate a NFTCheese smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: ERC1155 token for NFT Cheese\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n\n1. function getPrice(uint256 amount) public  view returns (uint256): \n- retrieve price for multiple NFTs\n- Parameter:  amount the amount of NFTs to get price for\n \n2. function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256): \n- get price at position of the NFT token by ID\n- Parameter:  position positiong to check the price at\n \n3. function whitelistMint(uint256 amount) external payable whenNotPaused: \n- purchase NFTs during whitelist mint\n- Parameter:  amount the amount of cards to purchase\n \n4. function publicMint(uint256 amount) external payable whenNotPaused: \n- mint NFTs during public mint\n- Parameter:  amount the amount of tokens to mint\n \n5. function mint(uint256 amount) private: \n- global mint function used in early access and public sale\n- Parameter:  amount the amount of tokens to mint\n \n6. function editWindows(uint256 _publicWindowOpens, uint256 _whitelistWindowOpens) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit windows\n- Parameter:  _publicWindowOpens UNIX timestamp for purchasing public window time\n- Parameter:  _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\n \n7. function editMintSettings(uint256 _priceInc, uint256 _incrementNumber, uint256 _startingPrice) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit mint settings\n- Parameter:  _priceInc how much the price increments\n- Parameter:  _incrementNumber per how many tokens to increase price\n- Parameter:  _startingPrice starting price of the token\n \n8. function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE): \n- adds addresses into a whitelist\n- Parameter:  addresses an array of addresses to add to whitelist\n \n9. function isWhitelisted() external view returns (bool): \n- Return: true or false depending on whether it is whitelisted\n \n10 function uri(uint256 _id) public view override returns (string memory): \n- Return: the metadata uri for a given id\n- Parameter:  _id is the NFT id to return metadata for\n\n\n"}, {"role": "assistant", "content": "contract NFTCheese is AbstractERC1155Factory {\r\n\r\n    uint256 public constant ARTWORK = 0;\r\n    uint256 public _maxSupply = 333;\r\n    uint256 public _reserved = 33;\r\n\r\n    uint8 maxPerTx = 2;\r\n\r\n    uint256 public whitelistWindowOpens = 1644523200;\r\n    uint256 public publicWindowOpens    = 1644609600;\r\n\r\n    uint256 public priceInc = 100000000000000000;\r\n    uint256 public incrementNumber= 50;\r\n    uint256 public startingPrice = 50000000000000000;\r\n\r\n    mapping(address => bool) private whiteList; \r\n    mapping(address => uint256) public purchaseTxs;\r\n\r\n    constructor(\r\n        address[] memory _payees,\r\n        uint256[] memory _shares,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _uri\r\n        ) ERC1155(_uri) PaymentSplitter(_payees, _shares) {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(DEFAULT_ADMIN_ROLE, 0x5DeD00BE946085E7a523803596706593DbF9959b);\r\n        _mint(0x5DeD00BE946085E7a523803596706593DbF9959b, ARTWORK, 33, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice retrieve price for multiple NFTs\r\n    *\r\n    * @param amount the amount of NFTs to get price for\r\n    */\r\n    function getPrice(uint256 amount) public  view returns (uint256){\r\n        uint256 supply = totalSupply(ARTWORK) - _reserved;\r\n        uint totalCost = 0;\r\n        for (uint i = 0; i < amount; i++) {\r\n            totalCost += getCurrentPriceAtPosition(supply + i);\r\n        }\r\n        return totalCost;\r\n    }\r\n\r\n    /**\r\n    * @notice get price at position of the NFT token by ID\r\n    *\r\n    * @param position positiong to check the price at\r\n    */\r\n    function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256){\r\n        uint256 multiplier  = position/incrementNumber;\r\n        uint256 priceIncrease = multiplier * priceInc;\r\n        return priceIncrease + startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice purchase NFTs during whitelist mint\r\n    *\r\n    * @param amount the amount of cards to purchase\r\n    */\r\n    function whitelistMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= whitelistWindowOpens, \"Early access: window closed\");\r\n        require(whiteList[msg.sender], \"Sender not on the whitelist\");\r\n        require(purchaseTxs[msg.sender] + amount <= maxPerTx, \"Wallet mint limit\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice mint NFTs during public mint\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function publicMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= publicWindowOpens, \"Purchase: window closed\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice global mint function used in early access and public sale\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function mint(uint256 amount) private {\r\n        require(amount > 0, \"Need to request at least 1 NFT\");\r\n        require(totalSupply(ARTWORK) + amount <= _maxSupply, \"Exceeds maximum supply\");\r\n        require(msg.value >= getPrice(amount), \"Not enough ETH sent, check price\");\r\n\r\n        purchaseTxs[msg.sender] += amount;\r\n        _mint(msg.sender, ARTWORK, amount, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice edit windows\r\n    *\r\n    * @param _publicWindowOpens UNIX timestamp for purchasing public window time\r\n    * @param _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\r\n    */\r\n    function editWindows(\r\n        uint256 _publicWindowOpens,\r\n        uint256 _whitelistWindowOpens\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        require(\r\n            _publicWindowOpens > _whitelistWindowOpens,\r\n            \"window combination not allowed\"\r\n        );\r\n        publicWindowOpens = _publicWindowOpens;\r\n        whitelistWindowOpens = _whitelistWindowOpens;\r\n    }\r\n\r\n    /**\r\n    * @notice edit mint settings\r\n    *\r\n    * @param _priceInc how much the price increments\r\n    * @param _incrementNumber per how many tokens to increase price\r\n    * @param _startingPrice starting price of the token\r\n    */\r\n    function editMintSettings(\r\n        uint256 _priceInc,\r\n        uint256 _incrementNumber,\r\n        uint256 _startingPrice\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        priceInc = _priceInc;\r\n        incrementNumber = _incrementNumber;\r\n        startingPrice = _startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice adds addresses into a whitelist\r\n    *\r\n    * @param addresses an array of addresses to add to whitelist\r\n    */\r\n    function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            whiteList[addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice returns true or false depending on \r\n    */\r\n    function isWhitelisted() external view  returns (bool) {\r\n        return whiteList[msg.sender];\r\n    }\r\n\r\n    /**\r\n    * @notice returns the metadata uri for a given id\r\n    *\r\n    * @param _id the NFT id to return metadata for\r\n    */\r\n    function uri(uint256 _id) public view override returns (string memory) {\r\n        require(exists(_id), \"URI: nonexistent token\");\r\n\r\n        return string(abi.encodePacked(super.uri(_id), Strings.toString(_id), \".json\"));\r\n    }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a BLONDCOIN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function BLONDCOIN() public:\n- Constructor \n\n2. function totalSupply() public constant returns (uint):\n- Total supply \n\n3. function balanceOf(address tokenOwner) public constant returns (uint balance):\n- Get the token balance for account tokenOwner \n\n4. function transfer(address to, uint tokens) public returns (bool success):\n- Transfer the balance from token owner's account to to account  Owner's account must have sufficient balance to transfer  0 value transfers are allowed \n\n5. function approve(address spender, uint tokens) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. https:github.comethereumEIPsblobmasterEIPSeip20.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces  \n\n6. function transferFrom(address from, address to, uint tokens) public returns (bool success):\n- Transfer tokens from the 'from' account to the 'to' account  The calling account must already have sufficient tokens approve(...)d for spending from the 'from' account and 'from' account must have sufficient balance to transfer, spender must have sufficient allowance to transfer, and 0 value transfers are allowed.\n\n7. function allowance(address tokenOwner, address spender) public constant returns (uint remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n\n8. function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. The spender contract function receiveApproval(...) is then executed \n\n9. function () public payable:\n- Don't accept ETH \n\n10. function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens \n\n"}, {"role": "assistant", "content": "contract BLONDCOIN is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function BLONDCOIN() public {\r\n        symbol = \"BLO\";\r\n        name = \"BLONDCOIN\";\r\n        decimals = 18;\r\n        _totalSupply = 45000000000000000000000000;\r\n        balances[0xff72c65aa864774aa029114c0f15a44bfc6bc4e0] = _totalSupply;\r\n        Transfer(address(0), 0xff72c65aa864774aa029114c0f15a44bfc6bc4e0, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}, {"role": "user", "content": "\nGenerate a NFTCheese smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: ERC1155 token for NFT Cheese\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n\n1. function getPrice(uint256 amount) public  view returns (uint256): \n- retrieve price for multiple NFTs\n- Parameter:  amount the amount of NFTs to get price for\n \n2. function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256): \n- get price at position of the NFT token by ID\n- Parameter:  position positiong to check the price at\n \n3. function whitelistMint(uint256 amount) external payable whenNotPaused: \n- purchase NFTs during whitelist mint\n- Parameter:  amount the amount of cards to purchase\n \n4. function publicMint(uint256 amount) external payable whenNotPaused: \n- mint NFTs during public mint\n- Parameter:  amount the amount of tokens to mint\n \n5. function mint(uint256 amount) private: \n- global mint function used in early access and public sale\n- Parameter:  amount the amount of tokens to mint\n \n6. function editWindows(uint256 _publicWindowOpens, uint256 _whitelistWindowOpens) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit windows\n- Parameter:  _publicWindowOpens UNIX timestamp for purchasing public window time\n- Parameter:  _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\n \n7. function editMintSettings(uint256 _priceInc, uint256 _incrementNumber, uint256 _startingPrice) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit mint settings\n- Parameter:  _priceInc how much the price increments\n- Parameter:  _incrementNumber per how many tokens to increase price\n- Parameter:  _startingPrice starting price of the token\n \n8. function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE): \n- adds addresses into a whitelist\n- Parameter:  addresses an array of addresses to add to whitelist\n \n9. function isWhitelisted() external view returns (bool): \n- Return: true or false depending on whether it is whitelisted\n \n10 function uri(uint256 _id) public view override returns (string memory): \n- Return: the metadata uri for a given id\n- Parameter:  _id is the NFT id to return metadata for\n\n\n"}, {"role": "assistant", "content": "contract NFTCheese is AbstractERC1155Factory {\r\n\r\n    uint256 public constant ARTWORK = 0;\r\n    uint256 public _maxSupply = 333;\r\n    uint256 public _reserved = 33;\r\n\r\n    uint8 maxPerTx = 2;\r\n\r\n    uint256 public whitelistWindowOpens = 1644523200;\r\n    uint256 public publicWindowOpens    = 1644609600;\r\n\r\n    uint256 public priceInc = 100000000000000000;\r\n    uint256 public incrementNumber= 50;\r\n    uint256 public startingPrice = 50000000000000000;\r\n\r\n    mapping(address => bool) private whiteList; \r\n    mapping(address => uint256) public purchaseTxs;\r\n\r\n    constructor(\r\n        address[] memory _payees,\r\n        uint256[] memory _shares,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _uri\r\n        ) ERC1155(_uri) PaymentSplitter(_payees, _shares) {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(DEFAULT_ADMIN_ROLE, 0x5DeD00BE946085E7a523803596706593DbF9959b);\r\n        _mint(0x5DeD00BE946085E7a523803596706593DbF9959b, ARTWORK, 33, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice retrieve price for multiple NFTs\r\n    *\r\n    * @param amount the amount of NFTs to get price for\r\n    */\r\n    function getPrice(uint256 amount) public  view returns (uint256){\r\n        uint256 supply = totalSupply(ARTWORK) - _reserved;\r\n        uint totalCost = 0;\r\n        for (uint i = 0; i < amount; i++) {\r\n            totalCost += getCurrentPriceAtPosition(supply + i);\r\n        }\r\n        return totalCost;\r\n    }\r\n\r\n    /**\r\n    * @notice get price at position of the NFT token by ID\r\n    *\r\n    * @param position positiong to check the price at\r\n    */\r\n    function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256){\r\n        uint256 multiplier  = position/incrementNumber;\r\n        uint256 priceIncrease = multiplier * priceInc;\r\n        return priceIncrease + startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice purchase NFTs during whitelist mint\r\n    *\r\n    * @param amount the amount of cards to purchase\r\n    */\r\n    function whitelistMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= whitelistWindowOpens, \"Early access: window closed\");\r\n        require(whiteList[msg.sender], \"Sender not on the whitelist\");\r\n        require(purchaseTxs[msg.sender] + amount <= maxPerTx, \"Wallet mint limit\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice mint NFTs during public mint\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function publicMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= publicWindowOpens, \"Purchase: window closed\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice global mint function used in early access and public sale\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function mint(uint256 amount) private {\r\n        require(amount > 0, \"Need to request at least 1 NFT\");\r\n        require(totalSupply(ARTWORK) + amount <= _maxSupply, \"Exceeds maximum supply\");\r\n        require(msg.value >= getPrice(amount), \"Not enough ETH sent, check price\");\r\n\r\n        purchaseTxs[msg.sender] += amount;\r\n        _mint(msg.sender, ARTWORK, amount, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice edit windows\r\n    *\r\n    * @param _publicWindowOpens UNIX timestamp for purchasing public window time\r\n    * @param _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\r\n    */\r\n    function editWindows(\r\n        uint256 _publicWindowOpens,\r\n        uint256 _whitelistWindowOpens\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        require(\r\n            _publicWindowOpens > _whitelistWindowOpens,\r\n            \"window combination not allowed\"\r\n        );\r\n        publicWindowOpens = _publicWindowOpens;\r\n        whitelistWindowOpens = _whitelistWindowOpens;\r\n    }\r\n\r\n    /**\r\n    * @notice edit mint settings\r\n    *\r\n    * @param _priceInc how much the price increments\r\n    * @param _incrementNumber per how many tokens to increase price\r\n    * @param _startingPrice starting price of the token\r\n    */\r\n    function editMintSettings(\r\n        uint256 _priceInc,\r\n        uint256 _incrementNumber,\r\n        uint256 _startingPrice\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        priceInc = _priceInc;\r\n        incrementNumber = _incrementNumber;\r\n        startingPrice = _startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice adds addresses into a whitelist\r\n    *\r\n    * @param addresses an array of addresses to add to whitelist\r\n    */\r\n    function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            whiteList[addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice returns true or false depending on \r\n    */\r\n    function isWhitelisted() external view  returns (bool) {\r\n        return whiteList[msg.sender];\r\n    }\r\n\r\n    /**\r\n    * @notice returns the metadata uri for a given id\r\n    *\r\n    * @param _id the NFT id to return metadata for\r\n    */\r\n    function uri(uint256 _id) public view override returns (string memory) {\r\n        require(exists(_id), \"URI: nonexistent token\");\r\n\r\n        return string(abi.encodePacked(super.uri(_id), Strings.toString(_id), \".json\"));\r\n    }\r\n}"}]
