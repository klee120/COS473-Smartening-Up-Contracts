Generate a smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:
Task Description: 
  @dev Wrappers over Solidity's arithmetic operations with added overflow
  checks.
 
  Arithmetic operations in Solidity wrap on overflow. This can easily result
  in bugs, because programmers usually assume that an overflow raises an
  error, which is the standard behavior in high level programming languages.
  `SafeMath` restores this intuition by reverting the transaction when an
  operation overflows.
 
  Using this library instead of the unchecked operations eliminates an entire
  class of bugs, so it's recommended to use it always.
 

The contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).
Here are the key functions that you must fully implement so that they are functioning:
function add(uint256 a, uint256 b) internal pure returns (uint256) :    Returns the addition of two unsigned integers, reverting on  overflow.   Counterpart to Solidity's `+` operator.   Requirements:   Addition cannot overflow. 
function sub(uint256 a, uint256 b) internal pure returns (uint256) :    Returns the subtraction of two unsigned integers, reverting on  overflow (when the result is negative).   Counterpart to Solidity's `` operator.   Requirements:   Subtraction cannot overflow. 
function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) :    Returns the subtraction of two unsigned integers, reverting with custom message on  overflow (when the result is negative).   Counterpart to Solidity's `` operator.   Requirements:   Subtraction cannot overflow. 
function mul(uint256 a, uint256 b) internal pure returns (uint256) :    Returns the multiplication of two unsigned integers, reverting on  overflow.   Counterpart to Solidity's `` operator.   Requirements:   Multiplication cannot overflow. 
function div(uint256 a, uint256 b) internal pure returns (uint256) :    Returns the integer division of two unsigned integers. Reverts on  division by zero. The result is rounded towards zero.   Counterpart to Solidity's `` operator. Note: this function uses a  `revert` opcode (which leaves remaining gas untouched) while Solidity  uses an invalid opcode to revert (consuming all remaining gas).   Requirements:   The divisor cannot be zero. 
function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) :    Returns the integer division of two unsigned integers. Reverts with custom message on  division by zero. The result is rounded towards zero.   Counterpart to Solidity's `` operator. Note: this function uses a  `revert` opcode (which leaves remaining gas untouched) while Solidity  uses an invalid opcode to revert (consuming all remaining gas).   Requirements:   The divisor cannot be zero. 
function mod(uint256 a, uint256 b) internal pure returns (uint256) :    Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),  Reverts when dividing by zero.   Counterpart to Solidity's `%` operator. This function uses a `revert`  opcode (which leaves remaining gas untouched) while Solidity uses an  invalid opcode to revert (consuming all remaining gas).   Requirements:   The divisor cannot be zero. 
function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) :    Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),  Reverts with custom message when dividing by zero.   Counterpart to Solidity's `%` operator. This function uses a `revert`  opcode (which leaves remaining gas untouched) while Solidity uses an  invalid opcode to revert (consuming all remaining gas).   Requirements:   The divisor cannot be zero. 
function totalSupply() external view returns (uint256);
:    Returns the amount of tokens in existence. 
function balanceOf(address account) external view returns (uint256);
:    Returns the amount of tokens owned by `account`. 
function transfer(address recipient, uint256 amount) external returns (bool);
:    Moves `amount` tokens from the caller's account to `recipient`.   Returns a boolean value indicating whether the operation succeeded.   Emits a {Transfer} event. 
function allowance(address owner, address spender) external view returns (uint256);
:    Returns the remaining number of tokens that `spender` will be  allowed to spend on behalf of `owner` through {transferFrom}. This is  zero by default.   This value changes when {approve} or {transferFrom} are called. 
function approve(address spender, uint256 amount) external returns (bool);
:    Sets `amount` as the allowance of `spender` over the caller's tokens.   Returns a boolean value indicating whether the operation succeeded.   IMPORTANT: Beware that changing an allowance with this method brings the risk  that someone may use both the old and the new allowance by unfortunate  transaction ordering. One possible solution to mitigate this race  condition is to first reduce the spender's allowance to 0 and set the  desired value afterwards:  https:github.comethereumEIPsissues20#issuecomment263524729   Emits an {Approval} event. 
function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
:    Moves `amount` tokens from `sender` to `recipient` using the  allowance mechanism. `amount` is then deducted from the caller's  allowance.   Returns a boolean value indicating whether the operation succeeded.   Emits a {Transfer} event. 
function name() public view returns (string memory) :    Returns the name of the token. 
function symbol() public view returns (string memory) :    Returns the symbol of the token, usually a shorter version of the  name. 
function decimals() public view returns (uint8) :    Returns the number of decimals used to get its user representation.  For example, if `decimals` equals `2`, a balance of `505` tokens should  be displayed to a user as `5,05` (`505  10  2`).   Tokens usually opt for a value of 18, imitating the relationship between  Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is  called.   NOTE: This information is only used for _display_ purposes: it in  no way affects any of the arithmetic of the contract, including  {IERC20balanceOf} and {IERC20transfer}. 
function totalSupply() public view override returns (uint256) :    See {IERC20totalSupply}. 
function balanceOf(address account) public view override returns (uint256) :    See {IERC20balanceOf}. 
function transfer(address recipient, uint256 amount) public virtual override returns (bool) :    See {IERC20transfer}.   Requirements:    `recipient` cannot be the zero address.   the caller must have a balance of at least `amount`. 
function allowance(address owner, address spender) public view virtual override returns (uint256) :    See {IERC20allowance}. 
function approve(address spender, uint256 amount) public virtual override returns (bool) :    See {IERC20approve}.   Requirements:    `spender` cannot be the zero address. 
function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) :    See {IERC20transferFrom}.   Emits an {Approval} event indicating the updated allowance. This is not  required by the EIP. See the note at the beginning of {ERC20};   Requirements:   `sender` and `recipient` cannot be the zero address.   `sender` must have a balance of at least `amount`.   the caller must have allowance for ``sender``'s tokens of at least  `amount`. 
function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) :    Atomically increases the allowance granted to `spender` by the caller.   This is an alternative to {approve} that can be used as a mitigation for  problems described in {IERC20approve}.   Emits an {Approval} event indicating the updated allowance.   Requirements:    `spender` cannot be the zero address. 
function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) :    Atomically decreases the allowance granted to `spender` by the caller.   This is an alternative to {approve} that can be used as a mitigation for  problems described in {IERC20approve}.   Emits an {Approval} event indicating the updated allowance.   Requirements:    `spender` cannot be the zero address.   `spender` must have allowance for the caller of at least  `subtractedValue`. 
function _transfer(address sender, address recipient, uint256 amount) internal virtual :    Moves tokens `amount` from `sender` to `recipient`.   This is internal function is equivalent to {transfer}, and can be used to  e.g. implement automatic token fees, slashing mechanisms, etc.   Emits a {Transfer} event.   Requirements:    `sender` cannot be the zero address.   `recipient` cannot be the zero address.   `sender` must have a balance of at least `amount`. 
function setTreasury ( address treasuryAddress_) public onlyMinter :   Used by the migration contract  
function mint(address account, uint256 amount) public virtual onlyMinter :   Used by the migration contract  
function _mint(address account, uint256 amount) internal virtual :   Creates `amount` tokens and assigns them to `account`, increasing  the total supply.   Emits a {Transfer} event with `from` set to the zero address.   Requirements    `to` cannot be the zero address. 
function _approve(address owner, address spender, uint256 amount) internal virtual :    Sets `amount` as the allowance of `spender` over the `owner`s tokens.   This is internal function is equivalent to `approve`, and can be used to  e.g. set automatic allowances for certain subsystems, etc.   Emits an {Approval} event.   Requirements:    `owner` cannot be the zero address.   `spender` cannot be the zero address. 
function _setupDecimals(uint8 decimals_) internal :    Sets {decimals} to a value other than the default one of 18.   WARNING: This function should only be called from the constructor. Most  applications that interact with token contracts will not expect  {decimals} to ever change, and may work incorrectly if it does. 
