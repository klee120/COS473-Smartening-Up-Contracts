{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Molokiwie smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create an Ethereum-based NFT minting smart contract named Molokiwie that adheres to the ERC721Enumerable and Ownable standards. This contract allows the owner to mint unique digital assets, manage minting costs, toggle the minting process on or off, and set metadata URIs for individual tokens and the contract itself. Additionally, the contract should enable the withdrawal of funds accumulated through minting operations.\n\nContract Specifications:\n- Inherits ERC721Enumerable for NFT enumeration and Ownable for ownership management.\n- Implements features such as minting control, dynamic pricing, and metadata management.\n- Utilizes Ethereum's native currency (ETH) for transactions.\n\nKey Functionalities:\n1. Minting Control: Allows the contract owner to enable or disable the NFT minting function to control the supply.\n2. Dynamic Pricing: The owner can adjust the cost per NFT minted to respond to market demands or strategic pricing adjustments.\n3. Metadata Management: Enables setting and updating the base URI for token metadata and the contract's metadata, facilitating dynamic content management.\n4. Funds Withdrawal: Allows the contract owner to withdraw the balance accumulated from minting fees, ensuring secure and exclusive access to the funds.\n\nImplementation Details:\n- Minting Process: The mint function enables users to mint a specified number of NFTs given they meet the prerequisites, such as minting being enabled, the minimum quantity requirement, and sufficient ETH to cover the cost.\n- Access Control: Utilizes the onlyOwner modifier from the Ownable contract to restrict certain functions, like pausing minting, setting costs, and withdrawing funds, to the contract owner.\n- Metadata URIs: The contract stores separate URIs for token metadata and contract metadata, which can be updated by the owner, providing flexibility in managing how NFTs and the contract are presented externally.\n- Error Handling: Implements checks and requires statements to validate function calls, ensuring operations like minting and withdrawing funds are executed under defined conditions.\n\nSecurity Considerations:\n- Reentrancy Guard: Consider implementing reentrancy guards for functions that transfer ETH to prevent reentrancy attacks.\n- Validation Checks: Ensure all user inputs and state-changing operations are correctly validated (e.g., mint amount, ETH sent for minting) to prevent exploits.\n- Access Control: The onlyOwner modifier is crucial for functions that could impact the contract's integrity and financial state. It's essential to ensure the ownership is securely managed.\n"}, {"role": "assistant", "content": "contract Molokiwie is ERC721Enumerable, Ownable { \n    uint256 public cost;\n    bool public paused;\n    string public tokenURIPrefix;\n    string public contractURIPrefix;\n\n    constructor() ERC721(\"MOLOKIWIE\", \"MOLOKIWIE\") {\n        pause(false);\n        setCost(20000000 gwei); //0.02 eth\n        setTokenURI(\"https://gateway.pinata.cloud/ipfs/QmPhtzrqnJ6ozr98JbVxWvac4anj6ViQeaCwTHBuAYmQU3\");\n        setContractURI(\"https://gateway.pinata.cloud/ipfs/QmR6cvG9F35yRKRn8QPfRX8cGhm3Ez27E3Z7uEu1jdTBVt\");\n    }\n\n    function mint(uint256 _mintAmount) public payable {\n        require(canMint(_mintAmount, msg.value), \"Can't mint\");\n        uint256 supply = totalSupply();\n        for (uint i; i < _mintAmount; ++i ) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    function setCost(uint256 _newCost) public onlyOwner {\n        cost = _newCost;\n    }\n\n    function canMint(uint256 _mintAmount, uint256 ethValue) public view returns (bool) {\n        require(!paused, \"Minting is paused\");\n        require(_mintAmount > 0, \"Need to mint at least 1 NFT\");\n        require(ethValue >= cost * _mintAmount, \"Insufficient funds\");\n        \n        return true;\n    }\n\n    function setTokenURI(string memory _tokenURIPrefix) public onlyOwner {\n        tokenURIPrefix = _tokenURIPrefix;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n        return tokenURIPrefix;\n    }\n\n    function setContractURI(string memory _contractURIPrefix) public onlyOwner {\n        contractURIPrefix = _contractURIPrefix;\n    }\n\n    function contractURI() public view returns (string memory) {\n        return contractURIPrefix;\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(os, \"Can't withdraw\");\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a TWOToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract named TWOToken implementing the ERC20Interface, along with an ownership management system through OwnerHelper. The contract introduces a custom token with features like token locking/unlocking for addresses, transfer restrictions, and mechanisms for the initial distribution of tokens to a founder. Additionally, it provides functions for token locking management and the ability to permanently destroy the contract.\n\nContract Specifications:\n- Implements ERC20 standard functionalities for token management.\n- Incorporates OwnerHelper for ownership-related actions.\n- Utilizes SafeMath for secure mathematical operations.\n- Features include token lock management, address whitelisting, and ERC20 standard operations.\n\nKey Functionalities:\n1. Token Information: The contract stores token-related data such as name, decimals, and symbol, defining the token's basic characteristics.\n2. Ownership and Token Supply: Establishes a founder address receiving the initial total token supply and integrates ownership management for critical administrative functions.\n3. Locking Mechanism: Introduces a system to lock or unlock the token transfer capabilities for specific addresses, enhancing security and compliance.\n4. ERC20 Compliance: Implements standard ERC20 functions for token transfers, balance inquiries, allowances, and approval mechanisms, ensuring interoperability with the broader Ethereum ecosystem.\n\nImplementation Details\n- Initial Setup: During contract creation, initial token attributes are set, and the total supply is allocated to the founder's address.\n- Transfer Restrictions: Incorporates a notLocked modifier to check if tokens are transferable by the sender, applying various conditions including owner privileges and address-specific locking status.\n- Lock Management: Offers functions for the contract owner to lock or unlock addresses, enabling or disabling their ability to transfer tokens.\n- ERC20 Functions: Detailed implementation of transfer, approve, allowance, and transferFrom methods adhering to the ERC20 standard, with added checks for the locking status.\n- Destruction Capability: Allows the contract owner to permanently destroy the contract, sending all remaining funds to the owner's address.\n\nSecurity Considerations\n- SafeMath: Utilizes SafeMath library to prevent overflow and underflow vulnerabilities in arithmetic operations.\n- Ownership Controls: Critical actions like locking tokens, updating lock status, and contract destruction are guarded with onlyOwner checks to prevent unauthorized access.\n- Locking Mechanism: The token lock feature should be carefully managed to ensure it does not inadvertently hinder the token's liquidity and transferability among rightful holders.\n"}, {"role": "assistant", "content": "contract TWOToken is ERC20Interface, OwnerHelper {\n    using SafeMath for uint;\n    \n    string public name;\n    uint public decimals;\n    string public symbol;\n\n    // Founder\n    address private founder;\n    \n    // Total\n    uint public totalTokenSupply;\n\n    mapping (address => uint) public balances;\n    mapping (address => mapping ( address => uint )) public approvals;\n    mapping (address => bool) private whiteAddresses; // Lock : false, unLock : true\n    \n    bool public tokenLock = false;\n\n    // Token Total\n    uint constant private E18 = 1000000000000000000;\n\n    constructor(address _founder, uint _totalTokenSupply) public {\n        name = \"two#\";\n        decimals = 18;\n        symbol = \"TO1\";\n\n        founder = _founder;\n        totalTokenSupply  = _totalTokenSupply * E18;\n        balances[founder] = totalTokenSupply;\n        emit Transfer(0x0, founder, totalTokenSupply);\n    }\n\n    modifier notLocked {\n        require(isTransferable() == true);\n        _;\n    }\n\n    function lock(address who) onlyOwner public {\n        whiteAddresses[who] = false;\n    }\n    \n    function unlock(address who) onlyOwner public {\n        whiteAddresses[who] = true;\n    }\n    \n    function isLocked(address who) public view returns(bool) {\n        return whiteAddresses[who];\n    }\n\n    function totalSupply() view public returns (uint) {\n        return totalTokenSupply;\n    }\n    \n    function balanceOf(address _who) view public returns (uint) {\n        return balances[_who];\n    }\n    \n    function transfer(address _to, uint _value) notLocked public returns (bool) {\n        require(balances[msg.sender] >= _value);\n        \n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        \n        emit Transfer(msg.sender, _to, _value);\n        \n        return true;\n    }\n    \n    function approve(address _spender, uint _value) notLocked public returns (bool){\n        require(balances[msg.sender] >= _value);\n        \n        approvals[msg.sender][_spender] = _value;\n        \n        emit Approval(msg.sender, _spender, _value);\n        \n        return true; \n    }\n    \n    function allowance(address _owner, address _spender) view public returns (uint) {\n        return approvals[_owner][_spender];\n    }\n\n    function transferFrom(address _from, address _to, uint _value) notLocked public returns (bool) {\n        require(balances[_from] >= _value);\n        require(approvals[_from][msg.sender] >= _value);\n        \n        approvals[_from][msg.sender] = approvals[_from][msg.sender].sub(_value);\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to]  = balances[_to].add(_value);\n        \n        emit Transfer(_from, _to, _value);\n        \n        return true;\n    }\n        \n    function isTransferable() private view returns (bool) {\n        if (tokenLock == false) {\n            return true;\n        }\n        else {\n          if(msg.sender == owner) {\n            return true;\n          }\n\n          if (whiteAddresses[msg.sender]) // true is unLocked {\n              return true;\n          }\n        }\n        return false;\n    }\n    \n    function setTokenUnlock() onlyOwner public {\n        require(tokenLock == true);\n        \n        tokenLock = false;\n    }\n    \n    function setTokenLock() onlyOwner public {\n        require(tokenLock == false);\n        \n        tokenLock = true;\n    }\n    \n    function close() onlyOwner public {\n        selfdestruct(msg.sender);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a XappCoin smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop an Ethereum smart contract named XappCoin that implements the ERC20 standard and includes ownership management. The contract introduces a cryptocurrency called XappCoin (XAPP) with a fixed supply, mechanisms for distributing tokens through ICOs, airdrops, and developer allocations. It also features dynamic token pricing throughout various ICO phases, the ability to withdraw collected funds, and functions for distributing tokens to specific addresses.\n\nContract Specifications:\n- Inherits ERC20 for token functionality and Owned for ownership management.\n- Uses SafeMath for safe mathematical operations to prevent overflow.\n- Defines constants for token name (XappCoin), symbol (XAPP), and decimals (18).\n- Sets a fixed total supply of tokens and allocates percentages for ICO, airdrops, and developer incentives.\n- Implements ERC20 functions with additional checks and custom distribution logic.\n\nKey Functionalities:\n1. Fixed Supply & Allocation: Sets a fixed total supply with predefined allocations for ICO sales, airdrops, and developer incentives.\n2. ICO and Token Sale Mechanics: Details the distribution of tokens through various sale phases (presale, ICO1, ICO2, etc.) with specific start times and ETH-to-token conversion rates.\n3. Airdrop and Developer Distribution: Specialized functions to distribute tokens for airdrops and to developer addresses, controlling the flow and allocation of tokens.\n4. Token Pricing and Adjustments: Mechanisms to update the tokens-per-ETH rate dynamically based on the phase of the ICO.\n5. Withdrawal and Burn Functions: Allows the withdrawal of ETH collected during the sale and the burning of tokens to reduce the supply.\n\nImplementation Details:\n- Initial Setup: Upon deployment, the contract allocates the total supply among the ICO, airdrop, and developer addresses based on predefined percentages.\n- Distribution Flags and Times: Utilizes flags to mark the opening and closing of the ICO, alongside timestamps to manage different sale phases.\n- Dynamic Token Pricing: Adjusts token pricing for each phase of the ICO, allowing for flexible investment opportunities.\n- Custom Distribution Functions: Includes methods for distributing tokens to private sale participants, airdrop recipients, and developers, ensuring each group receives their allotted share.\n- Security Measures: Implements checks for transaction amounts, sale phases, and ensures functions can only be called by the owner or authorized addresses.\n\nSecurity Considerations:\n- SafeMath Usage: Ensures arithmetic operations are secure and free from overflows and underflows.\n- Ownership and Access Control: Critical functions are protected by ownership checks to prevent unauthorized access.\n- Validation of Contributions: Checks for minimum contributions and valid phases ensure that transactions are processed correctly.\n- Mitigation of Common Vulnerabilities: Includes protections against reentrancy, short address attacks, and ensures proper handling of ERC20 tokens.\n"}, {"role": "assistant", "content": "contract XappCoin is ERC20, Owned {\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\t\t\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;    \n\n    string public constant name = \"XappCoin\";\n    string public constant symbol = \"XAPP\";\n    uint public constant decimals = 18;\n    \n    uint256 public totalSupply =  160000000000000000000000000;\n    uint256 public totalDistributed = 0; \n    uint256 public totalIcoDistributed = 0;\n    uint256 public constant minContribution = 1 ether / 100; // 0.01 Eth\n\t\n\t\n\tuint256 public tokensPerEth = 0;\n\t\n    // Token Distribution and Address\n    \n    // saleable 90%\n    uint256 public constant totalIco = 144000000000000000000000000;\n    uint256 public totalIcoDist = 0;\n    address storageIco = owner;\n\n    // airdrop 5%\n    uint256 public constant totalAirdrop = 8000000000000000000000000;\n    address private storageAirdrop = 0x9EF2b3c9D297342Cad1EEae796D1BE3e804A30F9;\n\n    // developer 5%\n    uint256 public constant totalDeveloper = 8000000000000000000000000;\n    address private storageDeveloper = 0x4E9084cB8B30CAD65f1210Ec7CCcED1F1a5F2D78;\n    \n    // sale start  price and bonus\n    \n    // presale\n\tuint public presaleStartTime = 1544979600; // Monday, 20 January 2020 00:00:00 GMT+07:00\n    uint256 public presalePerEth = 1000000000000000000000;\n    \n    // ico\n    uint public icoStartTime = 1546189200; // Thursday, 5 March 2020 00:00:00 GMT+07:00\n    uint256 public icoPerEth = 1000000000000000000000;\n    \n    // ico1\n    uint public ico1StartTime = 1547398800; // Sunday, 19 April 2020 00:00:00 GMT+07:00\n    uint256 public ico1PerEth = 1000000000000000000000;\n    \n    \n    // ico2\n    uint public ico2StartTime = 1548608400; // Wednesday, 3 June 2020 00:00:00 GMT+07:00\n    uint256 public ico2PerEth = 1000000000000000000000;\n    \n    \n    //ico start and end\n    uint public icoOpenTime = presaleStartTime;\n    uint public icoEndTime = 1610298000; // Thursday, 9 July 2019 00:00:00 GMT+07:00\n\t\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n    \n    event Burn(address indexed burner, uint256 value);\n\t\n\tevent Sent(address from, address to, uint amount);\n\t\n    bool public icoOpen = false; \n    bool public icoFinished = false;\n    bool public distributionFinished = false;\n\n    uint256 public tTokenPerEth = 0;\n    uint256 public tAmount = 0;\n    uint i = 0;\n    bool private tIcoOpen = false;\n    \n    constructor() public {        \n        balances[owner] = totalIco;\n        balances[storageAirdrop] = totalAirdrop;\n        balances[storageDeveloper] = totalDeveloper;       \n    }\n    \n    function totalSupply() public constant returns (uint) {\n        return totalSupply  - balances[address(0)];\n    }\n\n    modifier canDistr() {\n        require(!distributionFinished);\n        _;\n    }\n\t\n\tfunction startDistribution() onlyOwner canDistr public returns (bool) {\n        icoOpen = true;\n        presaleStartTime = now;\n        icoOpenTime = now;\n        return true;\n    }\n    \n    function finishDistribution() onlyOwner canDistr public returns (bool) {\n        distributionFinished = true;\n        icoFinished = true;\n        emit DistrFinished();\n        return true;\n    }\n    \n    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n        totalDistributed = totalDistributed.add(_amount);        \n        balances[_to] = balances[_to].add(_amount);\n        balances[owner] = balances[owner].sub(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n\n        return true;\n    }\n\t\n\tfunction send(address receiver, uint amount) public {\n        if (balances[msg.sender] < amount) return;\n        balances[msg.sender] -= amount;\n        balances[receiver] += amount;\n        emit Sent(msg.sender, receiver, amount);\n    }\n    \n   \n    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        \n        tokensPerEth = _tokensPerEth;\n        emit TokensPerEthUpdated(_tokensPerEth);\n    }\n           \n    function () external payable {\n\t\t\t\t\n\t\t// owner withdraw \n\t\tif (msg.sender == owner && msg.value == 0) {\n\t\t\twithdraw();\n\t\t}\n\t\t\n\t\tif (msg.sender != owner){\n\t\t\tif ( now < icoOpenTime ){\n\t\t\t\trevert('ICO does not open yet');\n\t\t\t}\n\t\t\t\n\t\t\t//is Open\n\t\t\tif (( now >= icoOpenTime ) && ( now <= icoEndTime )) {\n\t\t\t\ticoOpen = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (now > icoEndTime) {\n\t\t\t\ticoOpen = false;\n\t\t\t\ticoFinished = true;\n\t\t\t\tdistributionFinished = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (icoFinished == true) {\n\t\t\t\trevert('ICO has finished');\n\t\t\t}\n\t\t\t\n\t\t\tif (distributionFinished == true) {\n\t\t\t\trevert('Token distribution has finished');\n\t\t\t}\n\t\t\t\n\t\t\tif (icoOpen == true ) {\n\t\t\t\tif (now >= presaleStartTime && now < icoStartTime){ tTokenPerEth = presalePerEth; }\n\t\t\t\tif (now >= icoStartTime && now < ico1StartTime){ tTokenPerEth = icoPerEth; }\n\t\t\t\tif (now >= ico1StartTime && now < ico2StartTime){ tTokenPerEth = ico1PerEth; }\n\t\t\t\tif (now >= ico2StartTime && now < icoEndTime){ tTokenPerEth = ico2PerEth; }\n\t\t\t\t\n\t\t\t\ttokensPerEth = tTokenPerEth;\t\t\t\t\n\t\t\t\tgetTokens();\n\t\t\t}\n\t\t}\n     }\n    \n    function getTokens() payable canDistr  public {\n        uint256 tokens = 0;\n\n        require( msg.value >= minContribution );\n        require( msg.value > 0 );\n        \n        tokens = tokensPerEth.mul(msg.value) / 1 ether;\n        address investor = msg.sender;\n        \n        if (icoFinished == true) {\n\t\t\trevert('ICO Has Finished');\n\t\t}\n        \n        if (balances[owner] < tokens){\n\t\t\trevert('Insufficient Token Balance or Sold Out.');\n\t\t}\n        \n        if (tokens < 0) {\n\t\t\trevert();\n\t\t}\n        \n        totalIcoDistributed += tokens;\n        \n        if (tokens > 0) {\n           distr(investor, tokens);           \n        }\n\n        if (totalIcoDistributed >= totalIco) {\n            distributionFinished = true;\n        }\n    }\n\t\n\t\n    function balanceOf(address _owner) constant public returns (uint256) {\n        return balances[_owner];\n    }\n\n    // mitigates the ERC20 short address attack\n    modifier onlyPayloadSize(uint size) {\n        assert(msg.data.length >= size + 4);\n        _;\n    }\n    \n    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n        \n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n\n        require(_to != address(0));\n        require(_amount <= balances[_from]);\n        require(_amount <= allowed[_from][msg.sender]);\n        \n        balances[_from] = balances[_from].sub(_amount);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    \n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        // mitigates the ERC20 spend/approval race condition\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n    \n    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n        AltcoinToken t = AltcoinToken(tokenAddress);\n        uint bal = t.balanceOf(who);\n        return bal;\n    }\n    \n    function withdraw() onlyOwner public {\n        address myAddress = this;\n        uint256 etherBalance = myAddress.balance;\n        owner.transfer(etherBalance);\n    }\n    \n    function burn(uint256 _amount) onlyOwner public {\n        balances[owner] = balances[owner].sub(_amount);\n        totalSupply = totalSupply.sub(_amount);\n        totalDistributed = totalDistributed.sub(_amount);\n        emit Burn(owner, _amount);\n    }\n    \n    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {\n        AltcoinToken token = AltcoinToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n    \n    function dist_privateSale(address _to, uint256 _amount) onlyOwner public {\n\t\t\n\t\trequire(_amount <= balances[owner]);\n\t\trequire(_amount > 0);\n\t\t\n\t\ttotalDistributed = totalDistributed.add(_amount);        \n        balances[_to] = balances[_to].add(_amount);\n        balances[owner] = balances[owner].sub(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        tAmount = 0;\n\t}\n\t\n\tfunction dist_airdrop(address _to, uint256 _amount) onlyOwner public {\t\t\n\t\trequire(_amount <= balances[storageAirdrop]);\n\t\trequire(_amount > 0);\n        balances[_to] = balances[_to].add(_amount);\n        balances[storageAirdrop] = balances[storageAirdrop].sub(_amount);\n        emit Airdrop(_to, _amount, balances[_to]);\n        emit Transfer(address(0), _to, _amount);\n\t}\n\t\n\tfunction dist_multiple_airdrop(address[] _participants, uint256 _amount) onlyOwner public {\n\t\ttAmount = 0;\n\t\t\n\t\tfor ( i = 0; i < _participants.length; i++){\n\t\t\ttAmount = tAmount.add(_amount);\n\t\t}\n\t\t\n\t\trequire(tAmount <= balances[storageAirdrop]);\n\t\t\n\t\tfor ( i = 0; i < _participants.length; i++){\n\t\t\tdist_airdrop(_participants[i], _amount);\n\t\t}\n\t\t\n\t\ttAmount = 0;\n\t}    \n    \n    function dist_developer(address _to, uint256 _amount) onlyOwner public {\n\t\trequire(_amount <= balances[storageDeveloper]);\n\t\trequire(_amount > 0);\n\t\tbalances[_to] = balances[_to].add(_amount);\n        balances[storageDeveloper] = balances[storageDeveloper].sub(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        tAmount = 0;\n\t}\n\t\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a FricaCoin smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract named FricaCoin, an ERC20 token with additional features supporting Pre-ICO, ICO phases, advisor allocations, and a mechanism to pause and resume the ICO. The contract includes a fixed total supply of tokens, distribution among various stakeholders (including a public sale, advisors, and charity), and stages to manage the lifecycle of the ICO.\n\nContract Specifications:\n- Inherits the ERC20 standard for token functionality.\n- Utilizes SafeMath for safe arithmetic operations.\n- Defines constants such as name (FricaCoin), symbol (FRI), and decimals (8).\n- Sets a fixed total supply and initial allocations for the owner, employees, advisors, charity, and ICO rounds.\n- Implements a stage-based system to manage the ICO process.\n\nKey Functionalities:\n1. Initial Token Allocation: Distributes the initial supply among the owner, advisors, charity, and reserves for ICO and Pre-ICO sales.\n2. ICO Stage Management: Controls the ICO process through stages, including not started, pre-ICO, ICO, paused, and ended.\n3. Advisor Allocation: Manages the distribution of tokens to advisors, including adding new advisors and transferring tokens.\n4. ICO Participation: Allows investors to participate in the ICO by sending ETH in exchange for FricaCoin tokens during the active sale phase.\n5. Pause and Resume ICO: Provides the owner with the ability to pause and resume the ICO to address any unforeseen issues.\n\nImplementation Details:\n- Stage Modifiers: Uses stage-specific modifiers to ensure functions are executed only at the appropriate times in the ICO lifecycle.\n- Ownership Checks: Includes ownership verification to secure sensitive functions like starting the ICO, pausing, and distributing tokens.\n- Token Distribution: Details functions for transferring tokens from the contract to participants, including public sale buyers and advisors.\n- ICO Timing and Caps: Sets specific start and end dates for the Pre-ICO and ICO phases, along with a maximum cap for public sale contributions.\n- Advisors Management: Facilitates the addition of advisors and tracks the distribution of tokens to these key stakeholders.\n\nSecurity Considerations:\n- SafeMath for Arithmetic: Ensures all arithmetic operations are safe from overflows and underflows, protecting the token's integrity.\n- Contract Ownership: Critical actions are restricted to the contract owner, preventing unauthorized access and modifications.\n- Stage Restrictions: Functions are gated by the current ICO stage, reducing the risk of inappropriate token minting or distribution.\n- Advisors Whitelisting: Advisors are managed through a mapping, with functions to add and verify their status, mitigating the risk of unauthorized token allocation.\n"}, {"role": "assistant", "content": "contract FricaCoin is ERC20 { \n    using SafeMath for uint256;\n    string public constant name = \"FricaCoin\";\n\n    string public constant symbol = \"FRI\";\n    uint8 public constant decimals = 8;\n    uint public _totalsupply = 1000000000000 * 10 ** 8; // 1 trillion total supply // muliplies dues to decimal precision\n    address public owner; \n    uint256 no_of_tokens;\n    uint256 bonus_token;\n    uint256 total_token;\n    bool stopped = false;\n    uint256 public pre_startdate;\n    uint256 public ico1_startdate;\n    uint256 ico_first;\n    uint256 ico_second;\n    uint256 ico_third;\n    uint256 ico_fourth;\n    uint256 pre_enddate;\n  \n    uint256 public eth_received; // total ether received in the contract\n    uint256 maxCap_public = 250000000000 * 10 **8;  //  25% - 250 billion in Public Sale\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    mapping (address => bool) private Advisors;\n    \n    uint256 public advisorCount;\n\n    enum Stages {\n        NOTSTARTED,\n        PREICO,\n        ICO,\n        PAUSED,\n        ENDED\n    }\n    Stages public stage;\n    \n    modifier atStage(Stages _stage) {\n        if (stage != _stage)\n            // Contract not in expected state\n            revert();\n        _;\n    }\n    \n     modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    function FricaCoin() public {\n        owner = msg.sender;\n        balances[owner] = 50000000000 * 10 **8; // 5% - 50 billion to owner\n        stage = Stages.NOTSTARTED;\n        Transfer(0, owner, balances[owner]);\n        \n        uint256 _transfertoemployees = 140000000000 * 10 **8; // 14% - 140 billion to Employees Advisors Consultants & Partners\n        balances[0xa36eEa22131881BB0a8902A6b8bF4a2cbb9782BC] = _transfertoemployees;\n        Transfer(address(0), 0xa36eEa22131881BB0a8902A6b8bF4a2cbb9782BC, _transfertoemployees);\n        \n        uint256 _transfertofirstround = 260000000000 * 10 **8; // 26% - 260 billion to First Round & Bonus\n        balances[0x553015bc932FaCc0C60159b7503a58ef5806CA48] = _transfertofirstround;\n        Transfer(address(0), 0x553015bc932FaCc0C60159b7503a58ef5806CA48, _transfertofirstround);\n        \n        uint256 _transfertocharity = 50000000000 * 10 **8; // 5% - 50 billion to Charity and non-profit\n        balances[0x11Bfb0B5a901cbc5015EF924c39ac33e91Eb015a] = _transfertocharity;\n        Transfer(address(0), 0x11Bfb0B5a901cbc5015EF924c39ac33e91Eb015a, _transfertocharity);\n\n        uint256 _transfertosecondround = 250000000000 * 10 **8; // 25% - 250 billion to Second Round & Bonus\n        balances[0xaAA258C8dbf31De53Aa679F6b492569556e1c306] = _transfertosecondround;\n        Transfer(address(0), 0xaAA258C8dbf31De53Aa679F6b492569556e1c306, _transfertosecondround);\n    }\n  \n\n    function start_PREICO() public onlyOwner atStage(Stages.NOTSTARTED) {\n        stage = Stages.PREICO;\n        stopped = false;\n        balances[address(this)] =  maxCap_public;\n        pre_startdate = now;\n        pre_enddate = now + 16 days;\n        Transfer(0, address(this), balances[address(this)]);\n    }\n      \n    function start_ICO() public onlyOwner atStage(Stages.PREICO) {\n        require(now > pre_enddate || eth_received >= 1500 ether);\n        stage = Stages.ICO;\n        stopped = false;\n        ico1_startdate = now;\n        ico_first = now + 15 days;\n        ico_second = ico_first + 15 days;\n        ico_third = ico_second + 15 days;\n        ico_fourth = ico_third + 15 days;\n        Transfer(0, address(this), balances[address(this)]);\n    }\n    \n    function PauseICO() external onlyOwner {\n        stopped = true;\n    }\n\n    function ResumeICO() external onlyOwner {\n        stopped = false;\n    }\n    \n    function end_ICO() external onlyOwner atStage(Stages.ICO) {\n        require(now > ico_fourth);\n        stage = Stages.ENDED;\n        _totalsupply = (_totalsupply).sub(balances[address(this)]);\n        balances[address(this)] = 0;\n        Transfer(address(this), 0 , balances[address(this)]);\n        \n    }\n\n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalsupply;\n    }\n    \n    function balanceOf(address _owner)public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount )public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    function approve(address _spender, uint256 _amount)public returns (bool success) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n  \n    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n\n     // Transfer the balance from owner's account to another account\n     function transfer(address _to, uint256 _amount)public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    // Transfer the balance from owner's account to another account\n    function transferTokens(address _to, uint256 _amount) private returns(bool success) {\n        require( _to != 0x0);       \n        require(balances[address(this)] >= _amount && _amount > 0);\n        balances[address(this)] = (balances[address(this)]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(address(this), _to, _amount);\n        return true;\n    }\n \n    // Transfer the balance from owner's account to advisor's account\n    function transferToAdvisors(address _to, uint256 _amount) public returns(bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        \n        if(!isAdvisor(_to)) {\n          addAdvisor(_to);\n          advisorCount++ ;\n        }\n\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n \n    function addAdvisor(address _advisor) public {\n        Advisors[_advisor]=true;\n    }\n\n    function isAdvisor(address _advisor) public returns(bool success){\n        return Advisors[_advisor];\n        return true;\n    }\n    \n    function drain() external onlyOwner {\n        owner.transfer(this.balance);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a GenF smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Design a smart contract named GenF that combines the ERC721A token standard with unique features for a digital asset launch. This contract manages a collection with a Dutch auction for public sale, a whitelist for presale, and admin functions for managing the sale's parameters. It also includes provenance data for the collection's authenticity, Merkle proof verification for whitelist eligibility, and withdrawal functionality for collecting funds.\n\nContract Specifications:\n- Inherits ERC721A for efficient batch minting and Ownable for administrative control.\n- Manages a digital asset collection with a fixed supply, dynamic pricing for public sale, and restricted access for presale.\n- Utilizes a Merkle tree for verifying whitelist participants and their allocations.\n- Implements a Dutch auction mechanism for determining the sale price over time.\n\nKey Functionalities:\n1. Whitelist and Presale Management: Allows participants with verified Merkle proofs to mint tokens at a preset price before the public sale.\n2. Dutch Auction for Public Sale: Dynamically adjusts the minting price based on the elapsed time from the start of the sale.\n3. Provenance Record: Maintains a provenance hash to ensure the collection's authenticity and integrity.\n4. Admin Control: Includes functions for the owner to adjust sale parameters, manage the whitelist, and set collection metadata.\n\nImplementation Details:\n- Minting Restrictions: Enforces rules for minting during the presale and public sale, including checks for start times, allocation limits, and payment amounts.\n- Pricing Calculation: The Dutch auction pricing is calculated based on the current time, with the price decreasing at specified intervals until a floor price is reached.\n- Whitelist Verification: Utilizes a Merkle tree for efficient and secure verification of presale participants and their minting allocation.\n- Funds Withdrawal: Provides a function for the owner to withdraw accumulated funds to a specified recipient address.\n\nSecurity Considerations:\n- Ownership and Access Control: Uses the Ownable modifier to protect critical functions that could alter the contract's operational parameters or withdraw funds.\n- Minting Validation: Ensures that minting cannot occur before the sale starts, exceeds allocation limits, or surpasses the collection's maximum supply.\n- Pricing Integrity: The Dutch auction mechanism requires careful implementation to prevent manipulation or errors in pricing calculations.\n"}, {"role": "assistant", "content": "contract GenF is ERC721A, Ownable {\n    string public PROVENANCE;\n\n    bytes32 public merkleRoot = \"\"; // Construct this from (address, amount) tuple elements\n    mapping(address => uint) public whitelistRemaining; // Maps user address to their remaining mints if they have minted some but not all of their allocation\n    mapping(address => bool) public whitelistUsed; // Maps user address to bool, true if user has minted\n\n    uint public presaleMintPrice;\n    uint public dutchAuctionStart;\n    uint public dutchAuctionEnd = 0.025 ether;\n    uint public dutchAuctionIncrement = 0.025 ether;\n    uint public dutchAuctionStepTime = 300; // 5 minutes\n    uint public maxItems = 10000;\n    uint public maxItemsPerTx = 10;\n    address public recipient;\n    string public _baseTokenURI;\n    uint public startTimestamp;\n\n    event Mint(address indexed owner, uint indexed tokenId);\n\n    constructor(address _owner) ERC721A(\"Gen-F\", \"GENF\", 200) {\n        require(_owner != address(0x0), \"Set owner\");\n        transferOwnership(_owner);\n    }\n\n    modifier mintingOpen() {\n        require(startTimestamp != 0, \"Start timestamp not set\");\n        require(block.timestamp >= startTimestamp, \"Not open yet\");\n        _;\n    }\n\n    function dutchAuctionPrice() public view returns (uint) {\n        if (startTimestamp == 0 || block.timestamp <= startTimestamp) {\n            return dutchAuctionStart;\n        } else {\n            uint increments = (block.timestamp - startTimestamp) / dutchAuctionStepTime;\n            if (increments * dutchAuctionIncrement >= dutchAuctionStart) {\n                return dutchAuctionEnd;\n            } else {\n                return dutchAuctionStart - (increments * dutchAuctionIncrement);\n            }\n        }\n    }\n\n    function ownerMint(uint amount) external onlyOwner {\n        _mintWithoutValidation(msg.sender, amount, true);\n    }\n\n    function publicMint(uint amount) external payable mintingOpen {\n        // Require nonzero amount\n        require(amount > 0, \"Can't mint zero\");\n\n        // Check proper amount sent\n        require(msg.value == amount * dutchAuctionPrice(), \"Send proper ETH amount\");\n\n        _mintWithoutValidation(msg.sender, amount, false);\n    }\n\n    function whitelistMint(uint amount, uint totalAllocation, bytes32 leaf, bytes32[] memory proof) external payable {\n        // Create storage element tracking user mints if this is the first mint for them\n        if (!whitelistUsed[msg.sender]) {        \n            // Verify that (msg.sender, amount) correspond to Merkle leaf\n            require(keccak256(abi.encodePacked(msg.sender, totalAllocation)) == leaf, \"Sender and amount don't match Merkle leaf\");\n\n            // Verify that (leaf, proof) matches the Merkle root\n            require(verify(merkleRoot, leaf, proof), \"Not a valid leaf in the Merkle tree\");\n\n            whitelistUsed[msg.sender] = true;\n            whitelistRemaining[msg.sender] = totalAllocation;\n        }\n\n        // Require nonzero amount\n        require(amount > 0, \"Can't mint zero\");\n\n        // Check proper amount sent\n        require(msg.value == amount * presaleMintPrice, \"Send proper ETH amount\");\n\n        require(whitelistRemaining[msg.sender] >= amount, \"Can't mint more than remaining allocation\");\n\n        whitelistRemaining[msg.sender] -= amount;\n        _mintWithoutValidation(msg.sender, amount, false);\n    }\n\n    function _mintWithoutValidation(address to, uint amount, bool skipMaxItems) internal {\n        uint _totalSupply = totalSupply(); // Cache variable after reading from storage\n        require(_totalSupply + amount <= maxItems, \"mintWithoutValidation: Sold out\");\n        require(skipMaxItems || amount <= maxItemsPerTx, \"mintWithoutValidation: Surpasses maxItemsPerTx\");\n        _safeMint(to, amount);\n    }\n\n    function verify(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\n        return MerkleProof.verify(proof, root, leaf);\n    }\n\n    function setProvenance(string memory provenance) public onlyOwner {\n        PROVENANCE = provenance;\n    }\n\n    function setPresaleMintPrice(uint _presaleMintPrice) external onlyOwner {\n        presaleMintPrice = _presaleMintPrice;\n    }\n\n    function setDutchAuctionStart(uint _dutchAuctionStart) external onlyOwner {\n        dutchAuctionStart = _dutchAuctionStart;\n    }\n\n    function setDutchAuctionEnd(uint _dutchAuctionEnd) external onlyOwner {\n        dutchAuctionEnd = _dutchAuctionEnd;\n    }\n\n    function setDutchAuctionIncrement(uint _dutchAuctionIncrement) external onlyOwner {\n        dutchAuctionIncrement = _dutchAuctionIncrement;\n    }\n\n    function setDutchAuctionStepTime(uint _dutchAuctionStepTime) external onlyOwner {\n        dutchAuctionStepTime = _dutchAuctionStepTime;\n    }\n\n    function setMaxItems(uint _maxItems) external onlyOwner {\n        maxItems = _maxItems;\n    }\n\n    function setMaxItemsPerTx(uint _maxItemsPerTx) external onlyOwner {\n        maxItemsPerTx = _maxItemsPerTx;\n    }\n\n    function setRecipient(address _recipient) external onlyOwner {\n        recipient = _recipient;\n    }\n\n    function setStartTimestamp(uint _startTimestamp) external onlyOwner {\n        startTimestamp = _startTimestamp;\n    }\n\n    function setBaseTokenURI(string memory __baseTokenURI) public onlyOwner {\n        _baseTokenURI = __baseTokenURI;\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    // Withdraw the contract balance to the recipient address\n    function withdraw() external {\n        require(recipient != address(0x0), \"Set recipient first\");\n        uint amount = address(this).balance;\n        (bool success,) = recipient.call{value: amount}(\"\");\n        require(success, \"Failed to send ether\");\n    }\n\n    // Returns a URI for a given token ID's metadata\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n        return string(abi.encodePacked(_baseTokenURI, Strings.toString(_tokenId)));\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Adet smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a comprehensive smart contract named Adet that incorporates the ERC20 standard functionalities with additional features like burning, freezing, and unfreezing of tokens. This contract is designed to support the digital economy of Australia, represented by the token name \"Australia Digital Economy Token\" (ADET), with precision up to 6 decimal places. The contract includes mechanisms to reduce the total supply through burning, restrict token transfers by freezing tokens, and manage token ownership and permissions comprehensively.\n\nContract Specifications:\n- Inherits from Owned, SafeMath, and Pausable to utilize ownership management, safe arithmetic operations, and pausing functionality.\n- Implements the EIP20Interface for standard ERC20 token operations.\n- Introduces additional features for burning tokens to reduce the total supply, and freezing/unfreezing tokens to control token liquidity and transferability.\n\nKey Functionalities:\n1. Token Basics: Establishes token properties including name (\"Australia Digital Economy\"), symbol (\"ADET\"), decimals (6), and an initial total supply of 2.8 billion tokens.\n2. Burning Tokens: Allows the owner to permanently remove tokens from the total supply, reducing the number of tokens in circulation.\n3. Freezing and Unfreezing Tokens: Enables the contract owner to freeze tokens for a specified address, preventing those tokens from being transferred until they are unfrozen.\n4. ERC20 Compliance: Fully supports standard ERC20 functions such as balance queries, transfers, and approvals, ensuring compatibility with the broader Ethereum ecosystem.\n5. Pause Functionality: Incorporates the ability to pause and unpause token transfers, providing emergency controls to address potential issues.\n\nImplementation Details:\n- SafeMath for Arithmetic: Utilizes the SafeMath library to prevent overflow and underflow vulnerabilities in arithmetic operations.\n- Ownership and Access Control: Leverages the Owned contract to manage ownership-specific actions, such as burning and freezing tokens.\n- Pausable Transfers: Ensures that token transfers can be paused or unpaused by the owner, enhancing security and operational control.\n- Freeze and Unfreeze Mechanics: Details the process for freezing tokens, including reducing the available balance and tracking frozen amounts, and similarly for unfreezing.\n\nSecurity Considerations:\n- Role-Based Features: Restricts sensitive actions like burning and freezing tokens to the contract owner, preventing unauthorized use.\n- Input Validations: Includes checks for zero addresses, sufficient balances, and non-negative transaction values to ensure robustness and security.\n- Pause Control: Offers a mechanism to stop all token transfers in the event of a security concern or during contract upgrades, minimizing potential risks.\n"}, {"role": "assistant", "content": "contract Adet is Owned, SafeMath, Pausable, EIP20Interface {\n    uint256 private totalSupply_;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    \n    mapping (address => uint256) public balances;\n    mapping (address => uint256) public frozen;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    event Freeze(address indexed from, uint256 value);\n    event Unfreeze(address indexed from, uint256 value);\n    event Burned(address indexed from, uint256 value);\n\n    constructor() public {\n        name = \"Australia Digital Econmoy\";\n        symbol = \"ADET\";\n        decimals = 6;\n        totalSupply_ = 2800000000 * 10 ** uint256(decimals);\n        balances[msg.sender] = totalSupply_;\n    }\n\n    function burn(address _addr, uint256 _amount) onlyOwner public returns (bool success) {\n        require(_addr != 0);\n        require(_amount <= balances[_addr]);\n\n        totalSupply_ = sub(totalSupply_, _amount);\n        balances[_addr] = sub(balances[_addr], _amount);\n        emit Transfer(_addr, address(0), _amount);\n        emit Burned(_addr, _amount);\n        return true;\n    }\n\n    function freeze(address _addr, uint256 _value) public onlyOwner returns (bool success) {\n        require(balances[_addr] >= _value);\n        require(_value > 0);\n        balances[_addr] = sub(balances[_addr], _value);\n        frozen[_addr] = add(frozen[_addr], _value);\n        emit Freeze(_addr, _value);\n        return true;\n    }\n    \n    function unfreeze(address _addr, uint256 _value) public onlyOwner returns (bool success) {\n        require(frozen[_addr] >= _value);\n        require(_value > 0);\n        frozen[_addr] = sub(frozen[_addr], _value);\n        balances[_addr] = add(balances[_addr], _value);\n        emit Unfreeze(_addr, _value);\n        return true;\n    }\n\n    function frozenOf(address _addr) public view returns (uint256 balance) {\n        return frozen[_addr];\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    function balanceOf(address _addr) public view returns (uint256 balance) {\n        return balances[_addr];\n    }\n\n    function transfer(address _to, uint256 _value) public notPaused returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        require(balances[_to] + _value >= balances[_to]);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public notPaused returns (bool success) {\n        require(balances[_from] >= _value);\n        require(balances[_to] + _value >= balances[_to]);\n        require(allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public notPaused returns (bool success) {\n        require(_value > 0);\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    } \n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Hypechill smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract named Hypechill utilizing the ERC20 standard, augmented with a fee on transactions to support operational or developmental costs. This contract introduces a transfer fee mechanism applied to token transfers, excluding designated fee-exempt accounts, to generate revenue or support specific financial strategies. It includes administrative functions to manage the fee structure and exempt accounts, ensuring flexibility and control over the tokenomics.\n\nContract Specifications:\n- Inherits ERC20 for token functionality and Ownable for administrative actions.\n- Sets an initial supply of 25,800 CHILL tokens, with 18 decimal places, during contract deployment.\n- Implements a mechanism to levy fees on transfers, expressed as a percentage of the transaction amount.\n\nKey Functionalities:\n1. Initial Token Supply: Mints an initial supply of CHILL tokens to the contract owner's address upon deployment.\n2. Transfer Fee Mechanism: Applies a fee to token transfers, directing the fee to a specified recipient account, which can be changed by the contract owner.\n3. Fee Management: Allows the contract owner to adjust the transfer fee percentage and activate or deactivate the fee mechanism as needed.\n4. Fee Exceptions: Provides the ability to exempt certain accounts from transfer fees, accommodating use cases like liquidity pools or partner addresses.\n5. Event Logging: Emits events for significant administrative actions, such as changing the transfer fee, updating the fee recipient, and modifying fee exceptions.\n\nImplementation Details:\n- Fee Calculation: Calculates the transfer fee based on a set percentage of the transaction amount, ensuring the recipient receives the amount minus the fee.\n- Exempt Accounts: Manages a mapping of accounts that are exempt from transfer fees, allowing for strategic partnerships or operational necessities.\n- Administrative Controls: Includes functions for the owner to update the transfer fee percentage, designate the fee recipient, and manage exemptions.\n\nSecurity Considerations:\n- Ownership Verification: Utilizes the onlyOwner modifier to restrict sensitive operations, such as adjusting fees or designating exempt accounts, to the contract owner.\n- Fee Limits: Ensures the transfer fee percentage does not exceed a maximum threshold to protect users from excessive deductions.\n- Safe Math Operations: Employs the SafeMath library for arithmetic operations to prevent overflow and underflow vulnerabilities.\n"}, {"role": "assistant", "content": "contract Hypechill is ERC20, Ownable {\n    constructor() public ERC20(\"hypechill.finance\", \"CHILL\") { \n        // Mint 25,800 CHILL (18 Decimals)\n        _mint(msg.sender, 25800000000000000000000);\n    }\n\n    // Transfer Fee\n    event TransferFeeChanged(uint256 newFee);\n    event FeeRecipientChange(address account);\n    event AddFeeException(address account);\n    event RemoveFeeException(address account);\n\n    bool private activeFee;\n    uint256 public transferFee; // Fee as percentage\n    address public feeRecipient; \n\n    // Exception to transfer fees, for example for Uniswap contracts.\n    mapping (address => bool) public feeException;\n\n    function addFeeException(address account) public onlyOwner {\n        feeException[account] = true;\n        emit AddFeeException(account);\n    }\n\n    function removeFeeException(address account) public onlyOwner {\n        feeException[account] = false;\n        emit RemoveFeeException(account);\n    }\n\n    function setTransferFee(uint256 fee) public onlyOwner {\n        require(fee <= 2500, \"Fee cannot be greater than 25%\");\n        if (fee == 0) {\n            activeFee = false;\n        } else {\n            activeFee = true;\n        }\n        transferFee = fee;\n        emit TransferFeeChanged(fee);\n    }\n\n    function setTransferFeeRecipient(address account) public onlyOwner {\n        feeRecipient = account;\n        emit FeeRecipientChange(account);\n    }\n\n    // Transfer recipient recives amount - fee\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        if (activeFee && feeException[_msgSender()] == false) {\n            uint256 fee = transferFee.mul(amount).div(10000);\n            uint amountLessFee = amount.sub(fee);\n            _transfer(_msgSender(), recipient, amountLessFee);\n            _transfer(_msgSender(), feeRecipient, fee);\n        } else {\n            _transfer(_msgSender(), recipient, amount);\n        }\n\n        return true;\n    }\n\n    // TransferFrom recipient recives amount, sender's account is debited amount + fee\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        if (activeFee && feeException[recipient] == false) {\n            uint256 fee = transferFee.mul(amount).div(10000);\n            _transfer(sender, feeRecipient, fee);\n        }\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Onemizer90 smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract, Onemizer90, which is an ERC721 token with unique functionalities tailored for minting, reserving, and managing a limited supply of tokens. The contract integrates sales constraints, allowing tokens to be minted only after a specified start date and ensuring transactions meet the set ether value. Additionally, it supports owner-specific features like modifying contract parameters and reserving tokens for specific addresses.\n\nContract Specifications:\n- Inherits ERC721 and Ownable functionalities.\n- Utilizes Counters from OpenZeppelin to manage token IDs.\n- Establishes sale parameters including price, start date, max supply, and reserved tokens.\n- Includes a sale active modifier to control minting operations based on the start date.\n- Provides functions for minting, reserving tokens, querying total supply, and owner-specific operations like setting base URI, price, start date, max supply, and reserved tokens.\n\nKey Functionalities:\n1. Minting: Users can mint a specified number of tokens, adhering to the sale's active state, correct ether value, and max supply constraints.\n2. Reserving Tokens: The contract owner can reserve tokens for specific addresses, not affecting the publicly available supply.\n3. Supply and Ownership Queries: Functions are available to query the total supply of tokens and the list of token IDs owned by a specific address.\n4. Parameter Modifications: Only the contract owner can modify key parameters like the base URI, price, start date, max supply, and reserved tokens.\n5. Withdrawal: Enables the contract owner to withdraw funds to a specified address.\n6. OpenSea Integration: Overrides isApprovedForAll to whitelist OpenSea proxy accounts, facilitating gas-less listings.\n\nImplementation Details:\n- The mint function incorporates the saleIsActive modifier, ensuring tokens can only be minted after the sale starts, and checks if the ether sent with the request matches the total price for the requested number of tokens.\n- Reserved tokens are considered in the total supply to prevent exceeding the max supply when minting.\n- The reserve function is restricted to the contract owner, allowing them to mint tokens directly to given addresses without payment.\n- Base URI, price, start date, max supply, and reserved tokens can be updated by the owner, allowing for flexibility in managing the sale.\n\nSecurity Considerations:\n- Ensures that only the contract owner can modify critical contract parameters and reserve tokens, protecting against unauthorized alterations.\n- Includes checks for valid addresses and correct ether values to mitigate common vulnerabilities.\n- The use of the Ownable and Counters libraries from OpenZeppelin provides tested and secure management of ownership and token ID incrementation.\n- The contract adheres to ERC721 standards for NFTs, ensuring compatibility and security in transactions and ownership management.\n"}, {"role": "assistant", "content": "contract Onemizer90 is ERC721, Ownable {\n    using Counters for Counters.Counter;\n    address proxyRegistryAddress;\n    Counters.Counter private _tokenSupply;\n\n    uint256 public PRICE;\n    uint256 public START_DATE;\n    uint256 public MAX_SUPPLY;\n    uint256 public RESERVED;\n\n    string private baseUri;\n\n    modifier saleIsActive() {\n        require(START_DATE != 0 && block.timestamp >= START_DATE, \"Sale is not active yet\");\n        _;\n    }\n\n    constructor(address _proxyRegistryAddress, uint256 _price, uint256 _startDate, uint256 _maxSupply, uint256 _reserved, string memory _baseUri) ERC721(\"Onemizer90\", \"OM\") {\n        proxyRegistryAddress = _proxyRegistryAddress;\n        PRICE = _price;\n        START_DATE = _startDate;\n        MAX_SUPPLY = _maxSupply;\n        RESERVED = _reserved;\n        baseUri = _baseUri;\n    }\n\n    function mint(uint256 numberOfTokens) public payable saleIsActive {\n        require(numberOfTokens * PRICE == msg.value, \"Ether value is not correct\");\n        require(_tokenSupply.current() + numberOfTokens + RESERVED <= MAX_SUPPLY, \"Sold out!\");\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, _tokenSupply.current());\n            _tokenSupply.increment();\n        }\n    }\n\n    function reserve(address[] calldata to) public onlyOwner {\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], _tokenSupply.current());\n            _tokenSupply.increment();\n        }\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _tokenSupply.current();\n    }\n\n    function contractURI() public pure returns (string memory) {\n        return \"ipfs://bafybeigpmcheddbbt7un2745fzpoi3r3vsxnjhtzj5poovsledgb52qd3i\";\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseUri;\n    }\n\n    function setBaseURI(string memory _baseUri) public onlyOwner {\n        baseUri = _baseUri;\n    }\n\n    function setPrice(uint256 _price) public onlyOwner {\n        PRICE = _price;\n    }\n\n    function setStartDate(uint256 _startDate) public onlyOwner {\n        START_DATE = _startDate;\n    }\n\n    function setMaxSupply(uint256 _maxSupply) public onlyOwner {\n        MAX_SUPPLY = _maxSupply;\n    }\n\n    function setReserved(uint256 _reserved) public onlyOwner {\n        RESERVED = _reserved;\n    }\n\n    function walletOfOwner(address owner) public view returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](balanceOf(owner));\n        uint256 i = 0;\n\n        for (uint256 tokenId = 0; tokenId < _tokenSupply.current(); tokenId++) {\n            if (_exists(tokenId) && ownerOf(tokenId) == owner) {\n                result[i] = tokenId;\n                i += 1;\n            }\n        }\n        return result;\n    }\n\n    function withdraw(address payable to, uint256 amount) public onlyOwner {\n        require(to != address(0x0), \"Invalid address\");\n        to.transfer(amount);\n    }\n\n    // Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        // Whitelist OpenSea proxy contract for easy trading.\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n\n        return super.isApprovedForAll(owner, operator);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a YahtsContract smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop an ERC20 token smart contract named YahtsContract with advanced features including burning tokens and preventing accidental ETH transfers to the contract. The contract aims to manage a predefined supply of tokens, facilitate transfers between addresses, allow token spending approvals, and enable token holders to reduce the total supply by burning tokens they own.\n\nContract Specifications:\n- Implements ERC20 standard functionalities.\n- Initializes with a fixed token supply, name, symbol, standard, and decimals.\n- Incorporates functions for token transfer, allowance management, balance queries, and token burning.\n- Utilizes SafeMath for arithmetic operations to prevent overflow and underflow vulnerabilities.\n- Rejects incoming ETH transactions to prevent accidental ETH deposits.\n\nKey Functionalities:\n1. Initial Token Allocation: Assigns the entire initial supply to the contract creator's address.\n2. Token Transfer: Enables token holders to transfer tokens to another address, with checks for sufficient balance.\n3. Approval Mechanism: Allows token holders to authorize a third party to spend a specified amount of tokens on their behalf.\n4. Transfer from Approved Account: Facilitates transfers from an approved account up to the allowed limit, adjusting balances and allowances accordingly.\n5. Token Burning: Permits token holders to reduce the circulating supply by destroying a portion of their tokens.\n6. Query Functions: Provides public view functions to access token details (name, symbol, standard, decimals) and account-specific details (balance, allowance).\n\nImplementation Details:\n- The transfer, approve, and transferFrom functions incorporate checks for zero addresses and sufficient balances/allowances, aligning with ERC20 standards.\n- The burn function allows token holders to voluntarily decrease the total supply by destroying their tokens, emitting a transfer event to the zero address to signify the burn.\n- SafeMath library is used to safely conduct arithmetic operations, protecting against overflow and underflow.\n- The contract explicitly rejects direct ETH transfers by reverting transactions, ensuring that users do not mistakenly send ETH to the contract.\n\nSecurity Considerations:\n- Utilizes OpenZeppelin's SafeMath library to mitigate arithmetic vulnerabilities.\n- Includes input validation to prevent transfers to the zero address and ensure action legitimacy.\n- Implements a mechanism to reject ETH deposits, protecting users from accidental loss of ETH.\n- Adheres to the ERC20 standard, ensuring compatibility with the Ethereum ecosystem and preventing common token contract issues.\n"}, {"role": "assistant", "content": "contract YahtsContract is ERC20 {\n    string internal _name = \"VI YAHTS 1\";\n    string internal _symbol = \"VT1\";\n    string internal _standard = \"ERC20\";\n    uint8 internal _decimals = 18;\n    uint internal _totalSupply = 500000 * 1 ether;\n    \n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor () public {\n        balances[msg.sender] = totalSupply();\n    }\n\n    function () external payable  {\n        revert(\"This SmartContract is not payable\");\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function standard() public view returns (string memory) {\n        return _standard;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require (_spender != address(0), \"_spender address has to be set\");\n        require (_value > 0, \"'_value' parameter has to be greater than 0\");\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_from != address(0), \"'_from' address has to be set\");\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[_from], \"Insufficient balance\");\n        require(_value <= allowed[_from][msg.sender], \"Insufficient allowance\");\n\n        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n        balances[_from] = SafeMath.sub(balances[_from], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n    \n    function burn(uint256 _value) public returns (bool success) {\n        require(_value <= balances[msg.sender]);\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        _totalSupply = SafeMath.sub(_totalSupply, _value);\n        emit Transfer(msg.sender, address(0), _value);\n        return true;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a PerkyPineapples smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a unique ERC721 token smart contract, PerkyPineapples, designed to manage a collection of NFTs with distinct minting phases, including a free minting period. This contract incorporates several adjustable parameters to control the sales process, such as activation status, price per token, maximum tokens per transaction, and limitations on free mints per wallet. It also includes a mechanism to gift tokens and withdraw contract balances, alongside integration with proxy registries for marketplace compatibility.\n\nContract Specifications:\n- Inherits ERC721 and Ownable functionalities for NFT management and ownership control.\n- Defines parameters for sale activation, token pricing, minting caps, and free mint allowances.\n- Utilizes a counter to track the total supply of tokens.\n- Allows for the setting of hidden and base URIs to manage how token metadata is presented before and after reveal.\n- Includes proxy registry address integration for marketplace facilitation.\n\nKey Functionalities:\n1. Sale Activation: The contract owner can toggle the sale's active status, controlling when minting is allowed.\n2. Minting: Users can mint a specified number of tokens, adhering to maximum per transaction and total supply limits, with a distinction between paid and free minting based on the current supply and per-wallet free mint limits.\n3. Gifting Tokens: The contract owner can mint tokens directly to any address, bypassing payment and mint limits.\n4. Withdrawal: Enables the contract owner to withdraw the balance of ETH collected from token sales.\n5. Metadata Management: Offers functions to set hidden and revealed metadata URIs for the tokens.\n6. Marketplace Integration: Adjusts approval checks for token operations through a proxy registry, aiding in marketplace listings.\n\nImplementation Details:\n- The contract distinguishes between free and paid mints based on the total amount of tokens already minted and individual wallet contributions to the free mint count.\n- Incorporates safety checks to prevent sending ETH to the contract unintentionally.\n- Utilizes a constructor to gift an initial set of tokens to the contract deployer.\n- Employs Counters to safely increment token IDs upon minting.\n- Provides public view functions for querying contract states, such as total supply and sale activation status.\n\nSecurity Considerations:\n- Ensures that minting functions check for sale activation and adhere to max supply constraints to prevent over-minting.\n- Uses onlyOwner modifiers for functions that modify critical parameters, ensuring that only the contract owner can alter the sale dynamics.\n- Prevents direct ETH transfers to the contract, mitigating the risk of unintended contract interactions.\n- Safe use of external calls (msg.sender.call) in the withdrawal function, though care must be taken to monitor for reentrancy vulnerabilities.\n"}, {"role": "assistant", "content": "contract PerkyPineapples is ERC721, Ownable {\n    bool public saleIsActive = false;\n\n    uint256 public price = 0.025 ether;\n\tuint public maxPerTx = 10;\n\tuint public maxFreeMintPerWallet = 20;\n\tuint public amountAvailableFreeMint = 200;\n\tuint public maxSupply = 5000;\n\taddress proxyRegistryAddress ; \n\tmapping(address => uint) public addressFreeMinted;\n    string public _hiddenURI = \"ipfs://QmRkNnfQExTwer7vL1PNuRszzshpUWjRb7AerWQt1Ef82Q/hidden.json\";\n    string public _baseURIextended = \"\";\n\t\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenSupply;\n\n    constructor() ERC721(\"PerkyPineapples\", \"PP\") {\n        for (uint256 i = 0; i < 10; i++){\n            gift(msg.sender);\n        }\n    }\n\n    function totalSupply() public view returns (uint256 supply) {\n        return _tokenSupply.current();\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n\n        return super.isApprovedForAll(owner, operator);\n    }\n\n    function mint(uint numberOfTokens) external payable {\n        require(saleIsActive, \"Sale is inactive.\");\n        require(numberOfTokens <= maxPerTx, \"You can only mint 10 at a time.\");\n        require(_tokenSupply.current() + numberOfTokens <= maxSupply, \"Purchase would exceed max supply of tokens\");\n        \n        if (_tokenSupply.current() + numberOfTokens > amountAvailableFreeMint) {\n            require((price * numberOfTokens) <= msg.value, \"Don't send under (in ETH).\");\n        } else {\n\t\t\trequire(msg.value == 0, \"Don't send ether for the free mint.\");\n\t\t\trequire(addressFreeMinted[msg.sender] < maxFreeMintPerWallet, \"You can only adopt 20 free CAU per wallet. Wait for the paid adoption.\");\n\t\t}\n\t\t\n\t\taddressFreeMinted[msg.sender] += numberOfTokens;\n        for(uint i = 0; i < numberOfTokens; i++) {\n\t\t  uint256 _tokenId = _tokenSupply.current() + 1;\n            _safeMint(msg.sender, _tokenId);\n            _tokenSupply.increment();\n        }\n    }\n\n    function gift(address _to) public onlyOwner {\n        uint256 _tokenId = _tokenSupply.current() + 1;\n        _safeMint(_to, _tokenId);\n        _tokenSupply.increment();\n    }\n\n    function withdraw() public onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 \n            ? string(abi.encodePacked(baseURI, Strings.toString(tokenId), \".json\")) \n            : _hiddenURI; // If the base URI is not set, return a hidden URI\n    }\n\n    function setSaleIsActive(bool newState) public onlyOwner {\n        saleIsActive = newState;\n    }\n\n    function setPrice(uint newPrice) public onlyOwner {\n        price = newPrice;\n    }\n\n    function setMaxPerTx(uint _maxPerTx) external onlyOwner() {\n        maxPerTx = _maxPerTx;\n    }\n\n    function setMaxFreeMintPerWallet(uint _maxFreeMint) public onlyOwner() {\n        maxFreeMintPerWallet = _maxFreeMint;\n    }\n\n    function setAmountAvailableFreeMint(uint _freeMint) public onlyOwner() {\n        amountAvailableFreeMint = _freeMint;\n    }\n\n    function setMaxSupply(uint _maxSupply) public onlyOwner() {\n        maxSupply = _maxSupply;\n    }\n\n    // rinkeby: 0xf57b2c51ded3a29e6891aba85459d600256cf317\n    // mainnet: 0xa5409ec958c83c3f309868babaca7c86dcb077c1\n    function setProxyRegistryAddress(address proxyAddress) external onlyOwner {\n        proxyRegistryAddress = proxyAddress;\n    }\n\n    function setHiddenUri(string memory hiddenURI) public onlyOwner() {\n        _hiddenURI = hiddenURI;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\n        _baseURIextended = baseURI_;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a XYZZ smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a versatile ERC20 token smart contract, XYZZ, that incorporates a crowdfunding ICO mechanism with specific timelines, bonus periods, and caps. The contract features advanced token management options such as minting, burning, freezing accounts, and facilitating purchases within defined periods. Additionally, it incorporates SafeMath for arithmetic operations to prevent overflow and underflow vulnerabilities.\n\nContract Specifications:\n- Implements the ERC20 standard with extensions for crowdfunding functionality.\n- Initial setup includes token name, symbol, description, decimals, and caps (internal, soft).\n- Defines time-bound conditions for bonus periods and ICO duration.\n- ICO Stages: Include variables to manage ICO stages, like `_startDate`, `_bonusEnds`, `_endDate`, `_internalCap`, and `_softCap`\n- Utilizes mappings for token balances, allowances, and account freeze states.\n- Provides a mechanism for token purchases with bonuses, account freezing/unfreezing, token minting, and burning.\n- State Variables: Define mappings for storing balances (`_balances`), allowances (`_allowed`), and account freeze states (`_freezeState`).\n\nKey Functionalities:\n1. Constructor: Initialize the contract with token information, ICO parameters, and allocate initial tokens to the minter's account.\n2. ICO and Bonus Periods: Specifies start, bonus, and end dates for the ICO, including bonus token issuance for early contributions.\n3. Token Purchase: Enables the purchase of tokens by sending ETH to the contract, with bonus tokens awarded during the bonus period.\n4. Account Freezing: Allows the contract owner to freeze/unfreeze accounts, preventing affected accounts from transferring tokens.\n5. Token Minting and Burning: Grants the contract owner the ability to mint new tokens or burn existing tokens from the supply.\n6. Crowdfunding Goals: Incorporates soft and internal cap goals to gauge the success of the crowdfunding effort.\n7. Transfer Restrictions: Enforces transfer and approval restrictions until the ICO is successfully concluded, based on the end date and soft cap achievement.\n\nImplementation Details:\n- The constructor sets initial token parameters and allocates the internal cap amount to the contract owner.\n- Token purchases are allowed within the ICO period, with the amount of tokens received based on the contribution amount and current phase.\n- Implements SafeMath library functions for secure mathematical operations.\n- Includes modifiers to enforce ICO success conditions and check for account freeze states before allowing token transfers or approvals.\n- Offers approveAndCall function for compatibility with contracts that need to execute functions upon receiving approval.\n\nSecurity Considerations:\n- Utilizes the SafeMath library to mitigate overflow and underflow risks in arithmetic operations.\n- Restricts critical operations such as minting, burning, freezing, and unfreezing of accounts to the contract owner, protecting against unauthorized access.\n- Enforces a freeze mechanism to temporarily halt transactions for specific accounts, adding an extra layer of control over token circulation.\n- Ensures that token purchases, transfers, and approvals are only processed if the ICO has reached its end and the soft cap goal, safeguarding against premature distribution.\n"}, {"role": "assistant", "content": "\ncontract XYZZ is ERC20Interface, Owned, SafeMath {\n    string public symbol;\n    string public name;\n    string public description;\n    uint8 public decimals;    \n    uint private _startDate;\n    uint private _bonusEnds;\n    uint private _endDate;\n\n    uint256 private _internalCap;\n    uint256 private _softCap;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) _balances;\n    mapping(address => mapping(address => uint256)) _allowed;\n    mapping(address => bool) _freezeState;\n\n    constructor(\n        address payable minter) public {\n        \n        name   = \"VGNA Token\";\n        description = \"Virtual Geospatial Networking Asset\";\n        symbol = \"VGNA\";\n        decimals = 18;\n        _internalCap = 25000000;\n        _softCap     = 50000000;\n        \n        _bonusEnds = now + 3 days;\n        _endDate = now + 1 weeks;\n            \n        _owner = minter;\n        _balances[_owner] = _internalCap;  \n        _totalSupply = _internalCap;\n        emit Transfer(address(0), _owner, _internalCap);\n    }\n\n    modifier IcoSuccessful {\n        require(now >= _endDate);\n        require(_totalSupply >= _softCap);\n        _;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply - _balances[address(0)];\n    }\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return _balances[tokenOwner];\n    }\n    \n    function isFreezed(address tokenOwner) public view returns (bool freezed) {\n        return _freezeState[tokenOwner];\n    }\n\n    // Transfer the balance from token owner's account to `to` account\n    function transfer(address to, uint256 tokens) public IcoSuccessful returns (bool success) {\n        require(_freezeState[msg.sender] == false);\n        \n        _balances[msg.sender] = safeSub(_balances[msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    \n    // Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account\n    function approve(address spender, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    function transferFrom(address from, address to, uint tokens) public IcoSuccessful returns (bool success) {\n        require( _freezeState[from] == false && _freezeState[to] == false);\n        \n        _balances[from] = safeSub(_balances[from], tokens);\n        _allowed[from][msg.sender] = safeSub(_allowed[from][msg.sender], tokens);\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    // Returns the amount of tokens approved by the owner that can be transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        require(_freezeState[spender] == false);\n        return _allowed[tokenOwner][spender];\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account. The `spender` contract function `receiveApproval(...)` is then executed\n    function approveAndCall(address spender, uint tokens, bytes memory data) public IcoSuccessful returns (bool success) {\n        require(_freezeState[spender] == false);\n        _allowed[msg.sender][spender] = tokens;\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, _owner, data);\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // 1 VGNA Tokens per 1 Wei\n    function buy() public payable {\n        require(msg.value >= 1 finney);\n        require(now >= _startDate && now <= _endDate);\n\n        uint256 weiValue = msg.value;\n        uint256 tokens = 0;\n        \n        if (now <= _bonusEnds) {\n            tokens = safeMul(weiValue, 2);\n        } else {\n            tokens = safeMul(weiValue, 1);\n        }\n        \n        _freezeState[msg.sender] = true;\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        _owner.transfer(msg.value);\n    }\n    \n    function () payable external {\n        buy();\n    }\n\n    function burn(uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[msg.sender] >= tokens);   // Check if the sender has enough\n        address burner = msg.sender;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function burnFrom(address account, uint256 tokens) public onlyOwner returns (bool success) {\n        require(_balances[account] >= tokens);   // Check if the sender has enough\n        address burner = account;\n        _balances[burner] = safeSub(_balances[burner], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Transfer(burner, address(0), tokens);\n        return true;\n    }\n    \n    function freeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = true;\n        return true;\n    }\n    \n    function unfreeze(address account) public onlyOwner returns (bool success) {\n        require(account != _owner && account != address(0));\n        _freezeState[account] = false;\n        return true;\n    }\n    \n    function mint(uint256 tokens) public onlyOwner returns (bool success)\n    {\n        require(now >= _startDate && now <= _endDate);\n        _balances[msg.sender] = safeAdd(_balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        emit Transfer(address(0), msg.sender, tokens);\n        return true;\n    }\n\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(_owner, tokens);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a AquaTools smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a comprehensive prompt for a smart contract named AquaTools, which integrates the ERC1155 standard for NFTs, includes ownership and supply tracking functionalities, and enables presale and public sale mechanisms with price and supply management. This contract is designed for a specific collection with a maximum supply limit and incorporates a whitelist verification system using Merkle proofs for presale participants.\n\nContract Specifications:\n- Inherits from ERC1155 for NFT functionality, Ownable for ownership management, and ERC1155Supply for supply tracking.\n- Sets a token price, maximum supply, reserved supply for the owner, and sale status flags.\n- Includes minting functions for both presale and public sale with specific limits per transaction.\n- Utilizes a Merkle proof for whitelist verification during the presale.\n- Provides owner-only functions to adjust sale parameters and withdraw contract balance.\n\nKey Functionalities:\n1. Initial Setup: On deployment, mints a specified reserved supply to the contract owner and sets initial URI for metadata.\n2. Sale Management: Allows the owner to toggle presale and sale status, adjust the token price, set a new Merkle root for whitelist verification, and update the metadata URI.\n3. Withdrawal Function: Enables the owner to withdraw all funds collected from sales.\n4. Minting Mechanics:\n    - Presale Minting: Requires valid Merkle proof for whitelist, checks for presale status, and enforces a limit on the number of mints per transaction.\n    - Public Sale Minting: Checks for sale status and limits the number of mints per transaction.\n5. Supply and Ownership Queries: Functions to check the remaining supply, token ownership, and contract balance.\n\nImplementation Details:\n- The constructor mints the reserved supply to the owner and decreases the available supply accordingly.\n- Mint functions deduct from the supplyLeft and ensure the total minted tokens don't exceed maxSupply.\n- Presale minting requires a valid Merkle proof linking the transaction sender to the whitelist.\n- Sale status, price, and Merkle root can only be modified by the contract owner.\n- Uses ERC1155Supply to track and limit the total supply of tokens.\n- Includes safety checks for transfers and receiving tokens to comply with ERC1155 standards.\n\nSecurity Considerations:\n- The onlyOwner modifier ensures that critical functions can only be executed by the contract owner.\n- Merkle proof verification adds a layer of security for presale participation, ensuring only whitelisted addresses can mint.\n- Requires value sent with the mint transaction to match or exceed the calculated price to prevent underpayment.\n- Enforces max supply limits to prevent over-minting beyond the specified collection size.\n- Input validation for mint amounts and sale activation flags to avoid unintended state changes.\n"}, {"role": "assistant", "content": "\ncontract AquaTools is ERC1155, Ownable, ERC1155Supply {\n    uint256 public price = 0.1 ether;\n    uint16 public maxSupply = 3000;\n    uint16 public supplyLeft = maxSupply;\n    uint8 public reservedSupply = 200;\n    bool public presaleActive;\n    bool public saleActive;\n    uint8 public presaleMaxMintsPerTrans = 1;\n    uint8 public publicMaxMintsPerTrans = 3;\n    uint8 public passIndex = 0;\n    bytes32 public merkleRoot = 0x9492a15aa69d55a18e1181ac3b84b971ef9799e23b284f144961474af08621d9;\n\n    mapping(address => bool) public whitelistClaimed;\n\n    constructor() ERC1155(\"ipfs://QmTF8cSSv5Ewexo4TMU8Wg1MqEwXHfLVxYkuhy7GzwSU6U\") {\n        _mint(msg.sender, passIndex, reservedSupply, \"\");\n\n        supplyLeft -= reservedSupply;\n    }\n\n    function setPresaleStatus(bool _presaleActive) public onlyOwner {\n        presaleActive = _presaleActive;\n    }\n\n    function setSaleStatus(bool _saleActive) public onlyOwner {\n        saleActive = _saleActive;\n    }\n\n    function setPrice(uint256 _price) public onlyOwner {\n        price = _price;\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    function setURI(string memory newuri) public onlyOwner {\n        _setURI(newuri);\n    }\n\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function hasToken(address account) public view returns (bool) {\n        return balanceOf(account, passIndex) > 0;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return price;\n    }\n\n    function getSupplyLeft() public view returns (uint16) {\n        return supplyLeft;\n    }\n\n    function getMaxSupply() public view returns (uint16) {\n        return maxSupply;\n    }\n\n    function getMerkleRoot() public view returns (bytes32) {\n        return merkleRoot;\n    }\n\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function mintPresale(address account, uint8 amount, bytes32[] calldata _merkleProof) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(presaleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(!whitelistClaimed[msg.sender], \"Address has already claimed\");\n        require(amount <= presaleMaxMintsPerTrans, \"Only 1 mint allowed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(account));\n        require(\n            MerkleProof.verify(_merkleProof, merkleRoot, leaf),\n            \"Invalid proof\"\n        );\n\n        _mint(account, passIndex, amount, \"\");\n        whitelistClaimed[msg.sender] = true;\n\n        supplyLeft -= amount;\n    }\n\n    function mint(address account, uint8 amount) public payable {\n        require(msg.value >= amount * price, \"Wrong amount sent\");\n        require(saleActive, \"Sale is not active\");\n        require(amount > 0, \"Amount must be positive integer\");\n        require(\n            totalSupply(passIndex) + amount <= maxSupply,\n            \"Purchase would exceed max supply\"\n        );\n        require(amount <= publicMaxMintsPerTrans, \"Only 3 mints allowed\");\n\n        _mint(account, passIndex, amount, \"\");\n\n        supplyLeft -= amount;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155, ERC1155Supply) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a KOK_Contract smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a comprehensive prompt for the KOK_Contract, a smart contract that implements the ERC20 token standard with added features for ownership, blacklisting, and emergency stopping. The contract is designed for the \"KOK Coin\" with a fixed supply and additional mechanisms to control token distribution, such as an airdrop function for initial distribution and the ability to blacklist addresses to prevent them from participating in transactions.\n\nContract Specifications:\n- Inherits from ERC20Interface for standard token functionality and Owned for ownership management.\n- The token has a fixed supply, specified symbol, name, and decimal units.\n- Incorporates a blacklisting feature to restrict certain addresses from transferring or receiving tokens.\n- Includes an emergency stop feature that can halt all token transfers.\n- Allows the owner to distribute tokens through an airdrop to a list of addresses.\n\nKey Functionalities\n1. Initial Setup: On deployment, assigns the total supply of KOK Coins to the contract creator's address.\n2. Token Distribution via Airdrop: Allows the owner to distribute tokens to multiple addresses in one transaction, excluding addresses that already hold tokens.\n3. Blacklist Management: Provides functions for the owner to blacklist or remove addresses from the blacklist, affecting their ability to participate in transactions.\n4. Emergency Stop: Includes functionality to stop or restart the contract, preventing or allowing token transfers.\n5. ERC20 Compliance: Implements standard ERC20 functions for balance queries, transfers, allowance setup, and approval mechanisms, with added checks against the blacklist and stopped status.\n\nImplementation Details:\n- The constructor initializes the contract by setting the total token supply to the owner's balance.\n- The airdrop function iterates through an array of addresses, transferring specified token amounts to each, provided they don't already hold tokens.\n- Blacklisting is managed through a mapping, with events emitted upon changes to the blacklist status of any address.\n- Token transfers and approvals check whether the contract is stopped and if either the sender or recipient is blacklisted, rejecting transactions as necessary.\n- Standard ERC20 functions are modified to integrate checks for the stopped status and blacklist.\n\nSecurity Considerations:\n- The onlyOwner modifier ensures sensitive actions like stopping the contract, managing the blacklist, and performing airdrops are restricted to the contract owner.\n- Blacklist functionality adds a layer of security and control, allowing the owner to prevent malicious actors from participating in the token economy.\n- The stopped state acts as a circuit breaker to halt all token transfers in the event of an emergency, mitigating potential risks or vulnerabilities.\n- Validation checks in transfer functions prevent token losses and ensure that transactions adhere to the defined rules regarding blacklisting and emergency stops.\n"}, {"role": "assistant", "content": "\ncontract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if (balances[_to[i]] > 0) {\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success) {\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif (blackList[msg.sender] > 0) {\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (blackList[_to] > 0) {\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success) {\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif (blackList[_from] > 0) {\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (blackList[_to] > 0) {\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Minttk smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Craft a detailed prompt for the Minttk smart contract, which implements the ERC20 token standard alongside unique features such as Proof of Stake (PoS) mining rewards, a specified distribution of tokens for different purposes, and a minting function that rewards token holders. This contract is designed to manage the \"Minttk\" token with a predefined total supply, incorporating functionalities for ownership management, token distribution, and an incentive mechanism for token holders.\n\nContract Specifications:\n- Inherits from ERC20 for standard token functionality.\n- Utilizes SafeMath for safe arithmetic operations to prevent overflow and underflow.\n- Specifies token characteristics like name, symbol, decimals, and total supply.\n- Defines allocations for crowd sale, PoS mining, corporate reserve, promotion and bounty, and remaining tokens not allocated to PoS mining.\n- Includes an owner-specific modifier for functions that can only be executed by the contract owner.\n\nKey Functionalities:\n1. Initial Token Distribution: Upon deployment, assigns a portion of the total supply to the contract owner's balance.\n2. Token Minting Reward Mechanism: Allows token holders to receive rewards through a minting function, calculated as a percentage of their holdings if certain conditions are met.\n3. Token Transfer and Approval: Implements ERC20 standard functions with checks for blacklisted addresses and ensures that transfers only occur if the sender has sufficient balance.\n4. Ownership and Access Control: Uses an onlyOwner modifier to restrict certain administrative actions to the contract owner.\n5. Emergency Drain Function: Allows the contract owner to transfer all ether held by the contract to their address.\n\nImplementation Details:\n- The constructor initializes the contract, setting the initial token distribution to the owner.\n- The minting function calculates a 2% bonus of the holder's current balance, requiring at least a week between minting actions per address.\n- Token transfers are modified to include a check that prevents execution if the required time since the last minting has not passed, aligning with the minting restrictions.\n- Functions for transferring tokens (transfer, transferFrom), approving spending (approve), and checking allowances (allowance) adhere to ERC20 standards with added custom logic for the contract's features.\n- The contract employs SafeMath library functions to ensure safe arithmetic operations, guarding against common smart contract vulnerabilities.\n\nSecurity Considerations:\n- The onlyOwner modifier provides a mechanism to prevent unauthorized access to critical functions such as drain, ensuring that only the contract owner can perform these actions.\n- Utilizes the SafeMath library to prevent overflow and underflow, enhancing the contract's security by ensuring arithmetic operations are executed safely.\n- Minting restrictions, requiring a minimum interval between minting actions, aim to prevent abuse of the minting reward mechanism.\n- Validation checks in transfer functions ensure that tokens are not sent to the zero address, preventing accidental loss of tokens.\n"}, {"role": "assistant", "content": "\ncontract Minttk is ERC20 { \n    using SafeMath for uint256;\n    string public constant name = \"Minttk\"; // Name of the token\n    string public constant symbol = \"MNT\"; // Symbol of token\n    uint8 public constant decimals = 18; // Decimal of token\n    uint public _totalsupply = 500000000 * 10 ** 18; // 500 million total supply // muliplies dues to decimal precision\n    uint public crowdSale = 60000000 * 10 ** 18; // 60 million in Crowd Sale\n    uint public posMining = 350000000 * 10 ** 18; // 350 million in POS Mining\n    uint public corporateReserve = 80000000 * 10 ** 18; // 80 million in Corporate Reserve\n    uint public promotionBounty = 10000000 * 10 ** 18; // 10 million in Promotion & Bounty\n    uint public remainingToken = 150000000 * 10 ** 18; // 150 million in Remaining Token | Total Supply - POS\n    address public owner; // Owner of this contract\n    mapping(address => uint256) internal mintingDate;\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    \n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    function Minttk() public {\n        balances[msg.sender] = remainingToken;\n        Transfer(0, msg.sender, remainingToken);\n    }\n    \n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalsupply;\n    }\n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    \n    // Token minting function\n    function mint() public {\n        address _customerAddress = msg.sender;\n        uint256 userBalance = balances[_customerAddress];\n        uint256 currentTs = now;\n        uint256 userMintingDate = mintingDate[_customerAddress] + 7 days;\n        require (userBalance > 0);\n        require (currentTs > userMintingDate);\n        mintingDate[_customerAddress] = currentTs;\n        uint256 _bonusAmount = SafeMath.percent(userBalance,2,100,18);\n        balances[_customerAddress] = (uint256)(balances[_customerAddress]).add(_bonusAmount);\n    }\n    \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount ) public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n  \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        \n        address _customerAddress = msg.sender;\n        uint256 currentTs = now;\n        uint256 userMintingDate = mintingDate[_customerAddress] + 7 days;\n        require (currentTs > userMintingDate);\n        \n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    // Transfer the balance from owner's account to another account\n    function transferTokens(address _to, uint256 _amount) private returns (bool success) {\n        require( _to != 0x0);       \n        require(balances[address(this)] >= _amount && _amount > 0);\n        balances[address(this)] = (balances[address(this)]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(address(this), _to, _amount);\n        return true;\n    }\n \n    function drain() external onlyOwner {\n        owner.transfer(this.balance);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a TattooSkullzSociety smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a TattooSkullzSociety smart contract, which is an ERC721 non-fungible token (NFT) contract designed to manage the minting, sale, and distribution of a unique digital art collection called \"Skullz\". The contract incorporates features for a public sale, an allowlist (whitelist) sale, setting a provenance record, and managing base URI for metadata. It enforces limits on the total supply and the number of tokens that can be minted per transaction both in the public sale and allowlist sale.\n\nContract Specifications:\n- Inherits ERC721 for NFT functionality and ERC721Enumerable for enumerable extensions, along with Ownable for ownership management.\n- Defines constants for maximum supply, maximum tokens mintable per public transaction, reserve minting amount, and price per token.\n- Utilizes a mapping to manage the allowlist with the number of tokens addresses are allowed to mint.\n- Includes a provenance record and a variable for an extended base URI for metadata.\n\nKey Functionalities:\n1. Initial Setup: Upon deployment, initializes the NFT collection with a name and symbol.\n2. Allowlist Management:\n    - Ability to activate or deactivate the allowlist sale.\n    - Functions to set the allowlist and specify the number of tokens each address is allowed to mint.\n    - A method to check the number of tokens an address is eligible to mint from the allowlist.\n3. Minting Operations:\n    - Allowlist minting function that checks eligibility and enforces limits based on the allowlist.\n    - Public minting function available when the public sale is active, with checks on purchase limits and total supply constraints.\n    - Reserve minting function for the contract owner to mint tokens up to a specified reserve limit.\n4. Sale and Contract Management:\n    - Functions to toggle the public sale state.\n    - Withdraw function for the owner to transfer contract's Ether balance.\n    - Ability to set the provenance hash and base URI for the collection.\n\nImplementation Details:\n- The contract uses onlyOwner modifier to restrict certain management functions to the owner, such as toggling sale states, modifying the allowlist, and setting provenance and base URI.\n- Minting functions enforce checks for sale activation, maximum mint limits per transaction, total supply limits, and correct Ether value sent for the number of tokens being minted.\n- The contract overrides _baseURI to return a custom URI for token metadata, supporting dynamic content.\n\nSecurity Considerations:\n- Utilizes onlyOwner for critical functions to mitigate unauthorized access and potential vulnerabilities in contract management.\n- Includes sale state flags (isAllowListActive, saleIsActive) to control minting operations and prevent unauthorized minting outside of designated sale periods.\n- Implements checks in minting functions to prevent exceeding the maximum supply, ensuring scarcity and integrity of the collection.\n- Employs checks for Ether value sent in minting transactions to match the required price, protecting against underpayment.\n"}, {"role": "assistant", "content": "\ncontract TattooSkullzSociety is ERC721, ERC721Enumerable, Ownable {\n    string public PROVENANCE;\n    string private _baseURIextended;\n\n    bool public isAllowListActive = false;\n    bool public saleIsActive = false;\n    \n    uint256 public constant MAX_SUPPLY = 5000;\n    uint256 public constant MAX_PUBLIC_MINT = 22;\n    uint256 public constant RESERVE_MINT = 222;\n    uint256 public constant PRICE_PER_TOKEN = 0.08 ether;\n\n    mapping(address => uint8) private _allowList;\n\n    constructor() ERC721(\"TattooSkullzSociety\", \"SKULLZ\") {}\n\n    // Whitelist\n    function setIsAllowListActive(bool _isAllowListActive) external onlyOwner {\n        isAllowListActive = _isAllowListActive;\n    }\n\n    function setAllowList(address[] calldata addresses, uint8 numAllowedToMint) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            _allowList[addresses[i]] = numAllowedToMint;\n        }\n    }\n\n    function numAvailableToMint(address addr) external view returns (uint8) {\n        return _allowList[addr];\n    }\n\n    function mintAllowList(uint8 numberOfTokens) external payable {\n        uint256 ts = totalSupply();\n        require(isAllowListActive, \"Allow list is not active\");\n        require(numberOfTokens <= _allowList[msg.sender], \"Exceeded max available to purchase\");\n        require(numberOfTokens <= MAX_PUBLIC_MINT, \"Exceeded max token purchase\");\n        require(ts + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max tokens\");\n        require(PRICE_PER_TOKEN * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n\n        _allowList[msg.sender] -= numberOfTokens;\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, ts + i);\n        }\n    }\n\n    function setSaleState(bool newState) public onlyOwner {\n        saleIsActive = newState;\n    }\n\n    function mint(uint numberOfTokens) public payable {\n        uint256 ts = totalSupply();\n        require(saleIsActive, \"Sale must be active to mint tokens\");\n        require(numberOfTokens <= MAX_PUBLIC_MINT, \"Exceeded max token purchase\");\n        require(ts + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max tokens\");\n        require(PRICE_PER_TOKEN * numberOfTokens <= msg.value, \"Ether value sent is not correct\");\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, ts + i);\n        }\n    }\n\n    function reserve(uint numberOfTokens) public onlyOwner {\n      uint supply = totalSupply();\n      uint i;\n      for (i = 0; i < numberOfTokens; i++) {\n          _safeMint(msg.sender, supply + i);\n      }\n    }\n\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function setProvenance(string memory provenance) public onlyOwner {\n        PROVENANCE = provenance;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\n        _baseURIextended = baseURI_;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ERC721PresetMinterPauserAutoId smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Design an ERC721 token contract, ERC721PresetMinterPauserAutoId, incorporating automatic token ID assignment, minting authorization, and pausable transfers. This advanced template extends the standard ERC721 token capabilities, integrating AccessControl for role management. It provides mechanisms for minting new tokens with sequential IDs, pausing/unpausing token transfers for emergency or administrative reasons, and controlling token URI base setting with restrictions.\n\nContract Specifications:\n- Inherits from ERC721Enumerable, ERC721Burnable, ERC721Pausable, and AccessControlEnumerable for a rich set of features including token enumeration, burnability, pausability, and role-based access control.\n- Utilizes Counters to maintain a sequential token ID tracker, ensuring unique and incrementing identifiers for each minted token.\n- Defines MINTER_ROLE and PAUSER_ROLE to restrict minting and pausing capabilities to authorized accounts.\n- Implements a limit on the number of times the base token URI can be reset, enhancing security and predictability of token metadata.\n\nKey Functionalities:\n1. Role-based Permissions: Enforces that only accounts with specific roles can mint new tokens, pause or unpause the contract.\n2. Sequential Token IDs: Automatically assigns token IDs in a sequential manner, mitigating the risk of collision or gaps due to token burning.\n3. Pausable Transfers: Allows the contract to halt all token transfers in the case of an emergency or need for administrative intervention.\n4. Limited URI Resets: Provides the functionality to set and reset the base token URI, with a strict limit on the number of resets to prevent abuse.\n5. Comprehensive Interface Support: Guarantees compatibility with a wide array of ERC standards and interfaces through meticulous implementation of supportsInterface.\n\nImplementation Details:\n- The constructor initializes the contract with given name and symbol, and assigns the deploying account (_msgSender()) all roles necessary for administration.\n- The setBaseURI function updates the base URI for token metadata, constrained by a maximum number of allowed resets to maintain integrity.\n- Minting is streamlined through the mint function, which ensures that the minter has the appropriate role and increments the token ID counter upon each call.\n- Pausing and unpausing token transfers is managed through pause and unpause functions, respectively, each guarded by the PAUSER_ROLE.\n- Overrides _beforeTokenTransfer and supportsInterface to integrate the functionalities of its parent contracts effectively, ensuring that token transfers adhere to the pausable conditions and that the contract accurately reports its supported interfaces.\n\nSecurity Considerations:\n- Role-based access control is employed to safeguard against unauthorized minting, URI resets, and changes to the contract's operational state.\n- The use of a counter for token IDs prevents errors or vulnerabilities associated with manual ID assignment.\n- The pausability feature offers a mechanism to respond to security threats by freezing token transfers until the issue is resolved.\n- Limitations on the number of times the base URI can be reset protect against potential manipulation or confusion regarding token metadata locations.\n"}, {"role": "assistant", "content": "\ncontract ERC721PresetMinterPauserAutoId is Context, AccessControlEnumerable, ERC721Enumerable, ERC721Burnable, ERC721Pausable {\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    Counters.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n    \n    uint8 private constant MAX_URI_RESETS_ALLOWED = 1;\n    uint8 public uriResetCount = 0;\n\n    // Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the account that deploys the contract.\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n    \n    \n    // Sets `_baseTokenURI`. Resets allowed only `MAX_URI_RESETS_ALLOWED` no of times\n    function setBaseURI(string memory baseTokenURI) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"You don't have permission to do this.\");\n        require(uriResetCount <= MAX_URI_RESETS_ALLOWED, \"Max resets allowed is breached now\");\n        _baseTokenURI = baseTokenURI;\n        uriResetCount++;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    // Creates a new token for `to`. Its token ID will be automatically assigned (and available on the emitted {IERC721-Transfer} event), and the token URI autogenerated based on the base URI passed at construction.\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    // Pauses all token transfers.\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    //  Unpauses all token transfers.\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Wallstreetbets smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Design an ERC20 token contract named Wallstreetbets, focusing on the theme of stocks and options trading within the cryptocurrency space. This contract includes advanced features like token burning and ownership transfer, adhering strictly to the ERC20 standard. It utilizes SafeMath for all arithmetic operations to prevent overflow and underflow vulnerabilities.\n\nContract Specifications:\n- Implements the ERC20 token standard with additional functionalities.\n- Sets a fixed total supply of 65 million tokens, factoring in 18 decimal places for precision.\n- Includes a modifier to restrict certain functions to the contract owner only.\n- Employs SafeMath library for safe arithmetic operations.\n\nKey Functionalities:\n1. Token Ownership: Initially assigns the entire token supply to the contract creator, marking them as the owner.\n2. Token Burning: Allows the owner to reduce the total supply by permanently destroying a specified amount of tokens.\n3. Transfer Ownership: Enables the current owner to transfer ownership of the contract to a new address, along with the balance associated with the owner's account.\n4. ERC20 Compliance: Supports standard functions such as balanceOf, transfer, transferFrom, approve, and allowance to interact with token balances and allowances.\n5. Safety Measures: Integrates the SafeMath library for all mathematical operations to prevent common vulnerabilities in smart contracts.\n\nImplementation Details:\n- The constructor initializes the contract by setting the creator as the owner and allocating the entire token supply to them.\n- The burntokens function allows the owner to decrease the total supply, requiring the invocation by the current owner only.\n- Ownership transfer is facilitated through the transferOwnership function, transferring the owner's balance to the new owner and updating the owner address.\n- Standard ERC20 functions are implemented with additional checks to ensure the safety and integrity of transactions, such as non-zero addresses and sufficient balances.\n\nSecurity Considerations:\n- Utilizes the onlyOwner modifier to protect sensitive functions that could alter the contract's state or token distribution.\n- Incorporates the SafeMath library to guard against arithmetic overflow and underflow, enhancing contract security.\n- Enforces checks for zero addresses in token transfers and approvals to prevent loss of tokens and ensure transactions are intentional and valid.\n- Provides a mechanism for ownership transfer, ensuring continuity of contract management in the event of changes in ownership or control.\n"}, {"role": "assistant", "content": "\ncontract Wallstreetbets is ERC20 {\n    using SafeMath for uint256;\n    string public constant symbol = \"Wallstreetbets\";\n    string public constant name = \"Wallstreetbets stocks and Options trading\";\n    uint public constant decimals = 18;\n    uint256 _totalSupply = 65999999 * 10 ** 18; // 65 million Total Supply including 18 decimal\n\n    // Owner of this contract\n    address public owner;\n     \n    // Balances for each account\n    mapping(address => uint256) balances;\n\n    // Owner of account approves the transfer of an amount to another account\n    mapping(address => mapping (address => uint256)) allowed;\n\n    // Functions with this modifier can only be executed by the owner\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    // Constructor\n    constructor () public {\n        owner = msg.sender;\n        balances[owner] = _totalSupply;\n        emit Transfer(0, owner, _totalSupply);\n    }\n    \n    function burntokens(uint256 tokens) public onlyOwner {\n        _totalSupply = (_totalSupply).sub(tokens);\n    }\n\n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalSupply;\n    }\n    function balanceOf(address _owner)public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount)public returns (bool ok) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n         \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount )public returns (bool ok) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    function approve(address _spender, uint256 _amount)public returns (bool ok) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n     }\n  \n    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n        \n     // In case the ownership needs to be transferred\n\tfunction transferOwnership(address newOwner) external onlyOwner\t{\n\t    uint256 x = balances[owner];\n\t    require( newOwner != 0x0);\n\t    balances[newOwner] = (balances[newOwner]).add(balances[owner]);\n\t    balances[owner] = 0;\n\t    owner = newOwner;\n\t    emit Transfer(msg.sender, newOwner, x);\n\t}\n}\n"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a ChubbyCherubs smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create an ERC721 token smart contract named ChubbyCherubs that manages a limited collection of unique digital assets. This contract includes functionality for minting tokens up to a capped maximum, setting and updating the base token URI for metadata, toggling the sale state, withdrawing contract funds, and airdropping tokens to specific addresses. It emphasizes owner control for critical operations and integrates a public sale mechanism with price setting.\n\nContract Specifications:\n- Inherits ERC721 standards for NFT functionality and Ownable for ownership management.\n- Sets a fixed cap (MAX_CHUB) of 1111 tokens to maintain exclusivity.\n- Implements a variable token price, initially set to 0.07 Ether, adjustable by the owner.\n- Incorporates a switch to open or close the token sale, allowing for phased release.\n- Tracks the total number of minted tokens to prevent exceeding the maximum supply.\n\nKey Functionalities:\n1. Initialization and Base URI Management:\n    - Initialize the contract with a base token URI.\n    - Provide an onlyOwner function to update the base URI as needed.\n2. Minting Price and Sale State:\n    - Allow the contract owner to set and adjust the minting price.\n    - Implement a function to toggle the sale's open/closed state, enabling or disabling public minting.\n3. Public Minting Functionality:\n    - Enable users to mint a specified number of tokens within set limits per transaction, provided the sale is open and the maximum supply has not been reached.\n    - Charge the correct amount of Ether for the number of tokens minted and enforce a maximum mint limit per transaction for non-owner minters.\n4. Airdrop Functionality:\n    - Offer an onlyOwner function to airdrop tokens to a list of addresses, ensuring the operation does not exceed the maximum supply or mint tokens to the null address.\n5. Withdrawal of Contract Funds:\n    - Implement an onlyOwner function to withdraw all Ether collected by the contract through minting operations.\n\nImplementation Details:\n- The constructor sets the initial base URI for token metadata, essential for linking each token to its digital asset.\n- setBaseURI and setPrice functions allow the owner to update metadata pathways and token price, reflecting operational flexibility.\n- flipSaleState toggles the sale's active status, enabling or disabling public minting.\n- The mint function includes checks for sale status, minting limits per transaction, total supply constraints, and correct Ether values for transactions not initiated by the owner.\n- Utilizes an internal handleMint function to abstract the minting process, streamlining the creation of tokens and emission of events upon minting.\n\nSecurity Considerations:\n- Adheres to the onlyOwner modifier for administrative actions, mitigating unauthorized alterations to the contract's critical parameters.\n- Ensures that minting cannot exceed the defined maximum supply, preserving the collection's exclusivity and integrity.\n- Protects against sending Ether to the contract inadvertently through controlled sale mechanisms and validated fund withdrawals.\n- Incorporates checks for non-zero addresses in minting and airdropping functions to prevent loss of tokens.\n"}, {"role": "assistant", "content": "\ncontract ChubbyCherubs is ERC721, Ownable {\n    uint256 private mintCount = 0;\n\n    uint256 public constant MAX_CHUB = 1111;\n    uint256 public price = 70000000000000000; //0.07 Ether\n    string baseTokenURI;\n    bool public saleOpen;\n\n    event ChubMinted(uint256 totalMinted);\n\n    constructor(string memory baseURI) ERC721(\"Chubby Cherubs\", \"CHUB\") {\n        setBaseURI(baseURI);\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        baseTokenURI = baseURI;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return mintCount;\n    }\n\n    function setPrice(uint256 _newPrice) external onlyOwner {\n        price = _newPrice;\n    }\n\n    // Close sale if open, open sale if closed\n    function flipSaleState() external onlyOwner {\n        saleOpen = !saleOpen;\n    }\n\n    function withdrawAll() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function airdrop(address[] calldata _recipients) external onlyOwner {\n        uint256 supply = totalSupply();\n        require(\n            supply + _recipients.length <= MAX_CHUB,\n            \"Airdrop will exceed maximum supply of CHUB\"\n        );\n        require(_recipients.length != 0, \"Address not found\");\n        mintCount += _recipients.length;\n        for (uint256 i = 0; i < _recipients.length; i++) {\n            require(_recipients[i] != address(0), \"Airdrop to Null address\");\n            handleMint(_recipients[i], ++supply);\n        }\n    }\n\n    function mint(uint256 _count) external payable {\n        uint256 supply = totalSupply();\n        require(supply + _count <= MAX_CHUB, \"Exceeds maximum supply of CHUB\");\n        require(_count > 0, \"Minimum 1 CHUB has to be minted per transaction\");\n\n        if (msg.sender != owner()) {\n            require(saleOpen, \"Sale is not open yet\");\n            require(\n                _count <= 10,\n                \"Maximum 10 Chubby Cherubs can be minted per transaction\"\n            );\n            require(\n                msg.value >= price * _count,\n                \"Ether sent with this transaction is not correct\"\n            );\n        }\n\n        mintCount += _count;\n\n        for (uint256 i = 0; i < _count; i++) {\n            handleMint(msg.sender, ++supply);\n        }\n    }\n\n    function handleMint(address _to, uint256 tokenId) private {\n        _safeMint(_to, tokenId);\n        emit ChubMinted(tokenId);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n}\n"}]}
