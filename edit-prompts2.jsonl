[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Molokiwie smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create an Ethereum-based NFT minting smart contract named Molokiwie that adheres to the ERC721Enumerable and Ownable standards. This contract allows the owner to mint unique digital assets, manage minting costs, toggle the minting process on or off, and set metadata URIs for individual tokens and the contract itself. Additionally, the contract should enable the withdrawal of funds accumulated through minting operations.\n\nContract Specifications:\n- Inherits ERC721Enumerable for NFT enumeration and Ownable for ownership management.\n- Implements features such as minting control, dynamic pricing, and metadata management.\n- Utilizes Ethereum's native currency (ETH) for transactions.\n\nKey Functionalities:\n1. Minting Control: Allows the contract owner to enable or disable the NFT minting function to control the supply.\n2. Dynamic Pricing: The owner can adjust the cost per NFT minted to respond to market demands or strategic pricing adjustments.\n3. Metadata Management: Enables setting and updating the base URI for token metadata and the contract's metadata, facilitating dynamic content management.\n4. Funds Withdrawal: Allows the contract owner to withdraw the balance accumulated from minting fees, ensuring secure and exclusive access to the funds.\n\nImplementation Details:\n- Minting Process: The mint function enables users to mint a specified number of NFTs given they meet the prerequisites, such as minting being enabled, the minimum quantity requirement, and sufficient ETH to cover the cost.\n- Access Control: Utilizes the onlyOwner modifier from the Ownable contract to restrict certain functions, like pausing minting, setting costs, and withdrawing funds, to the contract owner.\n- Metadata URIs: The contract stores separate URIs for token metadata and contract metadata, which can be updated by the owner, providing flexibility in managing how NFTs and the contract are presented externally.\n- Error Handling: Implements checks and requires statements to validate function calls, ensuring operations like minting and withdrawing funds are executed under defined conditions.\n\nSecurity Considerations:\n- Reentrancy Guard: Consider implementing reentrancy guards for functions that transfer ETH to prevent reentrancy attacks.\n- Validation Checks: Ensure all user inputs and state-changing operations are correctly validated (e.g., mint amount, ETH sent for minting) to prevent exploits.\n- Access Control: The onlyOwner modifier is crucial for functions that could impact the contract's integrity and financial state. It's essential to ensure the ownership is securely managed.\n"}, {"role": "assistant", "content": "\ncontract Molokiwie is ERC721Enumerable, Ownable { \n    uint256 public cost;\n    bool public paused;\n    string public tokenURIPrefix;\n    string public contractURIPrefix;\n\n    constructor() ERC721(\"MOLOKIWIE\", \"MOLOKIWIE\") {\n        pause(false);\n        setCost(20000000 gwei); //0.02 eth\n        setTokenURI(\"https://gateway.pinata.cloud/ipfs/QmPhtzrqnJ6ozr98JbVxWvac4anj6ViQeaCwTHBuAYmQU3\");\n        setContractURI(\"https://gateway.pinata.cloud/ipfs/QmR6cvG9F35yRKRn8QPfRX8cGhm3Ez27E3Z7uEu1jdTBVt\");\n    }\n\n    function mint(uint256 _mintAmount) public payable {\n        require(canMint(_mintAmount, msg.value), \"Can't mint\");\n        uint256 supply = totalSupply();\n        for (uint i; i < _mintAmount; ++i ) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    function setCost(uint256 _newCost) public onlyOwner {\n        cost = _newCost;\n    }\n\n    function canMint(uint256 _mintAmount, uint256 ethValue) public view returns (bool) {\n        require(!paused, \"Minting is paused\");\n        require(_mintAmount > 0, \"Need to mint at least 1 NFT\");\n        require(ethValue >= cost * _mintAmount, \"Insufficient funds\");\n        \n        return true;\n    }\n\n    function setTokenURI(string memory _tokenURIPrefix) public onlyOwner {\n        tokenURIPrefix = _tokenURIPrefix;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n        return tokenURIPrefix;\n    }\n\n    function setContractURI(string memory _contractURIPrefix) public onlyOwner {\n        contractURIPrefix = _contractURIPrefix;\n    }\n\n    function contractURI() public view returns (string memory) {\n        return contractURIPrefix;\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(os, \"Can't withdraw\");\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a TWOToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract named TWOToken implementing the ERC20Interface, along with an ownership management system through OwnerHelper. The contract introduces a custom token with features like token locking/unlocking for addresses, transfer restrictions, and mechanisms for the initial distribution of tokens to a founder. Additionally, it provides functions for token locking management and the ability to permanently destroy the contract.\n\nContract Specifications:\n- Implements ERC20 standard functionalities for token management.\n- Incorporates OwnerHelper for ownership-related actions.\n- Utilizes SafeMath for secure mathematical operations.\n- Features include token lock management, address whitelisting, and ERC20 standard operations.\n\nKey Functionalities:\n1. Token Information: The contract stores token-related data such as name, decimals, and symbol, defining the token's basic characteristics.\n2. Ownership and Token Supply: Establishes a founder address receiving the initial total token supply and integrates ownership management for critical administrative functions.\n3. Locking Mechanism: Introduces a system to lock or unlock the token transfer capabilities for specific addresses, enhancing security and compliance.\n4. ERC20 Compliance: Implements standard ERC20 functions for token transfers, balance inquiries, allowances, and approval mechanisms, ensuring interoperability with the broader Ethereum ecosystem.\n\nImplementation Details\n- Initial Setup: During contract creation, initial token attributes are set, and the total supply is allocated to the founder's address.\n- Transfer Restrictions: Incorporates a notLocked modifier to check if tokens are transferable by the sender, applying various conditions including owner privileges and address-specific locking status.\n- Lock Management: Offers functions for the contract owner to lock or unlock addresses, enabling or disabling their ability to transfer tokens.\n- ERC20 Functions: Detailed implementation of transfer, approve, allowance, and transferFrom methods adhering to the ERC20 standard, with added checks for the locking status.\n- Destruction Capability: Allows the contract owner to permanently destroy the contract, sending all remaining funds to the owner's address.\n\nSecurity Considerations\n- SafeMath: Utilizes SafeMath library to prevent overflow and underflow vulnerabilities in arithmetic operations.\n- Ownership Controls: Critical actions like locking tokens, updating lock status, and contract destruction are guarded with onlyOwner checks to prevent unauthorized access.\n- Locking Mechanism: The token lock feature should be carefully managed to ensure it does not inadvertently hinder the token's liquidity and transferability among rightful holders.\n"}, {"role": "assistant", "content": "\ncontract TWOToken is ERC20Interface, OwnerHelper {\n    using SafeMath for uint;\n    \n    string public name;\n    uint public decimals;\n    string public symbol;\n\n    // Founder\n    address private founder;\n    \n    // Total\n    uint public totalTokenSupply;\n\n    mapping (address => uint) public balances;\n    mapping (address => mapping ( address => uint )) public approvals;\n    mapping (address => bool) private whiteAddresses; // Lock : false, unLock : true\n    \n    bool public tokenLock = false;\n\n    // Token Total\n    uint constant private E18 = 1000000000000000000;\n\n    constructor(address _founder, uint _totalTokenSupply) public {\n        name = \"two#\";\n        decimals = 18;\n        symbol = \"TO1\";\n\n        founder = _founder;\n        totalTokenSupply  = _totalTokenSupply * E18;\n        balances[founder] = totalTokenSupply;\n        emit Transfer(0x0, founder, totalTokenSupply);\n    }\n\n    modifier notLocked {\n        require(isTransferable() == true);\n        _;\n    }\n\n    function lock(address who) onlyOwner public {\n        whiteAddresses[who] = false;\n    }\n    \n    function unlock(address who) onlyOwner public {\n        whiteAddresses[who] = true;\n    }\n    \n    function isLocked(address who) public view returns(bool) {\n        return whiteAddresses[who];\n    }\n\n    function totalSupply() view public returns (uint) {\n        return totalTokenSupply;\n    }\n    \n    function balanceOf(address _who) view public returns (uint) {\n        return balances[_who];\n    }\n    \n    function transfer(address _to, uint _value) notLocked public returns (bool) {\n        require(balances[msg.sender] >= _value);\n        \n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        \n        emit Transfer(msg.sender, _to, _value);\n        \n        return true;\n    }\n    \n    function approve(address _spender, uint _value) notLocked public returns (bool){\n        require(balances[msg.sender] >= _value);\n        \n        approvals[msg.sender][_spender] = _value;\n        \n        emit Approval(msg.sender, _spender, _value);\n        \n        return true; \n    }\n    \n    function allowance(address _owner, address _spender) view public returns (uint) {\n        return approvals[_owner][_spender];\n    }\n\n    function transferFrom(address _from, address _to, uint _value) notLocked public returns (bool) {\n        require(balances[_from] >= _value);\n        require(approvals[_from][msg.sender] >= _value);\n        \n        approvals[_from][msg.sender] = approvals[_from][msg.sender].sub(_value);\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to]  = balances[_to].add(_value);\n        \n        emit Transfer(_from, _to, _value);\n        \n        return true;\n    }\n        \n    function isTransferable() private view returns (bool) {\n        if (tokenLock == false) {\n            return true;\n        }\n        else {\n          if(msg.sender == owner) {\n            return true;\n          }\n\n          if (whiteAddresses[msg.sender]) // true is unLocked {\n              return true;\n          }\n        }\n        return false;\n    }\n    \n    function setTokenUnlock() onlyOwner public {\n        require(tokenLock == true);\n        \n        tokenLock = false;\n    }\n    \n    function setTokenLock() onlyOwner public {\n        require(tokenLock == false);\n        \n        tokenLock = true;\n    }\n    \n    function close() onlyOwner public {\n        selfdestruct(msg.sender);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a XappCoin smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop an Ethereum smart contract named XappCoin that implements the ERC20 standard and includes ownership management. The contract introduces a cryptocurrency called XappCoin (XAPP) with a fixed supply, mechanisms for distributing tokens through ICOs, airdrops, and developer allocations. It also features dynamic token pricing throughout various ICO phases, the ability to withdraw collected funds, and functions for distributing tokens to specific addresses.\n\nContract Specifications:\n- Inherits ERC20 for token functionality and Owned for ownership management.\n- Uses SafeMath for safe mathematical operations to prevent overflow.\n- Defines constants for token name (XappCoin), symbol (XAPP), and decimals (18).\n- Sets a fixed total supply of tokens and allocates percentages for ICO, airdrops, and developer incentives.\n- Implements ERC20 functions with additional checks and custom distribution logic.\n\nKey Functionalities:\n1. Fixed Supply & Allocation: Sets a fixed total supply with predefined allocations for ICO sales, airdrops, and developer incentives.\n2. ICO and Token Sale Mechanics: Details the distribution of tokens through various sale phases (presale, ICO1, ICO2, etc.) with specific start times and ETH-to-token conversion rates.\n3. Airdrop and Developer Distribution: Specialized functions to distribute tokens for airdrops and to developer addresses, controlling the flow and allocation of tokens.\n4. Token Pricing and Adjustments: Mechanisms to update the tokens-per-ETH rate dynamically based on the phase of the ICO.\n5. Withdrawal and Burn Functions: Allows the withdrawal of ETH collected during the sale and the burning of tokens to reduce the supply.\n\nImplementation Details:\n- Initial Setup: Upon deployment, the contract allocates the total supply among the ICO, airdrop, and developer addresses based on predefined percentages.\n- Distribution Flags and Times: Utilizes flags to mark the opening and closing of the ICO, alongside timestamps to manage different sale phases.\n- Dynamic Token Pricing: Adjusts token pricing for each phase of the ICO, allowing for flexible investment opportunities.\n- Custom Distribution Functions: Includes methods for distributing tokens to private sale participants, airdrop recipients, and developers, ensuring each group receives their allotted share.\n- Security Measures: Implements checks for transaction amounts, sale phases, and ensures functions can only be called by the owner or authorized addresses.\n\nSecurity Considerations:\n- SafeMath Usage: Ensures arithmetic operations are secure and free from overflows and underflows.\n- Ownership and Access Control: Critical functions are protected by ownership checks to prevent unauthorized access.\n- Validation of Contributions: Checks for minimum contributions and valid phases ensure that transactions are processed correctly.\n- Mitigation of Common Vulnerabilities: Includes protections against reentrancy, short address attacks, and ensures proper handling of ERC20 tokens.\n"}, {"role": "assistant", "content": "\ncontract XappCoin is ERC20, Owned {\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\t\t\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;    \n\n    string public constant name = \"XappCoin\";\n    string public constant symbol = \"XAPP\";\n    uint public constant decimals = 18;\n    \n    uint256 public totalSupply =  160000000000000000000000000;\n    uint256 public totalDistributed = 0; \n    uint256 public totalIcoDistributed = 0;\n    uint256 public constant minContribution = 1 ether / 100; // 0.01 Eth\n\t\n\t\n\tuint256 public tokensPerEth = 0;\n\t\n    // Token Distribution and Address\n    \n    // saleable 90%\n    uint256 public constant totalIco = 144000000000000000000000000;\n    uint256 public totalIcoDist = 0;\n    address storageIco = owner;\n\n    // airdrop 5%\n    uint256 public constant totalAirdrop = 8000000000000000000000000;\n    address private storageAirdrop = 0x9EF2b3c9D297342Cad1EEae796D1BE3e804A30F9;\n\n    // developer 5%\n    uint256 public constant totalDeveloper = 8000000000000000000000000;\n    address private storageDeveloper = 0x4E9084cB8B30CAD65f1210Ec7CCcED1F1a5F2D78;\n    \n    // sale start  price and bonus\n    \n    // presale\n\tuint public presaleStartTime = 1544979600; // Monday, 20 January 2020 00:00:00 GMT+07:00\n    uint256 public presalePerEth = 1000000000000000000000;\n    \n    // ico\n    uint public icoStartTime = 1546189200; // Thursday, 5 March 2020 00:00:00 GMT+07:00\n    uint256 public icoPerEth = 1000000000000000000000;\n    \n    // ico1\n    uint public ico1StartTime = 1547398800; // Sunday, 19 April 2020 00:00:00 GMT+07:00\n    uint256 public ico1PerEth = 1000000000000000000000;\n    \n    \n    // ico2\n    uint public ico2StartTime = 1548608400; // Wednesday, 3 June 2020 00:00:00 GMT+07:00\n    uint256 public ico2PerEth = 1000000000000000000000;\n    \n    \n    //ico start and end\n    uint public icoOpenTime = presaleStartTime;\n    uint public icoEndTime = 1610298000; // Thursday, 9 July 2019 00:00:00 GMT+07:00\n\t\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n    \n    event Burn(address indexed burner, uint256 value);\n\t\n\tevent Sent(address from, address to, uint amount);\n\t\n    bool public icoOpen = false; \n    bool public icoFinished = false;\n    bool public distributionFinished = false;\n\n    uint256 public tTokenPerEth = 0;\n    uint256 public tAmount = 0;\n    uint i = 0;\n    bool private tIcoOpen = false;\n    \n    constructor() public {        \n        balances[owner] = totalIco;\n        balances[storageAirdrop] = totalAirdrop;\n        balances[storageDeveloper] = totalDeveloper;       \n    }\n    \n    function totalSupply() public constant returns (uint) {\n        return totalSupply  - balances[address(0)];\n    }\n\n    modifier canDistr() {\n        require(!distributionFinished);\n        _;\n    }\n\t\n\tfunction startDistribution() onlyOwner canDistr public returns (bool) {\n        icoOpen = true;\n        presaleStartTime = now;\n        icoOpenTime = now;\n        return true;\n    }\n    \n    function finishDistribution() onlyOwner canDistr public returns (bool) {\n        distributionFinished = true;\n        icoFinished = true;\n        emit DistrFinished();\n        return true;\n    }\n    \n    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n        totalDistributed = totalDistributed.add(_amount);        \n        balances[_to] = balances[_to].add(_amount);\n        balances[owner] = balances[owner].sub(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n\n        return true;\n    }\n\t\n\tfunction send(address receiver, uint amount) public {\n        if (balances[msg.sender] < amount) return;\n        balances[msg.sender] -= amount;\n        balances[receiver] += amount;\n        emit Sent(msg.sender, receiver, amount);\n    }\n    \n   \n    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        \n        tokensPerEth = _tokensPerEth;\n        emit TokensPerEthUpdated(_tokensPerEth);\n    }\n           \n    function () external payable {\n\t\t\t\t\n\t\t// owner withdraw \n\t\tif (msg.sender == owner && msg.value == 0) {\n\t\t\twithdraw();\n\t\t}\n\t\t\n\t\tif (msg.sender != owner){\n\t\t\tif ( now < icoOpenTime ){\n\t\t\t\trevert('ICO does not open yet');\n\t\t\t}\n\t\t\t\n\t\t\t//is Open\n\t\t\tif (( now >= icoOpenTime ) && ( now <= icoEndTime )) {\n\t\t\t\ticoOpen = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (now > icoEndTime) {\n\t\t\t\ticoOpen = false;\n\t\t\t\ticoFinished = true;\n\t\t\t\tdistributionFinished = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (icoFinished == true) {\n\t\t\t\trevert('ICO has finished');\n\t\t\t}\n\t\t\t\n\t\t\tif (distributionFinished == true) {\n\t\t\t\trevert('Token distribution has finished');\n\t\t\t}\n\t\t\t\n\t\t\tif (icoOpen == true ) {\n\t\t\t\tif (now >= presaleStartTime && now < icoStartTime){ tTokenPerEth = presalePerEth; }\n\t\t\t\tif (now >= icoStartTime && now < ico1StartTime){ tTokenPerEth = icoPerEth; }\n\t\t\t\tif (now >= ico1StartTime && now < ico2StartTime){ tTokenPerEth = ico1PerEth; }\n\t\t\t\tif (now >= ico2StartTime && now < icoEndTime){ tTokenPerEth = ico2PerEth; }\n\t\t\t\t\n\t\t\t\ttokensPerEth = tTokenPerEth;\t\t\t\t\n\t\t\t\tgetTokens();\n\t\t\t}\n\t\t}\n     }\n    \n    function getTokens() payable canDistr  public {\n        uint256 tokens = 0;\n\n        require( msg.value >= minContribution );\n        require( msg.value > 0 );\n        \n        tokens = tokensPerEth.mul(msg.value) / 1 ether;\n        address investor = msg.sender;\n        \n        if (icoFinished == true) {\n\t\t\trevert('ICO Has Finished');\n\t\t}\n        \n        if (balances[owner] < tokens){\n\t\t\trevert('Insufficient Token Balance or Sold Out.');\n\t\t}\n        \n        if (tokens < 0) {\n\t\t\trevert();\n\t\t}\n        \n        totalIcoDistributed += tokens;\n        \n        if (tokens > 0) {\n           distr(investor, tokens);           \n        }\n\n        if (totalIcoDistributed >= totalIco) {\n            distributionFinished = true;\n        }\n    }\n\t\n\t\n    function balanceOf(address _owner) constant public returns (uint256) {\n        return balances[_owner];\n    }\n\n    // mitigates the ERC20 short address attack\n    modifier onlyPayloadSize(uint size) {\n        assert(msg.data.length >= size + 4);\n        _;\n    }\n    \n    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n        \n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n\n        require(_to != address(0));\n        require(_amount <= balances[_from]);\n        require(_amount <= allowed[_from][msg.sender]);\n        \n        balances[_from] = balances[_from].sub(_amount);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    \n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        // mitigates the ERC20 spend/approval race condition\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n    \n    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n        AltcoinToken t = AltcoinToken(tokenAddress);\n        uint bal = t.balanceOf(who);\n        return bal;\n    }\n    \n    function withdraw() onlyOwner public {\n        address myAddress = this;\n        uint256 etherBalance = myAddress.balance;\n        owner.transfer(etherBalance);\n    }\n    \n    function burn(uint256 _amount) onlyOwner public {\n        balances[owner] = balances[owner].sub(_amount);\n        totalSupply = totalSupply.sub(_amount);\n        totalDistributed = totalDistributed.sub(_amount);\n        emit Burn(owner, _amount);\n    }\n    \n    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {\n        AltcoinToken token = AltcoinToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n    \n    function dist_privateSale(address _to, uint256 _amount) onlyOwner public {\n\t\t\n\t\trequire(_amount <= balances[owner]);\n\t\trequire(_amount > 0);\n\t\t\n\t\ttotalDistributed = totalDistributed.add(_amount);        \n        balances[_to] = balances[_to].add(_amount);\n        balances[owner] = balances[owner].sub(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        tAmount = 0;\n\t}\n\t\n\tfunction dist_airdrop(address _to, uint256 _amount) onlyOwner public {\t\t\n\t\trequire(_amount <= balances[storageAirdrop]);\n\t\trequire(_amount > 0);\n        balances[_to] = balances[_to].add(_amount);\n        balances[storageAirdrop] = balances[storageAirdrop].sub(_amount);\n        emit Airdrop(_to, _amount, balances[_to]);\n        emit Transfer(address(0), _to, _amount);\n\t}\n\t\n\tfunction dist_multiple_airdrop(address[] _participants, uint256 _amount) onlyOwner public {\n\t\ttAmount = 0;\n\t\t\n\t\tfor ( i = 0; i < _participants.length; i++){\n\t\t\ttAmount = tAmount.add(_amount);\n\t\t}\n\t\t\n\t\trequire(tAmount <= balances[storageAirdrop]);\n\t\t\n\t\tfor ( i = 0; i < _participants.length; i++){\n\t\t\tdist_airdrop(_participants[i], _amount);\n\t\t}\n\t\t\n\t\ttAmount = 0;\n\t}    \n    \n    function dist_developer(address _to, uint256 _amount) onlyOwner public {\n\t\trequire(_amount <= balances[storageDeveloper]);\n\t\trequire(_amount > 0);\n\t\tbalances[_to] = balances[_to].add(_amount);\n        balances[storageDeveloper] = balances[storageDeveloper].sub(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        tAmount = 0;\n\t}\n\t\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a FricaCoin smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract named FricaCoin, an ERC20 token with additional features supporting Pre-ICO, ICO phases, advisor allocations, and a mechanism to pause and resume the ICO. The contract includes a fixed total supply of tokens, distribution among various stakeholders (including a public sale, advisors, and charity), and stages to manage the lifecycle of the ICO.\n\nContract Specifications:\n- Inherits the ERC20 standard for token functionality.\n- Utilizes SafeMath for safe arithmetic operations.\n- Defines constants such as name (FricaCoin), symbol (FRI), and decimals (8).\n- Sets a fixed total supply and initial allocations for the owner, employees, advisors, charity, and ICO rounds.\n- Implements a stage-based system to manage the ICO process.\n\nKey Functionalities:\n1. Initial Token Allocation: Distributes the initial supply among the owner, advisors, charity, and reserves for ICO and Pre-ICO sales.\n2. ICO Stage Management: Controls the ICO process through stages, including not started, pre-ICO, ICO, paused, and ended.\n3. Advisor Allocation: Manages the distribution of tokens to advisors, including adding new advisors and transferring tokens.\n4. ICO Participation: Allows investors to participate in the ICO by sending ETH in exchange for FricaCoin tokens during the active sale phase.\n5. Pause and Resume ICO: Provides the owner with the ability to pause and resume the ICO to address any unforeseen issues.\n\nImplementation Details:\n- Stage Modifiers: Uses stage-specific modifiers to ensure functions are executed only at the appropriate times in the ICO lifecycle.\n- Ownership Checks: Includes ownership verification to secure sensitive functions like starting the ICO, pausing, and distributing tokens.\n- Token Distribution: Details functions for transferring tokens from the contract to participants, including public sale buyers and advisors.\n- ICO Timing and Caps: Sets specific start and end dates for the Pre-ICO and ICO phases, along with a maximum cap for public sale contributions.\n- Advisors Management: Facilitates the addition of advisors and tracks the distribution of tokens to these key stakeholders.\n\nSecurity Considerations:\n- SafeMath for Arithmetic: Ensures all arithmetic operations are safe from overflows and underflows, protecting the token's integrity.\n- Contract Ownership: Critical actions are restricted to the contract owner, preventing unauthorized access and modifications.\n- Stage Restrictions: Functions are gated by the current ICO stage, reducing the risk of inappropriate token minting or distribution.\n- Advisors Whitelisting: Advisors are managed through a mapping, with functions to add and verify their status, mitigating the risk of unauthorized token allocation.\n"}, {"role": "assistant", "content": "\ncontract FricaCoin is ERC20 { \n    using SafeMath for uint256;\n    string public constant name = \"FricaCoin\";\n\n    string public constant symbol = \"FRI\";\n    uint8 public constant decimals = 8;\n    uint public _totalsupply = 1000000000000 * 10 ** 8; // 1 trillion total supply // muliplies dues to decimal precision\n    address public owner; \n    uint256 no_of_tokens;\n    uint256 bonus_token;\n    uint256 total_token;\n    bool stopped = false;\n    uint256 public pre_startdate;\n    uint256 public ico1_startdate;\n    uint256 ico_first;\n    uint256 ico_second;\n    uint256 ico_third;\n    uint256 ico_fourth;\n    uint256 pre_enddate;\n  \n    uint256 public eth_received; // total ether received in the contract\n    uint256 maxCap_public = 250000000000 * 10 **8;  //  25% - 250 billion in Public Sale\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    mapping (address => bool) private Advisors;\n    \n    uint256 public advisorCount;\n\n    enum Stages {\n        NOTSTARTED,\n        PREICO,\n        ICO,\n        PAUSED,\n        ENDED\n    }\n    Stages public stage;\n    \n    modifier atStage(Stages _stage) {\n        if (stage != _stage)\n            // Contract not in expected state\n            revert();\n        _;\n    }\n    \n     modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    function FricaCoin() public {\n        owner = msg.sender;\n        balances[owner] = 50000000000 * 10 **8; // 5% - 50 billion to owner\n        stage = Stages.NOTSTARTED;\n        Transfer(0, owner, balances[owner]);\n        \n        uint256 _transfertoemployees = 140000000000 * 10 **8; // 14% - 140 billion to Employees Advisors Consultants & Partners\n        balances[0xa36eEa22131881BB0a8902A6b8bF4a2cbb9782BC] = _transfertoemployees;\n        Transfer(address(0), 0xa36eEa22131881BB0a8902A6b8bF4a2cbb9782BC, _transfertoemployees);\n        \n        uint256 _transfertofirstround = 260000000000 * 10 **8; // 26% - 260 billion to First Round & Bonus\n        balances[0x553015bc932FaCc0C60159b7503a58ef5806CA48] = _transfertofirstround;\n        Transfer(address(0), 0x553015bc932FaCc0C60159b7503a58ef5806CA48, _transfertofirstround);\n        \n        uint256 _transfertocharity = 50000000000 * 10 **8; // 5% - 50 billion to Charity and non-profit\n        balances[0x11Bfb0B5a901cbc5015EF924c39ac33e91Eb015a] = _transfertocharity;\n        Transfer(address(0), 0x11Bfb0B5a901cbc5015EF924c39ac33e91Eb015a, _transfertocharity);\n\n        uint256 _transfertosecondround = 250000000000 * 10 **8; // 25% - 250 billion to Second Round & Bonus\n        balances[0xaAA258C8dbf31De53Aa679F6b492569556e1c306] = _transfertosecondround;\n        Transfer(address(0), 0xaAA258C8dbf31De53Aa679F6b492569556e1c306, _transfertosecondround);\n    }\n  \n\n    function start_PREICO() public onlyOwner atStage(Stages.NOTSTARTED) {\n        stage = Stages.PREICO;\n        stopped = false;\n        balances[address(this)] =  maxCap_public;\n        pre_startdate = now;\n        pre_enddate = now + 16 days;\n        Transfer(0, address(this), balances[address(this)]);\n    }\n      \n    function start_ICO() public onlyOwner atStage(Stages.PREICO) {\n        require(now > pre_enddate || eth_received >= 1500 ether);\n        stage = Stages.ICO;\n        stopped = false;\n        ico1_startdate = now;\n        ico_first = now + 15 days;\n        ico_second = ico_first + 15 days;\n        ico_third = ico_second + 15 days;\n        ico_fourth = ico_third + 15 days;\n        Transfer(0, address(this), balances[address(this)]);\n    }\n    \n    function PauseICO() external onlyOwner {\n        stopped = true;\n    }\n\n    function ResumeICO() external onlyOwner {\n        stopped = false;\n    }\n    \n    function end_ICO() external onlyOwner atStage(Stages.ICO) {\n        require(now > ico_fourth);\n        stage = Stages.ENDED;\n        _totalsupply = (_totalsupply).sub(balances[address(this)]);\n        balances[address(this)] = 0;\n        Transfer(address(this), 0 , balances[address(this)]);\n        \n    }\n\n    function totalSupply() public view returns (uint256 total_Supply) {\n        total_Supply = _totalsupply;\n    }\n    \n    function balanceOf(address _owner)public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    \n    // Send _value amount of tokens from address _from to address _to\n    function transferFrom( address _from, address _to, uint256 _amount )public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n        balances[_from] = (balances[_from]).sub(_amount);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    function approve(address _spender, uint256 _amount)public returns (bool success) {\n        require( _spender != 0x0);\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n  \n    function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n        require( _owner != 0x0 && _spender !=0x0);\n        return allowed[_owner][_spender];\n    }\n\n     // Transfer the balance from owner's account to another account\n     function transfer(address _to, uint256 _amount)public returns (bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    // Transfer the balance from owner's account to another account\n    function transferTokens(address _to, uint256 _amount) private returns(bool success) {\n        require( _to != 0x0);       \n        require(balances[address(this)] >= _amount && _amount > 0);\n        balances[address(this)] = (balances[address(this)]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(address(this), _to, _amount);\n        return true;\n    }\n \n    // Transfer the balance from owner's account to advisor's account\n    function transferToAdvisors(address _to, uint256 _amount) public returns(bool success) {\n        require( _to != 0x0);\n        require(balances[msg.sender] >= _amount && _amount >= 0);\n        \n        if(!isAdvisor(_to)) {\n          addAdvisor(_to);\n          advisorCount++ ;\n        }\n\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n        balances[_to] = (balances[_to]).add(_amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n \n    function addAdvisor(address _advisor) public {\n        Advisors[_advisor]=true;\n    }\n\n    function isAdvisor(address _advisor) public returns(bool success){\n        return Advisors[_advisor];\n        return true;\n    }\n    \n    function drain() external onlyOwner {\n        owner.transfer(this.balance);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a GenF smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Design a smart contract named GenF that combines the ERC721A token standard with unique features for a digital asset launch. This contract manages a collection with a Dutch auction for public sale, a whitelist for presale, and admin functions for managing the sale's parameters. It also includes provenance data for the collection's authenticity, Merkle proof verification for whitelist eligibility, and withdrawal functionality for collecting funds.\n\nContract Specifications:\n- Inherits ERC721A for efficient batch minting and Ownable for administrative control.\n- Manages a digital asset collection with a fixed supply, dynamic pricing for public sale, and restricted access for presale.\n- Utilizes a Merkle tree for verifying whitelist participants and their allocations.\n- Implements a Dutch auction mechanism for determining the sale price over time.\n\nKey Functionalities:\n1. Whitelist and Presale Management: Allows participants with verified Merkle proofs to mint tokens at a preset price before the public sale.\n2. Dutch Auction for Public Sale: Dynamically adjusts the minting price based on the elapsed time from the start of the sale.\n3. Provenance Record: Maintains a provenance hash to ensure the collection's authenticity and integrity.\n4. Admin Control: Includes functions for the owner to adjust sale parameters, manage the whitelist, and set collection metadata.\n\nImplementation Details:\n- Minting Restrictions: Enforces rules for minting during the presale and public sale, including checks for start times, allocation limits, and payment amounts.\n- Pricing Calculation: The Dutch auction pricing is calculated based on the current time, with the price decreasing at specified intervals until a floor price is reached.\n- Whitelist Verification: Utilizes a Merkle tree for efficient and secure verification of presale participants and their minting allocation.\n- Funds Withdrawal: Provides a function for the owner to withdraw accumulated funds to a specified recipient address.\n\nSecurity Considerations:\n- Ownership and Access Control: Uses the Ownable modifier to protect critical functions that could alter the contract's operational parameters or withdraw funds.\n- Minting Validation: Ensures that minting cannot occur before the sale starts, exceeds allocation limits, or surpasses the collection's maximum supply.\n- Pricing Integrity: The Dutch auction mechanism requires careful implementation to prevent manipulation or errors in pricing calculations.\n"}, {"role": "assistant", "content": "\ncontract GenF is ERC721A, Ownable {\n    string public PROVENANCE;\n\n    bytes32 public merkleRoot = \"\"; // Construct this from (address, amount) tuple elements\n    mapping(address => uint) public whitelistRemaining; // Maps user address to their remaining mints if they have minted some but not all of their allocation\n    mapping(address => bool) public whitelistUsed; // Maps user address to bool, true if user has minted\n\n    uint public presaleMintPrice;\n    uint public dutchAuctionStart;\n    uint public dutchAuctionEnd = 0.025 ether;\n    uint public dutchAuctionIncrement = 0.025 ether;\n    uint public dutchAuctionStepTime = 300; // 5 minutes\n    uint public maxItems = 10000;\n    uint public maxItemsPerTx = 10;\n    address public recipient;\n    string public _baseTokenURI;\n    uint public startTimestamp;\n\n    event Mint(address indexed owner, uint indexed tokenId);\n\n    constructor(address _owner) ERC721A(\"Gen-F\", \"GENF\", 200) {\n        require(_owner != address(0x0), \"Set owner\");\n        transferOwnership(_owner);\n    }\n\n    modifier mintingOpen() {\n        require(startTimestamp != 0, \"Start timestamp not set\");\n        require(block.timestamp >= startTimestamp, \"Not open yet\");\n        _;\n    }\n\n    function dutchAuctionPrice() public view returns (uint) {\n        if (startTimestamp == 0 || block.timestamp <= startTimestamp) {\n            return dutchAuctionStart;\n        } else {\n            uint increments = (block.timestamp - startTimestamp) / dutchAuctionStepTime;\n            if (increments * dutchAuctionIncrement >= dutchAuctionStart) {\n                return dutchAuctionEnd;\n            } else {\n                return dutchAuctionStart - (increments * dutchAuctionIncrement);\n            }\n        }\n    }\n\n    function ownerMint(uint amount) external onlyOwner {\n        _mintWithoutValidation(msg.sender, amount, true);\n    }\n\n    function publicMint(uint amount) external payable mintingOpen {\n        // Require nonzero amount\n        require(amount > 0, \"Can't mint zero\");\n\n        // Check proper amount sent\n        require(msg.value == amount * dutchAuctionPrice(), \"Send proper ETH amount\");\n\n        _mintWithoutValidation(msg.sender, amount, false);\n    }\n\n    function whitelistMint(uint amount, uint totalAllocation, bytes32 leaf, bytes32[] memory proof) external payable {\n        // Create storage element tracking user mints if this is the first mint for them\n        if (!whitelistUsed[msg.sender]) {        \n            // Verify that (msg.sender, amount) correspond to Merkle leaf\n            require(keccak256(abi.encodePacked(msg.sender, totalAllocation)) == leaf, \"Sender and amount don't match Merkle leaf\");\n\n            // Verify that (leaf, proof) matches the Merkle root\n            require(verify(merkleRoot, leaf, proof), \"Not a valid leaf in the Merkle tree\");\n\n            whitelistUsed[msg.sender] = true;\n            whitelistRemaining[msg.sender] = totalAllocation;\n        }\n\n        // Require nonzero amount\n        require(amount > 0, \"Can't mint zero\");\n\n        // Check proper amount sent\n        require(msg.value == amount * presaleMintPrice, \"Send proper ETH amount\");\n\n        require(whitelistRemaining[msg.sender] >= amount, \"Can't mint more than remaining allocation\");\n\n        whitelistRemaining[msg.sender] -= amount;\n        _mintWithoutValidation(msg.sender, amount, false);\n    }\n\n    function _mintWithoutValidation(address to, uint amount, bool skipMaxItems) internal {\n        uint _totalSupply = totalSupply(); // Cache variable after reading from storage\n        require(_totalSupply + amount <= maxItems, \"mintWithoutValidation: Sold out\");\n        require(skipMaxItems || amount <= maxItemsPerTx, \"mintWithoutValidation: Surpasses maxItemsPerTx\");\n        _safeMint(to, amount);\n    }\n\n    function verify(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\n        return MerkleProof.verify(proof, root, leaf);\n    }\n\n    function setProvenance(string memory provenance) public onlyOwner {\n        PROVENANCE = provenance;\n    }\n\n    function setPresaleMintPrice(uint _presaleMintPrice) external onlyOwner {\n        presaleMintPrice = _presaleMintPrice;\n    }\n\n    function setDutchAuctionStart(uint _dutchAuctionStart) external onlyOwner {\n        dutchAuctionStart = _dutchAuctionStart;\n    }\n\n    function setDutchAuctionEnd(uint _dutchAuctionEnd) external onlyOwner {\n        dutchAuctionEnd = _dutchAuctionEnd;\n    }\n\n    function setDutchAuctionIncrement(uint _dutchAuctionIncrement) external onlyOwner {\n        dutchAuctionIncrement = _dutchAuctionIncrement;\n    }\n\n    function setDutchAuctionStepTime(uint _dutchAuctionStepTime) external onlyOwner {\n        dutchAuctionStepTime = _dutchAuctionStepTime;\n    }\n\n    function setMaxItems(uint _maxItems) external onlyOwner {\n        maxItems = _maxItems;\n    }\n\n    function setMaxItemsPerTx(uint _maxItemsPerTx) external onlyOwner {\n        maxItemsPerTx = _maxItemsPerTx;\n    }\n\n    function setRecipient(address _recipient) external onlyOwner {\n        recipient = _recipient;\n    }\n\n    function setStartTimestamp(uint _startTimestamp) external onlyOwner {\n        startTimestamp = _startTimestamp;\n    }\n\n    function setBaseTokenURI(string memory __baseTokenURI) public onlyOwner {\n        _baseTokenURI = __baseTokenURI;\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    // Withdraw the contract balance to the recipient address\n    function withdraw() external {\n        require(recipient != address(0x0), \"Set recipient first\");\n        uint amount = address(this).balance;\n        (bool success,) = recipient.call{value: amount}(\"\");\n        require(success, \"Failed to send ether\");\n    }\n\n    // Returns a URI for a given token ID's metadata\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n        return string(abi.encodePacked(_baseTokenURI, Strings.toString(_tokenId)));\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Adet smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a comprehensive smart contract named Adet that incorporates the ERC20 standard functionalities with additional features like burning, freezing, and unfreezing of tokens. This contract is designed to support the digital economy of Australia, represented by the token name \"Australia Digital Economy Token\" (ADET), with precision up to 6 decimal places. The contract includes mechanisms to reduce the total supply through burning, restrict token transfers by freezing tokens, and manage token ownership and permissions comprehensively.\n\nContract Specifications:\n- Inherits from Owned, SafeMath, and Pausable to utilize ownership management, safe arithmetic operations, and pausing functionality.\n- Implements the EIP20Interface for standard ERC20 token operations.\n- Introduces additional features for burning tokens to reduce the total supply, and freezing/unfreezing tokens to control token liquidity and transferability.\n\nKey Functionalities:\n1. Token Basics: Establishes token properties including name (\"Australia Digital Economy\"), symbol (\"ADET\"), decimals (6), and an initial total supply of 2.8 billion tokens.\n2. Burning Tokens: Allows the owner to permanently remove tokens from the total supply, reducing the number of tokens in circulation.\n3. Freezing and Unfreezing Tokens: Enables the contract owner to freeze tokens for a specified address, preventing those tokens from being transferred until they are unfrozen.\n4. ERC20 Compliance: Fully supports standard ERC20 functions such as balance queries, transfers, and approvals, ensuring compatibility with the broader Ethereum ecosystem.\n5. Pause Functionality: Incorporates the ability to pause and unpause token transfers, providing emergency controls to address potential issues.\n\nImplementation Details:\n- SafeMath for Arithmetic: Utilizes the SafeMath library to prevent overflow and underflow vulnerabilities in arithmetic operations.\n- Ownership and Access Control: Leverages the Owned contract to manage ownership-specific actions, such as burning and freezing tokens.\n- Pausable Transfers: Ensures that token transfers can be paused or unpaused by the owner, enhancing security and operational control.\n- Freeze and Unfreeze Mechanics: Details the process for freezing tokens, including reducing the available balance and tracking frozen amounts, and similarly for unfreezing.\n\nSecurity Considerations:\n- Role-Based Features: Restricts sensitive actions like burning and freezing tokens to the contract owner, preventing unauthorized use.\n- Input Validations: Includes checks for zero addresses, sufficient balances, and non-negative transaction values to ensure robustness and security.\n- Pause Control: Offers a mechanism to stop all token transfers in the event of a security concern or during contract upgrades, minimizing potential risks.\n"}, {"role": "assistant", "content": "\ncontract Adet is Owned, SafeMath, Pausable, EIP20Interface {\n    uint256 private totalSupply_;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    \n    mapping (address => uint256) public balances;\n    mapping (address => uint256) public frozen;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    event Freeze(address indexed from, uint256 value);\n    event Unfreeze(address indexed from, uint256 value);\n    event Burned(address indexed from, uint256 value);\n\n    constructor() public {\n        name = \"Australia Digital Econmoy\";\n        symbol = \"ADET\";\n        decimals = 6;\n        totalSupply_ = 2800000000 * 10 ** uint256(decimals);\n        balances[msg.sender] = totalSupply_;\n    }\n\n    function burn(address _addr, uint256 _amount) onlyOwner public returns (bool success) {\n        require(_addr != 0);\n        require(_amount <= balances[_addr]);\n\n        totalSupply_ = sub(totalSupply_, _amount);\n        balances[_addr] = sub(balances[_addr], _amount);\n        emit Transfer(_addr, address(0), _amount);\n        emit Burned(_addr, _amount);\n        return true;\n    }\n\n    function freeze(address _addr, uint256 _value) public onlyOwner returns (bool success) {\n        require(balances[_addr] >= _value);\n        require(_value > 0);\n        balances[_addr] = sub(balances[_addr], _value);\n        frozen[_addr] = add(frozen[_addr], _value);\n        emit Freeze(_addr, _value);\n        return true;\n    }\n    \n    function unfreeze(address _addr, uint256 _value) public onlyOwner returns (bool success) {\n        require(frozen[_addr] >= _value);\n        require(_value > 0);\n        frozen[_addr] = sub(frozen[_addr], _value);\n        balances[_addr] = add(balances[_addr], _value);\n        emit Unfreeze(_addr, _value);\n        return true;\n    }\n\n    function frozenOf(address _addr) public view returns (uint256 balance) {\n        return frozen[_addr];\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    function balanceOf(address _addr) public view returns (uint256 balance) {\n        return balances[_addr];\n    }\n\n    function transfer(address _to, uint256 _value) public notPaused returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        require(balances[_to] + _value >= balances[_to]);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public notPaused returns (bool success) {\n        require(balances[_from] >= _value);\n        require(balances[_to] + _value >= balances[_to]);\n        require(allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public notPaused returns (bool success) {\n        require(_value > 0);\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    } \n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a Hypechill smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a smart contract named Hypechill utilizing the ERC20 standard, augmented with a fee on transactions to support operational or developmental costs. This contract introduces a transfer fee mechanism applied to token transfers, excluding designated fee-exempt accounts, to generate revenue or support specific financial strategies. It includes administrative functions to manage the fee structure and exempt accounts, ensuring flexibility and control over the tokenomics.\n\nContract Specifications:\n- Inherits ERC20 for token functionality and Ownable for administrative actions.\n- Sets an initial supply of 25,800 CHILL tokens, with 18 decimal places, during contract deployment.\n- Implements a mechanism to levy fees on transfers, expressed as a percentage of the transaction amount.\n\nKey Functionalities:\n1. Initial Token Supply: Mints an initial supply of CHILL tokens to the contract owner's address upon deployment.\n2. Transfer Fee Mechanism: Applies a fee to token transfers, directing the fee to a specified recipient account, which can be changed by the contract owner.\n3. Fee Management: Allows the contract owner to adjust the transfer fee percentage and activate or deactivate the fee mechanism as needed.\n4. Fee Exceptions: Provides the ability to exempt certain accounts from transfer fees, accommodating use cases like liquidity pools or partner addresses.\n5. Event Logging: Emits events for significant administrative actions, such as changing the transfer fee, updating the fee recipient, and modifying fee exceptions.\n\nImplementation Details:\n- Fee Calculation: Calculates the transfer fee based on a set percentage of the transaction amount, ensuring the recipient receives the amount minus the fee.\n- Exempt Accounts: Manages a mapping of accounts that are exempt from transfer fees, allowing for strategic partnerships or operational necessities.\n- Administrative Controls: Includes functions for the owner to update the transfer fee percentage, designate the fee recipient, and manage exemptions.\n\nSecurity Considerations:\n- Ownership Verification: Utilizes the onlyOwner modifier to restrict sensitive operations, such as adjusting fees or designating exempt accounts, to the contract owner.\n- Fee Limits: Ensures the transfer fee percentage does not exceed a maximum threshold to protect users from excessive deductions.\n- Safe Math Operations: Employs the SafeMath library for arithmetic operations to prevent overflow and underflow vulnerabilities.\n"}, {"role": "assistant", "content": "\ncontract Hypechill is ERC20, Ownable {\n    constructor() public ERC20(\"hypechill.finance\", \"CHILL\") { \n        // Mint 25,800 CHILL (18 Decimals)\n        _mint(msg.sender, 25800000000000000000000);\n    }\n\n    // Transfer Fee\n    event TransferFeeChanged(uint256 newFee);\n    event FeeRecipientChange(address account);\n    event AddFeeException(address account);\n    event RemoveFeeException(address account);\n\n    bool private activeFee;\n    uint256 public transferFee; // Fee as percentage\n    address public feeRecipient; \n\n    // Exception to transfer fees, for example for Uniswap contracts.\n    mapping (address => bool) public feeException;\n\n    function addFeeException(address account) public onlyOwner {\n        feeException[account] = true;\n        emit AddFeeException(account);\n    }\n\n    function removeFeeException(address account) public onlyOwner {\n        feeException[account] = false;\n        emit RemoveFeeException(account);\n    }\n\n    function setTransferFee(uint256 fee) public onlyOwner {\n        require(fee <= 2500, \"Fee cannot be greater than 25%\");\n        if (fee == 0) {\n            activeFee = false;\n        } else {\n            activeFee = true;\n        }\n        transferFee = fee;\n        emit TransferFeeChanged(fee);\n    }\n\n    function setTransferFeeRecipient(address account) public onlyOwner {\n        feeRecipient = account;\n        emit FeeRecipientChange(account);\n    }\n\n    // Transfer recipient recives amount - fee\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        if (activeFee && feeException[_msgSender()] == false) {\n            uint256 fee = transferFee.mul(amount).div(10000);\n            uint amountLessFee = amount.sub(fee);\n            _transfer(_msgSender(), recipient, amountLessFee);\n            _transfer(_msgSender(), feeRecipient, fee);\n        } else {\n            _transfer(_msgSender(), recipient, amount);\n        }\n\n        return true;\n    }\n\n    // TransferFrom recipient recives amount, sender's account is debited amount + fee\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        if (activeFee && feeException[recipient] == false) {\n            uint256 fee = transferFee.mul(amount).div(10000);\n            _transfer(sender, feeRecipient, fee);\n        }\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Onemizer90 smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Create a smart contract, Onemizer90, which is an ERC721 token with unique functionalities tailored for minting, reserving, and managing a limited supply of tokens. The contract integrates sales constraints, allowing tokens to be minted only after a specified start date and ensuring transactions meet the set ether value. Additionally, it supports owner-specific features like modifying contract parameters and reserving tokens for specific addresses.\n\nContract Specifications:\n- Inherits ERC721 and Ownable functionalities.\n- Utilizes Counters from OpenZeppelin to manage token IDs.\n- Establishes sale parameters including price, start date, max supply, and reserved tokens.\n- Includes a sale active modifier to control minting operations based on the start date.\n- Provides functions for minting, reserving tokens, querying total supply, and owner-specific operations like setting base URI, price, start date, max supply, and reserved tokens.\n\nKey Functionalities:\n1. Minting: Users can mint a specified number of tokens, adhering to the sale's active state, correct ether value, and max supply constraints.\n2. Reserving Tokens: The contract owner can reserve tokens for specific addresses, not affecting the publicly available supply.\n3. Supply and Ownership Queries: Functions are available to query the total supply of tokens and the list of token IDs owned by a specific address.\n4. Parameter Modifications: Only the contract owner can modify key parameters like the base URI, price, start date, max supply, and reserved tokens.\n5. Withdrawal: Enables the contract owner to withdraw funds to a specified address.\n6. OpenSea Integration: Overrides isApprovedForAll to whitelist OpenSea proxy accounts, facilitating gas-less listings.\n\nImplementation Details:\n- The mint function incorporates the saleIsActive modifier, ensuring tokens can only be minted after the sale starts, and checks if the ether sent with the request matches the total price for the requested number of tokens.\n- Reserved tokens are considered in the total supply to prevent exceeding the max supply when minting.\n- The reserve function is restricted to the contract owner, allowing them to mint tokens directly to given addresses without payment.\n- Base URI, price, start date, max supply, and reserved tokens can be updated by the owner, allowing for flexibility in managing the sale.\n\nSecurity Considerations:\n- Ensures that only the contract owner can modify critical contract parameters and reserve tokens, protecting against unauthorized alterations.\n- Includes checks for valid addresses and correct ether values to mitigate common vulnerabilities.\n- The use of the Ownable and Counters libraries from OpenZeppelin provides tested and secure management of ownership and token ID incrementation.\n- The contract adheres to ERC721 standards for NFTs, ensuring compatibility and security in transactions and ownership management.\n"}, {"role": "assistant", "content": "\ncontract Onemizer90 is ERC721, Ownable {\n    using Counters for Counters.Counter;\n    address proxyRegistryAddress;\n    Counters.Counter private _tokenSupply;\n\n    uint256 public PRICE;\n    uint256 public START_DATE;\n    uint256 public MAX_SUPPLY;\n    uint256 public RESERVED;\n\n    string private baseUri;\n\n    modifier saleIsActive() {\n        require(START_DATE != 0 && block.timestamp >= START_DATE, \"Sale is not active yet\");\n        _;\n    }\n\n    constructor(address _proxyRegistryAddress, uint256 _price, uint256 _startDate, uint256 _maxSupply, uint256 _reserved, string memory _baseUri) ERC721(\"Onemizer90\", \"OM\") {\n        proxyRegistryAddress = _proxyRegistryAddress;\n        PRICE = _price;\n        START_DATE = _startDate;\n        MAX_SUPPLY = _maxSupply;\n        RESERVED = _reserved;\n        baseUri = _baseUri;\n    }\n\n    function mint(uint256 numberOfTokens) public payable saleIsActive {\n        require(numberOfTokens * PRICE == msg.value, \"Ether value is not correct\");\n        require(_tokenSupply.current() + numberOfTokens + RESERVED <= MAX_SUPPLY, \"Sold out!\");\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _safeMint(msg.sender, _tokenSupply.current());\n            _tokenSupply.increment();\n        }\n    }\n\n    function reserve(address[] calldata to) public onlyOwner {\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], _tokenSupply.current());\n            _tokenSupply.increment();\n        }\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _tokenSupply.current();\n    }\n\n    function contractURI() public pure returns (string memory) {\n        return \"ipfs://bafybeigpmcheddbbt7un2745fzpoi3r3vsxnjhtzj5poovsledgb52qd3i\";\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseUri;\n    }\n\n    function setBaseURI(string memory _baseUri) public onlyOwner {\n        baseUri = _baseUri;\n    }\n\n    function setPrice(uint256 _price) public onlyOwner {\n        PRICE = _price;\n    }\n\n    function setStartDate(uint256 _startDate) public onlyOwner {\n        START_DATE = _startDate;\n    }\n\n    function setMaxSupply(uint256 _maxSupply) public onlyOwner {\n        MAX_SUPPLY = _maxSupply;\n    }\n\n    function setReserved(uint256 _reserved) public onlyOwner {\n        RESERVED = _reserved;\n    }\n\n    function walletOfOwner(address owner) public view returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](balanceOf(owner));\n        uint256 i = 0;\n\n        for (uint256 tokenId = 0; tokenId < _tokenSupply.current(); tokenId++) {\n            if (_exists(tokenId) && ownerOf(tokenId) == owner) {\n                result[i] = tokenId;\n                i += 1;\n            }\n        }\n        return result;\n    }\n\n    function withdraw(address payable to, uint256 amount) public onlyOwner {\n        require(to != address(0x0), \"Invalid address\");\n        to.transfer(amount);\n    }\n\n    // Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        // Whitelist OpenSea proxy contract for easy trading.\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n\n        return super.isApprovedForAll(owner, operator);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a YahtsContract smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop an ERC20 token smart contract named YahtsContract with advanced features including burning tokens and preventing accidental ETH transfers to the contract. The contract aims to manage a predefined supply of tokens, facilitate transfers between addresses, allow token spending approvals, and enable token holders to reduce the total supply by burning tokens they own.\n\nContract Specifications:\n- Implements ERC20 standard functionalities.\n- Initializes with a fixed token supply, name, symbol, standard, and decimals.\n- Incorporates functions for token transfer, allowance management, balance queries, and token burning.\n- Utilizes SafeMath for arithmetic operations to prevent overflow and underflow vulnerabilities.\n- Rejects incoming ETH transactions to prevent accidental ETH deposits.\n\nKey Functionalities:\n1. Initial Token Allocation: Assigns the entire initial supply to the contract creator's address.\n2. Token Transfer: Enables token holders to transfer tokens to another address, with checks for sufficient balance.\n3. Approval Mechanism: Allows token holders to authorize a third party to spend a specified amount of tokens on their behalf.\n4. Transfer from Approved Account: Facilitates transfers from an approved account up to the allowed limit, adjusting balances and allowances accordingly.\n5. Token Burning: Permits token holders to reduce the circulating supply by destroying a portion of their tokens.\n6. Query Functions: Provides public view functions to access token details (name, symbol, standard, decimals) and account-specific details (balance, allowance).\n\nImplementation Details:\n- The transfer, approve, and transferFrom functions incorporate checks for zero addresses and sufficient balances/allowances, aligning with ERC20 standards.\n- The burn function allows token holders to voluntarily decrease the total supply by destroying their tokens, emitting a transfer event to the zero address to signify the burn.\n- SafeMath library is used to safely conduct arithmetic operations, protecting against overflow and underflow.\n- The contract explicitly rejects direct ETH transfers by reverting transactions, ensuring that users do not mistakenly send ETH to the contract.\n\nSecurity Considerations:\n- Utilizes OpenZeppelin's SafeMath library to mitigate arithmetic vulnerabilities.\n- Includes input validation to prevent transfers to the zero address and ensure action legitimacy.\n- Implements a mechanism to reject ETH deposits, protecting users from accidental loss of ETH.\n- Adheres to the ERC20 standard, ensuring compatibility with the Ethereum ecosystem and preventing common token contract issues.\n"}, {"role": "assistant", "content": "\ncontract YahtsContract is ERC20 {\n    string internal _name = \"VI YAHTS 1\";\n    string internal _symbol = \"VT1\";\n    string internal _standard = \"ERC20\";\n    uint8 internal _decimals = 18;\n    uint internal _totalSupply = 500000 * 1 ether;\n    \n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor () public {\n        balances[msg.sender] = totalSupply();\n    }\n\n    function () external payable  {\n        revert(\"This SmartContract is not payable\");\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function standard() public view returns (string memory) {\n        return _standard;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require (_spender != address(0), \"_spender address has to be set\");\n        require (_value > 0, \"'_value' parameter has to be greater than 0\");\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_from != address(0), \"'_from' address has to be set\");\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[_from], \"Insufficient balance\");\n        require(_value <= allowed[_from][msg.sender], \"Insufficient allowance\");\n\n        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n        balances[_from] = SafeMath.sub(balances[_from], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n    \n    function burn(uint256 _value) public returns (bool success) {\n        require(_value <= balances[msg.sender]);\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        _totalSupply = SafeMath.sub(_totalSupply, _value);\n        emit Transfer(msg.sender, address(0), _value);\n        return true;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a PerkyPineapples smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Develop a unique ERC721 token smart contract, PerkyPineapples, designed to manage a collection of NFTs with distinct minting phases, including a free minting period. This contract incorporates several adjustable parameters to control the sales process, such as activation status, price per token, maximum tokens per transaction, and limitations on free mints per wallet. It also includes a mechanism to gift tokens and withdraw contract balances, alongside integration with proxy registries for marketplace compatibility.\n\nContract Specifications:\n- Inherits ERC721 and Ownable functionalities for NFT management and ownership control.\n- Defines parameters for sale activation, token pricing, minting caps, and free mint allowances.\n- Utilizes a counter to track the total supply of tokens.\n- Allows for the setting of hidden and base URIs to manage how token metadata is presented before and after reveal.\n- Includes proxy registry address integration for marketplace facilitation.\n\nKey Functionalities:\n1. Sale Activation: The contract owner can toggle the sale's active status, controlling when minting is allowed.\n2. Minting: Users can mint a specified number of tokens, adhering to maximum per transaction and total supply limits, with a distinction between paid and free minting based on the current supply and per-wallet free mint limits.\n3. Gifting Tokens: The contract owner can mint tokens directly to any address, bypassing payment and mint limits.\n4. Withdrawal: Enables the contract owner to withdraw the balance of ETH collected from token sales.\n5. Metadata Management: Offers functions to set hidden and revealed metadata URIs for the tokens.\n6. Marketplace Integration: Adjusts approval checks for token operations through a proxy registry, aiding in marketplace listings.\n\nImplementation Details:\n- The contract distinguishes between free and paid mints based on the total amount of tokens already minted and individual wallet contributions to the free mint count.\n- Incorporates safety checks to prevent sending ETH to the contract unintentionally.\n- Utilizes a constructor to gift an initial set of tokens to the contract deployer.\n- Employs Counters to safely increment token IDs upon minting.\n- Provides public view functions for querying contract states, such as total supply and sale activation status.\n\nSecurity Considerations:\n- Ensures that minting functions check for sale activation and adhere to max supply constraints to prevent over-minting.\n- Uses onlyOwner modifiers for functions that modify critical parameters, ensuring that only the contract owner can alter the sale dynamics.\n- Prevents direct ETH transfers to the contract, mitigating the risk of unintended contract interactions.\n- Safe use of external calls (msg.sender.call) in the withdrawal function, though care must be taken to monitor for reentrancy vulnerabilities.\n"}, {"role": "assistant", "content": "\ncontract PerkyPineapples is ERC721, Ownable {\n    bool public saleIsActive = false;\n\n    uint256 public price = 0.025 ether;\n\tuint public maxPerTx = 10;\n\tuint public maxFreeMintPerWallet = 20;\n\tuint public amountAvailableFreeMint = 200;\n\tuint public maxSupply = 5000;\n\taddress proxyRegistryAddress ; \n\tmapping(address => uint) public addressFreeMinted;\n    string public _hiddenURI = \"ipfs://QmRkNnfQExTwer7vL1PNuRszzshpUWjRb7AerWQt1Ef82Q/hidden.json\";\n    string public _baseURIextended = \"\";\n\t\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenSupply;\n\n    constructor() ERC721(\"PerkyPineapples\", \"PP\") {\n        for (uint256 i = 0; i < 10; i++){\n            gift(msg.sender);\n        }\n    }\n\n    function totalSupply() public view returns (uint256 supply) {\n        return _tokenSupply.current();\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n\n        return super.isApprovedForAll(owner, operator);\n    }\n\n    function mint(uint numberOfTokens) external payable {\n        require(saleIsActive, \"Sale is inactive.\");\n        require(numberOfTokens <= maxPerTx, \"You can only mint 10 at a time.\");\n        require(_tokenSupply.current() + numberOfTokens <= maxSupply, \"Purchase would exceed max supply of tokens\");\n        \n        if (_tokenSupply.current() + numberOfTokens > amountAvailableFreeMint) {\n            require((price * numberOfTokens) <= msg.value, \"Don't send under (in ETH).\");\n        } else {\n\t\t\trequire(msg.value == 0, \"Don't send ether for the free mint.\");\n\t\t\trequire(addressFreeMinted[msg.sender] < maxFreeMintPerWallet, \"You can only adopt 20 free CAU per wallet. Wait for the paid adoption.\");\n\t\t}\n\t\t\n\t\taddressFreeMinted[msg.sender] += numberOfTokens;\n        for(uint i = 0; i < numberOfTokens; i++) {\n\t\t  uint256 _tokenId = _tokenSupply.current() + 1;\n            _safeMint(msg.sender, _tokenId);\n            _tokenSupply.increment();\n        }\n    }\n\n    function gift(address _to) public onlyOwner {\n        uint256 _tokenId = _tokenSupply.current() + 1;\n        _safeMint(_to, _tokenId);\n        _tokenSupply.increment();\n    }\n\n    function withdraw() public onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 \n            ? string(abi.encodePacked(baseURI, Strings.toString(tokenId), \".json\")) \n            : _hiddenURI; // If the base URI is not set, return a hidden URI\n    }\n\n    function setSaleIsActive(bool newState) public onlyOwner {\n        saleIsActive = newState;\n    }\n\n    function setPrice(uint newPrice) public onlyOwner {\n        price = newPrice;\n    }\n\n    function setMaxPerTx(uint _maxPerTx) external onlyOwner() {\n        maxPerTx = _maxPerTx;\n    }\n\n    function setMaxFreeMintPerWallet(uint _maxFreeMint) public onlyOwner() {\n        maxFreeMintPerWallet = _maxFreeMint;\n    }\n\n    function setAmountAvailableFreeMint(uint _freeMint) public onlyOwner() {\n        amountAvailableFreeMint = _freeMint;\n    }\n\n    function setMaxSupply(uint _maxSupply) public onlyOwner() {\n        maxSupply = _maxSupply;\n    }\n\n    // rinkeby: 0xf57b2c51ded3a29e6891aba85459d600256cf317\n    // mainnet: 0xa5409ec958c83c3f309868babaca7c86dcb077c1\n    function setProxyRegistryAddress(address proxyAddress) external onlyOwner {\n        proxyRegistryAddress = proxyAddress;\n    }\n\n    function setHiddenUri(string memory hiddenURI) public onlyOwner() {\n        _hiddenURI = hiddenURI;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\n        _baseURIextended = baseURI_;\n    }\n}\n"}]
