{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a InkeGold smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description:The InkeGold smart contract is an ERC20 token called \"Inke Gold\" (symbol: IKG) with a fixed supply of 45,000 tokens and specialized functionalities for freezing and unfreezing tokens. It allows the CEO to mint and burn tokens, while administrators can freeze tokens for a specified period or until manually unfrozen, preventing the affected accounts from transferring the frozen amount. The contract also provides standard ERC20 functions such as transferring tokens and checking balances, with additional checks to ensure that frozen tokens cannot be transferred until they are unfrozen.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function goldTotalSupply() public constant returns (uint):\n- Total supply\n2. function goldBalanceOf(address tokenOwner) public constant returns (uint balance): \n- Get the token balance for account tokenOwner\n3. function goldTransfer(address to, uint tokens) public whenNotPaused returns (bool success):\n- Transfer the balance from token owner's account to to account Owner's account must have sufficient balance to transfer 0 value transfers are allowed\n4. function mintGold(uint amount) public onlyCEO:\n- Mint Tokens\n5. function burnGold(uint amount) public onlyCEO: \n- Burn Tokens \n6. function goldFreeze(address user, uint amount, uint period) public onlyAdmin: \n- Freeze Tokens \n7. function goldUnFreeze() public whenNotPaused: \n- UnFreeze Tokens \n8. function goldIfFreeze(address user) public view returns:\n- if fromzen tokens, returns amount of tokens that are frozen and time remaining until the tokens are automatically unfrozen\n"}, {"role": "assistant", "content": "contract InkeGold is ERC20Interface, Administration, SafeMath {\r\n    event GoldTransfer(address indexed from, address indexed to, uint tokens);\r\n    \r\n    string public goldSymbol;\r\n    string public goldName;\r\n    uint8 public goldDecimals;\r\n    uint public _goldTotalSupply;\r\n\r\n    mapping(address => uint) goldBalances;\r\n    mapping(address => bool) goldFreezed;\r\n    mapping(address => uint) goldFreezeAmount;\r\n    mapping(address => uint) goldUnlockTime;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        goldSymbol = \"IKG\";\r\n        goldName = \"Inke Gold\";\r\n        goldDecimals = 0;\r\n        _goldTotalSupply = 45000;\r\n        goldBalances[CEOAddress] = _goldTotalSupply;\r\n        emit GoldTransfer(address(0), CEOAddress, _goldTotalSupply);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function goldTotalSupply() public constant returns (uint) {\r\n        return _goldTotalSupply  - goldBalances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function goldBalanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return goldBalances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function goldTransfer(address to, uint tokens) public whenNotPaused returns (bool success) {\r\n        if(goldFreezed[msg.sender] == false){\r\n            goldBalances[msg.sender] = safeSub(goldBalances[msg.sender], tokens);\r\n            goldBalances[to] = safeAdd(goldBalances[to], tokens);\r\n            emit GoldTransfer(msg.sender, to, tokens);\r\n        } else {\r\n            if(goldBalances[msg.sender] > goldFreezeAmount[msg.sender]) {\r\n                require(tokens <= safeSub(goldBalances[msg.sender], goldFreezeAmount[msg.sender]));\r\n                goldBalances[msg.sender] = safeSub(goldBalances[msg.sender], tokens);\r\n                goldBalances[to] = safeAdd(goldBalances[to], tokens);\r\n                emit GoldTransfer(msg.sender, to, tokens);\r\n            }\r\n        }\r\n            \r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Mint Tokens\r\n    // ------------------------------------------------------------------------\r\n    function mintGold(uint amount) public onlyCEO {\r\n        goldBalances[msg.sender] = safeAdd(goldBalances[msg.sender], amount);\r\n        _goldTotalSupply = safeAdd(_goldTotalSupply, amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Burn Tokens\r\n    // ------------------------------------------------------------------------\r\n    function burnGold(uint amount) public onlyCEO {\r\n        goldBalances[msg.sender] = safeSub(goldBalances[msg.sender], amount);\r\n        _goldTotalSupply = safeSub(_goldTotalSupply, amount);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Freeze Tokens\r\n    // ------------------------------------------------------------------------\r\n    function goldFreeze(address user, uint amount, uint period) public onlyAdmin {\r\n        require(goldBalances[user] >= amount);\r\n        goldFreezed[user] = true;\r\n        goldUnlockTime[user] = uint(now) + period;\r\n        goldFreezeAmount[user] = amount;\r\n    }\r\n    \r\n    function _goldFreeze(uint amount) internal {\r\n        require(goldFreezed[msg.sender] == false);\r\n        require(goldBalances[msg.sender] >= amount);\r\n        goldFreezed[msg.sender] = true;\r\n        goldUnlockTime[msg.sender] = uint(-1);\r\n        goldFreezeAmount[msg.sender] = amount;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // UnFreeze Tokens\r\n    // ------------------------------------------------------------------------\r\n    function goldUnFreeze() public whenNotPaused {\r\n        require(goldFreezed[msg.sender] == true);\r\n        require(goldUnlockTime[msg.sender] < uint(now));\r\n        goldFreezed[msg.sender] = false;\r\n        goldFreezeAmount[msg.sender] = 0;\r\n    }\r\n    \r\n    function _goldUnFreeze(uint _amount) internal {\r\n        require(goldFreezed[msg.sender] == true);\r\n        goldUnlockTime[msg.sender] = 0;\r\n        goldFreezed[msg.sender] = false;\r\n        goldFreezeAmount[msg.sender] = safeSub(goldFreezeAmount[msg.sender], _amount);\r\n    }\r\n    \r\n    function goldIfFreeze(address user) public view returns (\r\n        bool check, \r\n        uint amount, \r\n        uint timeLeft\r\n    ) {\r\n        check = goldFreezed[user];\r\n        amount = goldFreezeAmount[user];\r\n        timeLeft = goldUnlockTime[user] - uint(now);\r\n    }\r\n\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a liquidbotToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The liquidbotToken smart contract is an ERC20 token named \"Liquidbot Token\" with the symbol \"LQB\" and a decimal precision of 18. It includes functionalities for handling a crowdsale with a start and end date, allowing for token purchases at a fixed rate during this period, and enabling the owner to withdraw Ether, initiate an airdrop, and manage the crowdsale timing. The contract also implements standard ERC20 functions such as transferring tokens, approving token spending, and querying balances and allowances, with additional safety checks and an owner-only withdrawal mechanism for collected Ether post-crowdsale.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function totalSupply() public view override returns (uint256):\n- Total supply \n2. function balanceOf(address tokenOwner) public override view returns (uint256 balance):\n- Get the token balance for account `tokenOwner` \n3. function transfer(address to, uint256 tokens) public override returns (bool success):\n- Transfer the balance from token owner's account to `to` account  Owner's account must have sufficient balance to transfer  0 value transfers are allowed \n4. function approve(address spender, uint256 tokens) public override returns (bool success):\n- Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account https:github.comethereumEIPsblobmasterEIPSeip20tokenstandard.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces \n5. function transferFrom(address from, address to, uint256 tokens) public override returns (bool success):\n- Transfer `tokens` from the `from` account to the `to` account The calling account must already have sufficient tokens approve(...)d for spending from the `from` account and  From account must have sufficient balance to transfer  Spender must have sufficient allowance to transfer  0 value transfers are allowed \n6. function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n7. function approveAndCall(address spender, uint256 tokens, bytes memory data) public returns (bool success):\n- Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account. The `spender` contract function `receiveApproval(...)` is then executed \n8. function startCrowdsale() public onlyOwner:\n- Owner only start Crowdsale \n9. function getAirdropTokens() public onlyOwner:\n- Send tokens to owner for airdrop \n10. function withDrawETH(uint256 amount) public onlyOwner tokensaleEnded:\n- Owner only withdraw ETH \n11. function withDrawETHToAddress(address payable destinationAddress, uint256 amount) public onlyOwner tokensaleEnded:\n- Owner only withdraw ETH to address \n12. function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens\n"}, {"role": "assistant", "content": "contract liquidbotToken is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public name;\r\n    uint8 public decimals;\r\n    uint256 public _totalSupply;\r\n    uint256 public startDate;\r\n    uint256 public endDate;\r\n    bool public airdropTokensWithdrawn = false;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() {\r\n        symbol = \"LQB\";\r\n        name = \"Liquidbot Token\";\r\n        decimals = 18;\r\n        startDate = block.timestamp + 20 weeks;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint256 tokens)\r\n        public\r\n        override\r\n        returns (bool success)\r\n    {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces\r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint256 tokens)\r\n        public\r\n        override\r\n        returns (bool success)\r\n    {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    //\r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the `from` account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokens\r\n    ) public override returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256 remaining)\r\n    {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account. The `spender` contract function\r\n    // `receiveApproval(...)` is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(\r\n        address spender,\r\n        uint256 tokens,\r\n        bytes memory data\r\n    ) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(\r\n            msg.sender,\r\n            tokens,\r\n            address(0),\r\n            data\r\n        );\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // handles contributions\r\n    // ------------------------------------------------------------------------\r\n    receive() external payable {\r\n        require(block.timestamp >= startDate && block.timestamp <= endDate);\r\n        uint256 tokens = safeMul(msg.value, 40);\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);\r\n        _totalSupply = safeAdd(_totalSupply, tokens);\r\n        emit Transfer(address(0), msg.sender, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner only start Crowdsale\r\n    // ------------------------------------------------------------------------\r\n    function startCrowdsale() public onlyOwner {\r\n        startDate = block.timestamp;\r\n        endDate = block.timestamp + 6 weeks;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Send tokens to owner for airdrop\r\n    // ------------------------------------------------------------------------\r\n    function getAirdropTokens() public onlyOwner {\r\n        require(block.timestamp >= startDate && block.timestamp <= endDate);\r\n        require(!airdropTokensWithdrawn);\r\n        uint256 tokens = 5000000000000000000000;\r\n        balances[owner] = safeAdd(balances[owner], tokens);\r\n        _totalSupply = safeAdd(_totalSupply, tokens);\r\n        emit Transfer(address(0), owner, tokens);\r\n        airdropTokensWithdrawn = true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner only withdraw ETH\r\n    // ------------------------------------------------------------------------\r\n    function withDrawETH(uint256 amount) public onlyOwner tokensaleEnded {\r\n        owner.transfer(amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner only withdraw ETH to address\r\n    // ------------------------------------------------------------------------\r\n    function withDrawETHToAddress(address payable destinationAddress, uint256 amount) public onlyOwner tokensaleEnded {\r\n        destinationAddress.transfer(amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint256 tokens)\r\n        public\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    modifier tokensaleEnded {\r\n        require(block.timestamp > endDate);\r\n        _;\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a BluzelleStakingRewards smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The BluzelleStakingRewards smart contract is an ERC20 token with a detailed implementation that includes a deflationary mechanism where a percentage of each transaction is burned, reducing the total supply over time. It provides standard ERC20 functionalities such as transferring tokens, approving token spending, and querying balances and allowances, with additional functions for burning tokens both by the token holder and by an approved spender. The contract also includes a method to calculate the burn amount for a given transaction value, ensuring that a fixed percentage of the transaction value is removed from circulation with each transfer.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function totalSupply() public view returns(uint256):\n- Return: Total number of tokens in circulation\n2. function balanceOf(address owner) public view returns(uint256):\n- Return: Balance owned by `owner`\n3. function allowance(address owner, address spender) public view returns(uint256):\n- Return: Amount of tokens that `spender` is allowed to spend on behalf of `owner`\n4. function findBurnAmount(uint256 value) public view returns(uint256):\n- Calculates the amount of tokens to be burned based on the transaction value and the base burn percentage.\n5. function transfer(address to, uint256 value) public returns(bool):\n- Transfers `value` tokens from the caller's account to the `to` account, with a portion of the tokens being burned in the process\n6. function approve(address spender, uint256 value) public returns(bool):\n- Approves `spender` to spend up to `value` tokens on behalf of the caller.\n7. function transferFrom(address from, address to, uint256 value) public returns(bool):\n- Transfers `value` tokens from `from` account to `to` account on behalf of the caller, with a portion of the tokens being burned in the process\n8. function increaseAllowance(address spender, uint256 addedValue) public returns(bool):\n- Increases the allowance granted to `spender` by the caller by `addedValue` tokens\n9. function decreaseAllowance(address spender, uint256 subtractedValue) public returns(bool):\n- Decreases the allowance granted to `spender` by the caller by `subtractedValue` tokens\n10. function _mint(address account, uint256 amount) internal\n- Internal function to mint `amount` tokens to the specified `account`\n11. function burn(uint256 amount) external\n- Allows the caller to burn `amount` of their own tokens, reducing the total supply\n12. function _burn(address account, uint256 amount) internal\n- Internal function to burn `amount` tokens from the specified `account`, reducing the total supply\n13. function burnFrom(address account, uint256 amount) external\n- Allows a spender to burn `amount` of tokens from `account`'s balance, given sufficient allowance\n"}, {"role": "assistant", "content": "contract BluzelleStakingRewards is ERC20Detailed {\r\n\r\n    using SafeMath for uint256; \r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply = 11000e18;\r\n\r\n\r\n    uint256 public basePercent = 320;\r\n\r\n    constructor() public ERC20Detailed(\"Bluzelle Staking Rewards\", \"BLSR\", 18) {\r\n        _mint(msg.sender, _totalSupply);\r\n    }\r\n\r\n    /// @return Total number of tokens in circulation\r\n    function totalSupply() public view returns(uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    function balanceOf(address owner) public view returns(uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns(uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n\r\n    function findBurnAmount(uint256 value) public view returns(uint256) {\r\n  \r\n        if (value == 1) {\r\n            return 0;\r\n        }\r\n        uint256 roundValue = value.ceil(basePercent);\r\n        //Gas optimized\r\n        uint256 burnAmount = roundValue.mul(100).div(32000);\r\n        return burnAmount;\r\n    }\r\n\r\n\r\n    function transfer(address to, uint256 value) public returns(bool) {\r\n        require(to != address(0));\r\n\r\n        uint256 tokensToBurn = findBurnAmount(value);\r\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\r\n\r\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n        _balances[to] = _balances[to].add(tokensToTransfer);\r\n\r\n        _totalSupply = _totalSupply.sub(tokensToBurn);\r\n\r\n        emit Transfer(msg.sender, to, tokensToTransfer);\r\n        emit Transfer(msg.sender, address(0), tokensToBurn);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address spender, uint256 value) public returns(bool) {\r\n        require(spender != address(0));\r\n        _allowances[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns(bool) {\r\n        require(value <= _allowances[from][msg.sender]);\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n\r\n        uint256 tokensToBurn = findBurnAmount(value);\r\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\r\n\r\n        _balances[to] = _balances[to].add(tokensToTransfer);\r\n        _totalSupply = _totalSupply.sub(tokensToBurn);\r\n\r\n        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\r\n\r\n        emit Transfer(from, to, tokensToTransfer);\r\n        emit Transfer(from, address(0), tokensToBurn);\r\n\r\n        return true;\r\n    }\r\n\r\n  \r\n    function increaseAllowance(address spender, uint256 addedValue) public returns(bool) {\r\n        require(spender != address(0));\r\n        _allowances[msg.sender][spender] = (_allowances[msg.sender][spender].add(addedValue));\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns(bool) {\r\n        require(spender != address(0));\r\n        _allowances[msg.sender][spender] = (_allowances[msg.sender][spender].sub(subtractedValue));\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(amount != 0);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function burn(uint256 amount) external {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(amount != 0);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[account] = _balances[account].sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) external {\r\n        require(amount <= _allowances[account][msg.sender]);\r\n        _allowances[account][msg.sender] = _allowances[account][msg.sender].sub(amount);\r\n        _burn(account, amount);\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The GlassesLoot smart contract is an ERC721 token representing glasses-themed collectibles with a fixed maximum supply and a sale mechanism. It allows the owner to set prices, toggle the sale state, reserve tokens for giveaways, and withdraw funds, while users can mint new tokens during an active sale, paying a specified ETH price per token. A portion of the mint proceeds is allocated to a community wallet, and the contract includes safeguards against reentrancy attacks during token minting.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function withdraw() public onlyOwner:\n- Allows the owner to withdraw a portion of the contract's balance, allocated to the developer and community wallet based on predefined budgets.\n2. function calculateWithdraw(uint256 budget, uint256 proposal) private pure returns (uint256)\n- Calculates the withdrawal amount based on the available budget and the proposed amount, ensuring it doesn't exceed the budget.\n3. function _withdraw(address _address, uint256 _amount) private\n- Internal function to transfer `_amount` of Ether to the specified `_address`.\n4. function setGlassesPrice(uint256 _glassesPrice) public onlyOwner\n- Allows the owner to set the price for minting a Glasses Loot token.\n5. function setProvenanceHash(string memory provenanceHash) public onlyOwner\n- Allows the owner to set the provenance hash for the Glasses Loot collection.\n6. function setBaseURI(string memory baseURI) public onlyOwner\n- Allows the owner to set the base URI for the token metadata.\n7. function flipSaleState() public onlyOwner\n- Toggles the active state of the token sale, allowing or disallowing minting.\n8. function reserveGlassesLoot(address _to, uint256 _reserveAmount) public onlyOwner\n- Allows the owner to reserve a specific amount of Glasses Loot tokens for a specified address.\n9. function mintGlassesLoot(uint numberOfTokens) public payable reentryLock\n- Allows users to mint a specified number of Glasses Loot tokens during an active sale, subject to limits and price requirements.\n10. function tokensOfOwner(address _owner) external view returns(uint256[] memory)\n- Returns an array of token IDs owned by the specified address.\n"}, {"role": "assistant", "content": "contract GlassesLoot is ERC721, Ownable, nonReentrant {\r\n\r\n    string public GLASSES_PROVENANCE = \"\"; // IPFS URL WILL BE ADDED WHEN Glasses Loot from Space are sold out\r\n\t\r\n    uint256 public glassesPrice = 100000000000000000; // 0.1 ETH  75% of Mint goes back to the CommunityWallet!  20% of Royalties will go to the Community Wallet as well!\r\n\r\n    uint public constant maxGlassesPurchase = 20;\r\n\r\n    uint256 public constant MAX_GLASSES = 10000;\r\n\t\r\n\tuint256 public budgetDev1 = 10000 ether; \r\n    uint256 public budgetCommunityWallet = 10000 ether; \r\n\r\n    bool public saleIsActive = false;\r\n\t\r\n\taddress private constant DEV1 = 0xb9Ac0254e09AfB0C18CBF21B6a2a490FB608e738;\r\n    address private constant CommunityWallet = 0x7ccAfc2707E88B5C9929a844d074a06eb1555DD7;\r\n    \r\n    // mapping(uint => string) public glassesNames;\r\n    \r\n    // Reserve Glasses for team - Giveaways/Prizes etc\r\n\tuint public constant MAX_GLASSESRESERVE = 400;\t// total team reserves allowed for Giveaways, Admins, Mods, Team\r\n    uint public GlassesReserve = MAX_GLASSESRESERVE;\t// counter for team reserves remaining \r\n    \r\n    constructor() ERC721(\"Glasses Loot\", \"GLOOT\") {     }\r\n    //TEAM Withdraw\r\n\t\r\n\tfunction withdraw() public onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"Insufficent balance\");\r\n        uint256 witdrawAmount = calculateWithdraw(budgetDev1,(balance * 25) / 100);\r\n        if (witdrawAmount>0){\r\n            budgetDev1 -= witdrawAmount;\r\n            _withdraw(DEV1, witdrawAmount);\r\n        }\r\n        witdrawAmount = calculateWithdraw(budgetCommunityWallet,(balance * 75) / 100);\r\n        if (witdrawAmount>0){\r\n            budgetCommunityWallet -= witdrawAmount;\r\n            _withdraw(CommunityWallet, witdrawAmount);\r\n        }\r\n      \r\n    }\r\n\r\n    function calculateWithdraw(uint256 budget, uint256 proposal) private pure returns (uint256){\r\n        if (proposal>budget){\r\n            return budget;\r\n        } else{\r\n            return proposal;\r\n        }\r\n    }\r\n    \r\n    function _withdraw(address _address, uint256 _amount) private {\r\n        (bool success, ) = _address.call{ value: _amount }(\"\");\r\n        require(success, \"Failed to widthdraw Ether\");\r\n    }\r\n    \r\n    \r\n\r\n\t\r\n\tfunction setGlassesPrice(uint256 _glassesPrice) public onlyOwner {\r\n        glassesPrice = _glassesPrice;\r\n    }\r\n\t\r\n\t\r\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\r\n        GLASSES_PROVENANCE = provenanceHash;\r\n    }\r\n\r\n    function setBaseURI(string memory baseURI) public onlyOwner {\r\n        _setBaseURI(baseURI);\r\n    }\r\n\r\n\r\n    function flipSaleState() public onlyOwner {\r\n        saleIsActive = !saleIsActive;\r\n    }\r\n    \r\n    \r\n    function reserveGlassesLoot(address _to, uint256 _reserveAmount) public onlyOwner {        \r\n        uint reserveMint = MAX_GLASSESRESERVE - GlassesReserve; \r\n        require(_reserveAmount > 0 && _reserveAmount < GlassesReserve + 1, \"Not enough reserve left to fulfill amount\");\r\n        for (uint i = 0; i < _reserveAmount; i++) {\r\n            _safeMint(_to, reserveMint + i);\r\n        }\r\n        GlassesReserve = GlassesReserve - _reserveAmount;\r\n    }\r\n\r\n\r\n    function mintGlassesLoot(uint numberOfTokens) public payable reentryLock {\r\n        require(saleIsActive, \"Sale must be active to mint GlassesLoot\");\r\n        require(numberOfTokens > 0 && numberOfTokens < maxGlassesPurchase + 1, \"Can only mint 20 Glasses at a time\");\r\n        require(totalSupply() + numberOfTokens < MAX_GLASSES - GlassesReserve + 1, \"Purchase would exceed max supply of GlassesLoot\");\r\n        require(msg.value >= glassesPrice * numberOfTokens, \"Ether value sent is not correct\");\r\n        \r\n        for(uint i = 0; i < numberOfTokens; i++) {\r\n            uint mintIndex = totalSupply() + GlassesReserve; // start minting after reserved tokenIds\r\n            if (totalSupply() < MAX_GLASSES) {\r\n                _safeMint(msg.sender, mintIndex);\r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n    function tokensOfOwner(address _owner) external view returns(uint256[] memory ) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 index;\r\n            for (index = 0; index < tokenCount; index++) {\r\n                result[index] = tokenOfOwnerByIndex(_owner, index);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\t\r\n    \r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a ALCOIN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The ALCOIN smart contract represents a basic implementation of a cryptocurrency token called \"LATINO AMERICA COIN\" with the symbol \"ALC\" and a decimal precision of 3. It initializes with a total supply of 500 billion tokens, all of which are initially assigned to the contract creator. The contract includes a basic transfer function that allows token holders to send tokens to other addresses, with checks for sufficient balance and overflow protection, and an unnamed function to prevent accidental sending of ether to the contract.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function ALCOIN():\n- Initializes contract with initial supply tokens to the creator of the contract \n2. function transfer(address _to, uint256 _value):  \n- Send coins \n3. function() :\n- This unnamed function is called whenever someone tries to send ether to it \n"}, {"role": "assistant", "content": "contract ALCOIN {\r\n    /* Public variables of the token */\r\n    string public standard = 'Token 0.1';\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public initialSupply;\r\n    uint256 public totalSupply;\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  \r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function ALCOIN() {\r\n\r\n         initialSupply = 500000000000;\r\n        name = \"LATINO AMERICA COIN\";\r\n        decimals = 3;\r\n        symbol = \"ALC\";\r\n        \r\n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\r\n        totalSupply = initialSupply;                        // Update total supply\r\n                                   \r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n      \r\n    }\r\n\r\n    /* This unnamed function is called whenever someone tries to send ether to it */\r\n    function () {\r\n        throw;     // Prevents accidental sending of ether\r\n    }\r\n}"}]}
