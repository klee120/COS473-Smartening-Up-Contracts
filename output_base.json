["pragma solidity ^0.4.17;\n\nimport \"./ERC20.sol\";\nimport \"./MinterRole.sol\";\n\ncontract Bitfex_Token is ERC20, MinterRole {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    constructor(string _name, string _symbol, uint8 _decimals) public {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function mint(address account, uint256 amount) public onlyMinter {\n        _mint(account, amount);\n    }\n\n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n\n    function tokenName() public view returns (string) {\n        return name;\n    }\n\n    function tokenSymbol() public view returns (string) {\n        return symbol;\n    }\n\n    function tokenDecimals() public view returns (uint8) {\n        return decimals;\n    }\n}", "pragma solidity 0.4.17;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Detailed is IERC20 {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    constructor(string _name, string _symbol, uint8 _decimals) public {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n}\n\ncontract Legends_of_Crypto is ERC20Detailed(\"Legends of Crypto\", \"LOCG\", 18) {\n    using SafeMath for uint256;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    constructor() public {\n        totalSupply = 150000000 * 10 ** uint256(decimals);\n        balances[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return balances[owner];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(to != address(0));\n        require(value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        balances[to] = balances[to].add(value);\n        \n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        \n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(to != address(0));\n        require(value <= balances[from]);\n        require(value <= allowed[from][msg.sender]);\n\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        \n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function burn(uint256 value) public {\n        require(value <= balances[msg.sender]);\n        \n        balances[msg.sender] = balances[msg.sender].sub(value);\n        totalSupply = totalSupply.sub(value);\n        \n        emit Transfer(msg.sender, address(0), value);\n    }\n\n    function burnFrom(address from, uint256 value) public {\n        require(value <= balances[from]);\n        require(value <= allowed[from][msg.sender]);\n        \n        balances[from] = balances[from].sub(value);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        totalSupply = totalSupply.sub(value);\n        \n        emit Transfer(from, address(0), value);\n    }\n}", "pragma solidity 0.4.17;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Burnable.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Counters.sol\";\n\ncontract GrouchyTigerCubs is ERC721, ERC721Enumerable, ERC721Burnable, Ownable {\n    using SafeMath for uint256;\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n    uint256 private _mintingCost;\n    string private _baseTokenURI;\n\n    constructor() ERC721(\"GrouchyTigerCubs\", \"GTC\") {\n        _mintingCost = 0.1 ether;\n        _baseTokenURI = \"https://api.grouchytigercubs.com/token/\";\n    }\n\n    function _baseURI() internal view returns (string) {\n        return _baseTokenURI;\n    }\n\n    function setMintingCost(uint256 cost) public onlyOwner {\n        _mintingCost = cost;\n    }\n\n    function mintingCost() public view returns (uint256) {\n        return _mintingCost;\n    }\n\n    function ownerWithdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        address(owner()).transfer(balance);\n    }\n\n    function safeMint(address to) public payable {\n        require(msg.value >= _mintingCost, \"Insufficient Ether sent for minting\");\n        _safeMint(to, _tokenIdCounter.current());\n        _tokenIdCounter.increment();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}", "pragma solidity 0.4.17;\n\nimport \"./ERC20Detailed.sol\";\nimport \"./SafeMath.sol\";\n\ncontract ANTIHYPE is ERC20Detailed {\n    using SafeMath for uint256;\n\n    uint256 private _totalSupply = 10000 * (10 ** uint256(decimals()));\n    address private _owner;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address owner) ERC20Detailed(\"ANTIHYPE Token\", \"ANTIHYPE\", 18) public {\n        _owner = owner;\n        _balances[owner] = _totalSupply;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _executeTransfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount);\n        _executeTransfer(sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _allowances[msg.sender][spender] = _allowances[msg.sender][spender].add(addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _allowances[msg.sender][spender] = _allowances[msg.sender][spender].sub(subtractedValue);\n        return true;\n    }\n\n    function multiTransfer(address[] recipients, uint256[] amounts) public returns (bool) {\n        require(recipients.length == amounts.length, \"Recipient count does not match amount count\");\n        for (uint256 i = 0; i < recipients.length; i++) {\n            _executeTransfer(msg.sender, recipients[i], amounts[i]);\n        }\n        return true;\n    }\n\n    function multiTransferEqualAmount(address[] recipients, uint256 amount) public returns (bool) {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            _executeTransfer(msg.sender, recipients[i], amount);\n        }\n        return true;\n    }\n\n    function withdrawUnclaimedTokens(address token) public onlyOwner {\n        ERC20Detailed tokenContract = ERC20Detailed(token);\n        uint256 unclaimedTokens = tokenContract.balanceOf(address(this));\n        require(tokenContract.transfer(_owner, unclaimedTokens), \"Token transfer failed\");\n    }\n\n    function _executeTransfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n        require(_balances[sender] >= amount, \"Insufficient balance\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n    }\n}", "pragma solidity 0.4.17;\n\ninterface ERC20Detailed {\n    function name() external view returns (string);\n    function symbol() external view returns (string);\n    function decimals() external view returns (uint8);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\ncontract DCREDITY is ERC20Detailed {\n    using SafeMath for uint256;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    uint256 private _totalSupply;\n    address private _owner;\n\n    mapping(address => uint256) private _balanceOf;\n    mapping(address => uint256) private _freezeOf;\n    mapping(address => mapping(address => uint256)) private _allowance;\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner);\n        _;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    event Freeze(address indexed from, uint256 value);\n    event Unfreeze(address indexed from, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() public {\n        _name = \"DCREDITY\";\n        _symbol = \"DCR\";\n        _decimals = 18;\n        _totalSupply = 10 * 10**9 * 10**uint256(_decimals);\n        _owner = msg.sender;\n        _balanceOf[_owner] = _totalSupply;\n        emit Transfer(address(0), _owner, _totalSupply);\n    }\n\n    function name() public view returns (string) {\n        return _name;\n    }\n\n    function symbol() public view returns (string) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(to != address(0));\n        require(value <= _balanceOf[msg.sender]);\n\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(value);\n        _balanceOf[to] = _balanceOf[to].add(value);\n\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(to != address(0));\n        require(value <= _balanceOf[from]);\n        require(value <= _allowance[from][msg.sender]);\n\n        _balanceOf[from] = _balanceOf[from].sub(value);\n        _balanceOf[to] = _balanceOf[to].add(value);\n        _allowance[from][msg.sender] = _allowance[from][msg.sender].sub(value);\n\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function burn(uint256 value) public {\n        require(value <= _balanceOf[msg.sender]);\n        \n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(value);\n        _totalSupply = _totalSupply.sub(value);\n\n        emit Burn(msg.sender, value);\n        emit Transfer(msg.sender, address(0), value);\n    }\n\n    function freeze(uint256 value) public {\n        require(value <= _balanceOf[msg.sender]);\n        \n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(value);\n        _freezeOf[msg.sender] = _freezeOf[msg.sender].add(value);\n\n        emit Freeze(msg.sender, value);\n    }\n\n    function unfreeze(uint256 value) public {\n        require(value <= _freezeOf[msg.sender]);\n\n        _freezeOf[msg.sender] = _freezeOf[msg.sender].sub(value);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].add(value);\n\n        emit Unfreeze(msg.sender, value);\n    }\n\n    function multiTransfer(address[] recipients, uint256[] values) public {\n        require(recipients.length == values.length);\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], values[i]);\n        }\n    }\n\n    function setTokenCost(uint256 cost) public onlyOwner {\n        // Implement your logic for setting token cost here\n    }\n}", "pragma solidity 0.4.17;\n\nimport \"./Ownable.sol\";\nimport \"./ERC721.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Counters.sol\";\n\ncontract DegenerateDachshunds is Ownable, ERC721 {\n    using SafeMath for uint256;\n    using Counters for Counters.Counter;\n\n    uint256 public constant MAX_SUPPLY = 1000;\n    uint256 public constant MAX_PER_MINT = 5;\n\n    bool public saleIsActive;\n    uint256 public price;\n    string public baseTokenURI;\n    \n    Counters.Counter private _tokenIdCounter;\n\n    constructor(string memory _baseTokenURI) {\n        baseTokenURI = _baseTokenURI;\n    }\n\n    function reserveNfts(address _to, uint256 _amount) public onlyOwner {\n        require(_tokenIdCounter.current().add(_amount) <= MAX_SUPPLY, \"Exceeds maximum supply\");\n        \n        for (uint256 i = 0; i < _amount; i++) {\n            _mintSingleNft(_to);\n        }\n    }\n\n    function mintNft(uint256 _amount) public payable {\n        require(saleIsActive, \"Sale is not active\");\n        require(_amount > 0 && _amount <= MAX_PER_MINT, \"Invalid amount to mint\");\n        require(msg.value >= price.mul(_amount), \"Insufficient payment\");\n        require(_tokenIdCounter.current().add(_amount) <= MAX_SUPPLY, \"Exceeds maximum supply\");\n\n        for (uint256 i = 0; i < _amount; i++) {\n            _mintSingleNft(msg.sender);\n        }\n    }\n\n    function _mintSingleNft(address _to) private {\n        uint256 newTokenId = _tokenIdCounter.current();\n        _mint(_to, newTokenId);\n        _tokenIdCounter.increment();\n    }\n\n    function setSaleState(bool _state) public onlyOwner {\n        saleIsActive = _state;\n    }\n\n    function setPrice(uint256 _newPrice) public onlyOwner {\n        price = _newPrice;\n    }\n\n    function setBaseTokenURI(string memory _newBaseTokenURI) public onlyOwner {\n        baseTokenURI = _newBaseTokenURI;\n    }\n\n    function withdraw() public onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n}", "pragma solidity ^0.4.17;\n\nimport \"./ERC721Enumerable.sol\";\nimport \"./SafeMath.sol\";\n\ncontract PACLEXAction is ERC721Enumerable {\n    using SafeMath for uint256;\n\n    address public constant PAC_DAO = 0x123...; // PAC DAO wallet address\n    address public constant LEX_DAO = 0x456...; // LexDAO wallet address\n    address public constant ARTIST = 0x789...; // Artist wallet address\n\n    bytes32 public merkleRoot;\n    string public baseURI;\n\n    uint256 public constant MAX_MINTS_PER_LEAF = 2;\n    uint256 public totalMinted;\n\n    address public owner;\n    address public beneficiary;\n\n    mapping(address => uint256) public mintCount;\n    mapping(address => bool) public mintedSpecialNFTs;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor(string _baseURI, bytes32 _merkleRoot) public {\n        baseURI = _baseURI;\n        merkleRoot = _merkleRoot;\n        owner = msg.sender;\n        beneficiary = msg.sender;\n    }\n\n    function mint(uint256 tokenId, bytes32[] proof) public {\n        require(verifyProof(proof), \"Invalid proof\");\n        require(totalMinted < MAX_SUPPLY, \"Mint cap reached\");\n\n        _mint(msg.sender, tokenId);\n        totalMinted = totalMinted.add(1);\n        mintCount[msg.sender] = mintCount[msg.sender].add(1);\n\n        if (!mintedSpecialNFTs[ARTIST] && mintCount[msg.sender] == 1) {\n            _mint(ARTIST, totalSupply() + 1);\n            mintedSpecialNFTs[ARTIST] = true;\n        }\n\n        if (!mintedSpecialNFTs[PAC_DAO] && mintCount[msg.sender] == 2) {\n            _mint(PAC_DAO, totalSupply() + 1);\n            mintedSpecialNFTs[PAC_DAO] = true;\n        }\n\n        if (!mintedSpecialNFTs[LEX_DAO] && mintCount[msg.sender] == 3) {\n            _mint(LEX_DAO, totalSupply() + 1);\n            mintedSpecialNFTs[LEX_DAO] = true;\n        }\n    }\n\n    function verifyProof(bytes32[] proof) private view returns (bool) {\n        bytes32 hash = keccak256(abi.encodePacked(msg.sender));\n        bytes32 currentHash;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 parentHash = proof[i];\n\n            if (hash < parentHash) {\n                currentHash = keccak256(abi.encodePacked(hash, parentHash));\n            } else {\n                currentHash = keccak256(abi.encodePacked(parentHash, hash));\n            }\n\n            hash = currentHash;\n        }\n\n        return hash == merkleRoot;\n    }\n\n    function updateRoot(bytes32 newRoot) public onlyOwner {\n        merkleRoot = newRoot;\n    }\n\n    function withdraw() public onlyOwner {\n        beneficiary.transfer(address(this).balance);\n    }\n\n    function setTokenURI(uint256 tokenId, string tokenURI) public onlyOwner {\n        // Function to set token URI\n    }\n\n    function setDefaultMetadata(string metadata) public onlyOwner {\n        // Function to set default metadata\n    }\n\n    function setContractURI(string contractURI) public onlyOwner {\n        // Function to set contract URI\n    }\n}", "pragma solidity 0.4.17;\n\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address tokenOwner) public view returns (uint256 balance);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ncontract SafeMath {\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a);\n        return c;\n    }\n    \n    function safeSub(uint a, uint b) internal pure returns (uint) {\n        require(b <= a);\n        return a - b;\n    }\n}\n\ncontract CrymCoin is ERC20Interface, SafeMath {\n    string public constant name = \"CrymCoin\";\n    string public constant symbol = \"CRYM\";\n    uint8 public constant decimals = 8;\n    uint256 public constant initialSupply = 1000000 * 10**uint(decimals);\n    \n    address public owner;\n    uint256 public totalSupply;\n    uint256 public rate;\n    bool public isCrowdsaleActive;\n    \n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    constructor(uint256 _rate) public {\n        owner = msg.sender;\n        totalSupply = initialSupply;\n        balances[owner] = totalSupply;\n        rate = _rate;\n        isCrowdsaleActive = true;\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return totalSupply;\n    }\n    \n    function balanceOf(address tokenOwner) public view returns (uint256) {\n        return balances[tokenOwner];\n    }\n    \n    function transfer(address to, uint tokens) public returns (bool) {\n        require(tokens <= balances[msg.sender]);\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    \n    function transferFrom(address from, address to, uint tokens) public returns (bool) {\n        require(tokens <= balances[from]);\n        require(tokens <= allowed[from][msg.sender]);\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n    \n    function approve(address spender, uint tokens) public returns (bool) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n    \n    function allowance(address tokenOwner, address spender) public view returns (uint256) {\n        return allowed[tokenOwner][spender];\n    }\n    \n    function () public payable {\n        require(isCrowdsaleActive);\n        uint tokens = msg.value * rate;\n        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);\n        totalSupply = safeAdd(totalSupply, tokens);\n        owner.transfer(msg.value);\n        emit Transfer(address(0), msg.sender, tokens);\n    }\n    \n    function startCrowdsale() public onlyOwner {\n        isCrowdsaleActive = true;\n    }\n    \n    function endCrowdsale() public onlyOwner {\n        isCrowdsaleActive = false;\n    }\n    \n    function changeRate(uint256 _newRate) public onlyOwner {\n        rate = _newRate;\n    }\n    \n    function burnUnsoldTokens() public onlyOwner {\n        require(!isCrowdsaleActive);\n        totalSupply = safeSub(totalSupply, balances[owner]);\n        balances[owner] = 0;\n    }\n}", "pragma solidity 0.4.17;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./Ownable.sol\";\nimport \"./RoyaltiesV2Impl.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Counters.sol\";\n\ncontract Page is ERC721, ERC721Enumerable, Ownable {\n    using SafeMath for uint256;\n    using Counters for Counters.Counter;\n\n    string public constant NAME = \"100 Pages\";\n    string public constant SYMBOL = \"PAGES\";\n    uint256 public constant MAX_SUPPLY = 100;\n\n    string public baseURI;\n    Counters.Counter private _tokenIdTracker;\n\n    address[] public collaborators;\n    mapping(address => uint256) public paymentSplits;\n\n    constructor(string memory _baseURI, address[] memory _initialCollaborators, uint256[] memory _initialSplits) public {\n        baseURI = _baseURI;\n        require(_initialCollaborators.length == _initialSplits.length, \"Invalid input lengths\");\n\n        for (uint256 i = 0; i < _initialCollaborators.length; i++) {\n            collaborators.push(_initialCollaborators[i]);\n            paymentSplits[_initialCollaborators[i]] = _initialSplits[i];\n        }\n    }\n\n    function _baseURI() internal view returns (string memory) {\n        return baseURI;\n    }\n\n    function mint(uint256 _chapter) public {\n        // Implement minting logic based on chapters\n    }\n\n    function updateCollaborator(address _collaborator, uint256 _split) public onlyOwner {\n        // Implement collaborator update logic\n    }\n\n    function updateBaseURI(string memory _newBaseURI) public onlyOwner {\n        // Implement base URI update logic\n    }\n\n    // Other functions for chapter management, royalties, giveaways, etc.\n\n    // Events for tracking changes\n\n}", "pragma solidity ^0.4.17;\n\nimport \"./ERC1155.sol\";\nimport \"./Ownable.sol\";\nimport \"./ERC1155Burnable.sol\";\n\ncontract Yggdrasil is ERC1155, Ownable, ERC1155Burnable {\n    string public baseTokenURI;\n    uint256 private totalTokensMinted;\n    uint256 private totalTokensBurned;\n    \n    address public relayerAddress;\n    address public anthroWalletAddress;\n\n    constructor(string _baseTokenURI) public {\n        baseTokenURI = _baseTokenURI;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return totalTokensMinted - totalTokensBurned;\n    }\n\n    function setRelayerAddress(address _relayerAddress) public onlyOwner {\n        relayerAddress = _relayerAddress;\n    }\n\n    function setAnthroWalletAddress(address _anthroWalletAddress) public onlyOwner {\n        anthroWalletAddress = _anthroWalletAddress;\n    }\n\n    function mintBatch(address _to, uint256[] _ids, uint256[] _amounts, bytes _data) public onlyOwner {\n        _mintBatch(_to, _ids, _amounts, _data);\n        totalTokensMinted += _ids.length;\n    }\n\n    function transferToBacker(address _backer, uint256 _id, uint256 _amount) public {\n        require(msg.sender == owner || msg.sender == relayerAddress, \"Unauthorized\");\n        safeTransferFrom(anthroWalletAddress, _backer, _id, _amount, \"\");\n    }\n\n    function burn(uint256 _id, uint256 _amount) public {\n        _burn(msg.sender, _id, _amount);\n        totalTokensBurned += _amount;\n    }\n}", "pragma solidity 0.4.17;\n\nimport \"./ERC1155.sol\";\nimport \"./ERC165Storage.sol\";\nimport \"./IERC2981.sol\";\nimport \"./Ownable.sol\";\nimport \"./Counters.sol\";\n\ncontract EtchedNFT1155 is ERC1155, ERC165Storage, IERC2981, Ownable {\n    using Counters for Counters.Counter;\n\n    mapping(uint256 => string) private _tokenURIs;\n    mapping(uint256 => address) private _creators;\n    mapping(uint256 => uint256) private _totalSupplies;\n    mapping(address => bool) private _mintingPermissions;\n\n    uint256 private _globalRoyaltyRate;\n\n    Counters.Counter private _tokenIds;\n\n    constructor() public {\n        _globalRoyaltyRate = 10; // 10% royalty rate\n        _tokenIds.increment(); // Reserve token ID 0 for future use\n        _tokenIds.increment(); // Reserve token ID 1 for airdrop\n        _tokenIds.increment(); // Reserve token ID 2 for airdrop\n\n        _creators[1] = address(0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF); // Predefined creator for token ID 1\n        _creators[2] = address(0xB0bB0bB0bB0bB0B0bb0B0bB0bB0bB0B0B0Bb0B0b); // Predefined creator for token ID 2\n    }\n\n    function setGlobalRoyaltyRate(uint256 rate) external onlyOwner {\n        _globalRoyaltyRate = rate;\n    }\n\n    function setMinterPermission(address minter, bool permission) external onlyOwner {\n        _mintingPermissions[minter] = permission;\n    }\n\n    function totalSupply(uint256 tokenId) external view returns (uint256) {\n        return _totalSupplies[tokenId];\n    }\n\n    function uri(uint256 tokenId) external view returns (string) {\n        return _tokenURIs[tokenId];\n    }\n\n    function airdrop(address[] recipients) external onlyOwner {\n        require(recipients.length <= 100, \"Exceeds maximum airdrop recipients\");\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            _mint(recipients[i], 1, 1, \"\");\n            _mint(recipients[i], 2, 1, \"\");\n        }\n    }\n\n    function mint(address to, uint256 tokenId, uint256 amount, string memory tokenURI) external {\n        require(_mintingPermissions[msg.sender], \"Caller is not a minter\");\n        \n        _mint(to, tokenId, amount, \"\");\n        _tokenURIs[tokenId] = tokenURI;\n        _creators[tokenId] = msg.sender;\n        _totalSupplies[tokenId] += amount;\n    }\n\n    function mintBatch(address[] to, uint256[] tokenIds, uint256[] amounts, string[] tokenURIs) external {\n        require(_mintingPermissions[msg.sender], \"Caller is not a minter\");\n        require(to.length == tokenIds.length && to.length == amounts.length && to.length == tokenURIs.length, \"Invalid input lengths\");\n\n        for (uint256 i = 0; i < to.length; i++) {\n            _mint(to[i], tokenIds[i], amounts[i], \"\");\n            _tokenURIs[tokenIds[i]] = tokenURIs[i];\n            _creators[tokenIds[i]] = msg.sender;\n            _totalSupplies[tokenIds[i]] += amounts[i];\n        }\n    }\n\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address receiver, uint256 royaltyAmount) {\n        receiver = _creators[tokenId];\n        royaltyAmount = (value * _globalRoyaltyRate) / 100;\n    }\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n}", "pragma solidity ^0.4.17;\n\nimport \"./ERC20Detailed.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\n\ncontract Ghost_Core_Finance is ERC20Detailed, Ownable {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    constructor(address initialOwner) ERC20Detailed(\"Ghost Core Finance\", \"GHCO\", 18) public {\n        _totalSupply = 1000000 * (10 ** uint256(decimals()));\n        _balances[initialOwner] = _totalSupply;\n        emit Transfer(address(0), initialOwner, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(value <= _balances[msg.sender], \"ERC20: transfer amount exceeds balance\");\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(value <= _balances[from], \"ERC20: transfer amount exceeds balance\");\n        require(value <= _allowed[from][msg.sender], \"ERC20: transfer amount exceeds allowance\");\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n\n    function burnFrom(address from, uint256 value) public {\n        _burn(from, value);\n    }\n\n    function _burn(address account, uint256 value) internal {\n        require(value <= _balances[account], \"ERC20: burn amount exceeds balance\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    function findOnePercent(uint256 value) public view returns (uint256) {\n        uint256 onePercent = value.mul(1).div(100);\n        return onePercent;\n    }\n}", "pragma solidity 0.4.17;\n\ninterface ERC721 {\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n    function approve(address to, uint256 tokenId) external;\n    function transfer(address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n}\n\ninterface ERC721Enumerable {\n    function totalSupply() external view returns (uint256);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    function ReentrancyGuard() internal {\n        _notEntered = true;\n    }\n\n    modifier nonReentrant() {\n        require(_notEntered);\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n}\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() public {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function renounceOwnership() public onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract Goofballs is ERC721, ERC721Enumerable, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    constructor(uint256 _maxSupply, uint256 _initialDrop, string _baseTokenURI) public {\n        maxSupply = _maxSupply;\n        initialDrop = _initialDrop;\n        baseTokenURI = _baseTokenURI;\n    }\n\n    uint256 public maxSupply;\n    uint256 public initialDrop;\n    string public baseTokenURI;\n    uint256 public totalSupply;\n    uint256 public reservedSupply;\n    uint256 public mintPrice;\n    uint256 public maxPurchase;\n    bool public isSaleActive;\n    address public reservedMinter;\n\n    mapping (uint256 => address) private _tokenOwners;\n    mapping (address => uint256) private _tokenBalances;\n\n    modifier saleActive {\n        require(isSaleActive, \"Sale is not active\");\n        _;\n    }\n\n    function setSaleActive(bool _state) external onlyOwner {\n        isSaleActive = _state;\n    }\n\n    function setMintPrice(uint256 _price) external onlyOwner {\n        mintPrice = _price;\n    }\n\n    function setMaxPurchase(uint256 _max) external onlyOwner {\n        maxPurchase = _max;\n    }\n\n    function mint(uint256 _quantity) external payable saleActive nonReentrant {\n        require(_quantity > 0 && _quantity <= maxPurchase, \"Invalid quantity\");\n        require(totalSupply.add(_quantity) <= maxSupply, \"Exceeds total supply\");\n        require(msg.value >= mintPrice.mul(_quantity), \"Insufficient Ether sent\");\n\n        // Mint logic\n        // Implement your minting logic here\n\n        totalSupply = totalSupply.add(_quantity);\n    }\n\n    function reserveMint(address _to, uint256 _quantity) external onlyOwner {\n        require(reservedMinter != address(0), \"Reserved minter not set\");\n        require(_quantity > 0 && reservedSupply.add(_quantity) <= maxSupply, \"Invalid quantity\");\n\n        // Reserved minting logic\n        // Implement your reserved minting logic here\n\n        reservedSupply = reservedSupply.add(_quantity);\n    }\n\n    function withdraw() external onlyOwner {\n        // Withdrawal logic\n        // Implement your withdrawal logic here\n    }\n\n    // Other ERC721 and ERC721Enumerable functions to be implemented according to the standards\n\n    // Implement ERC721 and ERC721Enumerable functions\n}", "pragma solidity 0.4.17;\n\nimport \"./IERC20.sol\";\nimport \"./IERC1155.sol\";\nimport \"./IERC20Wrapper.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./ReentrancyGuard.sol\";\n\ncontract WStakingRewards is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address public stakingRewardsContract;\n    address public underlyingERC20Token;\n    address public rewardToken;\n\n    mapping(uint256 => uint256) public conversionRates;\n    \n    modifier onlyStakingRewardsContract() {\n        require(msg.sender == stakingRewardsContract, \"Caller is not the staking rewards contract\");\n        _;\n    }\n\n    constructor(address _stakingRewardsContract, address _underlyingERC20Token, address _rewardToken) public {\n        stakingRewardsContract = _stakingRewardsContract;\n        underlyingERC20Token = _underlyingERC20Token;\n        rewardToken = _rewardToken;\n        IERC20(underlyingERC20Token).approve(stakingRewardsContract, uint256(-1));\n    }\n\n    function getUnderlyingERC20TokenForId(uint256 _id) public view returns (address) {\n        // Implementation to return the underlying ERC20 token for a given ERC1155 token id\n        // Add your logic here\n    }\n\n    function getConversionRate(uint256 _id) public view returns (uint256) {\n        return conversionRates[_id];\n    }\n\n    function wrapAndMint(uint256 _amount) external nonReentrant {\n        // Implementation for wrapping ERC20 into ERC1155 and minting\n        // Add your logic here\n    }\n\n    function burnAndUnwrap(uint256 _id) external nonReentrant {\n        // Implementation for burning ERC1155 and unwrapping into ERC20\n        // Add your logic here\n    }\n\n    function rewardPerToken() external onlyStakingRewardsContract {\n        // Implementation for calculating the reward per token\n        // Add your logic here\n    }\n\n    function distributeReward(address _user) external onlyStakingRewardsContract {\n        // Implementation for distributing rewards to a specific user\n        // Add your logic here\n    }\n}", "pragma solidity ^0.4.17;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721URIStorage.sol\";\nimport \"./Pausable.sol\";\nimport \"./Ownable.sol\";\n\ncontract legendary_tkn is ERC721, ERC721Enumerable, ERC721URIStorage, Pausable, Ownable {\n    \n    uint256 public constant maxSupply = 100;\n    uint256 public mintPrice = 0.15 ether;\n    uint256 public totalMinted;\n    string private baseURI;\n    \n    mapping(address => uint256) public presaleAllowance;\n    mapping(address => bool) public presaleWhitelist;\n    bool public presaleActive;\n    bool public publicSaleActive;\n    \n    modifier duringPresale {\n        require(presaleActive, \"Presale is not active\");\n        require(presaleWhitelist[msg.sender], \"Address not whitelisted for presale\");\n        require(presaleAllowance[msg.sender] > 0, \"Address has no presale allowance\");\n        _;\n    }\n    \n    modifier duringPublicSale {\n        require(publicSaleActive, \"Public sale is not active\");\n        _;\n    }\n    \n    function togglePresale(bool _status) external onlyOwner {\n        presaleActive = _status;\n    }\n    \n    function togglePublicSale(bool _status) external onlyOwner {\n        publicSaleActive = _status;\n    }\n    \n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n    \n    function setMintPrice(uint256 _newPrice) public onlyOwner {\n        mintPrice = _newPrice;\n    }\n    \n    function whitelistAddress(address _addr, uint256 _allowance) public onlyOwner {\n        presaleWhitelist[_addr] = true;\n        presaleAllowance[_addr] = _allowance;\n    }\n    \n    function mint() public payable duringPublicSale {\n        require(totalMinted < maxSupply, \"Token supply reached its limit\");\n        require(msg.value >= mintPrice, \"Insufficient funds sent\");\n        \n        _internalMint(msg.sender);\n    }\n    \n    function presaleMint() public payable duringPresale {\n        require(totalMinted < maxSupply, \"Token supply reached its limit\");\n        require(msg.value >= mintPrice, \"Insufficient funds sent\");\n        require(presaleAllowance[msg.sender] > 0, \"Address has no presale allowance\");\n        \n        presaleAllowance[msg.sender]--;\n        _internalMint(msg.sender);\n    }\n    \n    function withdrawBalance() public onlyOwner {\n        address payable ownerAddr = address(uint160(owner()));\n        ownerAddr.transfer(address(this).balance);\n    }\n    \n    function _internalMint(address _to) internal {\n        uint256 tokenId = totalMinted + 1;\n        _safeMint(_to, tokenId);\n        _setTokenURI(tokenId, string(abi.encodePacked(baseURI, tokenId.toString())));\n        totalMinted++;\n    }\n}", "pragma solidity 0.4.17;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./Pausable.sol\";\nimport \"./Ownable.sol\";\nimport \"./RoyaltiesV2Impl.sol\";\nimport \"./Counters.sol\";\n\ncontract FloydiesGenerative is ERC721, ERC721Enumerable, Pausable, Ownable, RoyaltiesV2Impl {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n    uint256 private constant MAX_MINT_PER_TX = 10;\n    uint256 private constant MAX_SUPPLY = 5000;\n    uint256 private constant MINT_PRICE = 0.006 ether;\n    string private _baseTokenURI;\n\n    struct RoyaltyInfo {\n        address recipient;\n        uint256 value;\n    }\n\n    mapping(uint256 => RoyaltyInfo[]) private _royalties;\n\n    constructor(string memory baseTokenURI) {\n        _baseTokenURI = baseTokenURI;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    function mintFloydies(uint256 quantity) external payable whenNotPaused {\n        require(quantity > 0, \"Quantity cannot be zero\");\n        require(quantity <= MAX_MINT_PER_TX, \"Exceeds max mint per transaction\");\n        require(_tokenIdCounter.current() + quantity <= MAX_SUPPLY, \"Exceeds max supply\");\n        require(msg.value == quantity * MINT_PRICE, \"Incorrect Ether value\");\n\n        for (uint256 i = 0; i < quantity; i++) {\n            _safeMint(msg.sender, _tokenIdCounter.current());\n            _tokenIdCounter.increment();\n        }\n    }\n\n    function setRoyalties(uint256 tokenId, LibPart.Part[] calldata _fees) external onlyOwner {\n        _saveRoyalties(tokenId, _fees);\n    }\n\n    function getRoyalties(uint256 tokenId) external view returns (LibPart.Part[] memory) {\n        return _royalties[tokenId];\n    }\n\n    function pauseContract() external onlyOwner {\n        _pause();\n    }\n\n    function unpauseContract() external onlyOwner {\n        _unpause();\n    }\n\n    function withdrawBalance(address payable recipient) external onlyOwner {\n        recipient.transfer(address(this).balance);\n    }\n}", "pragma solidity 0.4.17;\n\nimport \"@chainlink/contracts/src/v0.4/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract LobsterBeachClub is VRFConsumerBase, ERC721, ERC721Enumerable, ERC721URIStorage, Ownable {\n    // State variables\n    enum SalePhase { Inactive, Presale, PublicSale, Revealed }\n    SalePhase public salePhase;\n\n    uint256 public maxSupply;\n    uint256 public mintingFee;\n\n    address[] public presaleWhitelist;\n    mapping(address => bool) public presaleWhitelisted;\n\n    uint256 public promoTokensCount;\n\n    // Chainlink VRF variables\n    bytes32 internal keyHash;\n    uint256 internal fee;\n\n    // Events\n    event PresaleWhitelisted(address indexed account);\n    event Minted(address indexed to, uint256 tokenId);\n    event Revealed(uint256 indexed tokenId, bytes32 requestID);\n\n    // Constructor\n    constructor(address _vrfCoordinator, address _link, bytes32 _keyHash, uint256 _fee) \n    VRFConsumerBase(_vrfCoordinator, _link) {\n        keyHash = _keyHash;\n        fee = _fee;\n    }\n\n    // Modifiers\n    modifier duringPhase(SalePhase _phase) {\n        require(salePhase == _phase, \"Operation not allowed in this phase\");\n        _;\n    }\n\n    // Presale and Public Sale Management\n    function startPresale() external onlyOwner {\n        require(salePhase == SalePhase.Inactive, \"Presale already started\");\n        // Add logic to start presale\n        salePhase = SalePhase.Presale;\n    }\n\n    function endPresale() external onlyOwner duringPhase(SalePhase.Presale) {\n        // Add logic to end presale\n        salePhase = SalePhase.PublicSale;\n    }\n\n    function startPublicSale() external onlyOwner {\n        require(salePhase == SalePhase.Presale, \"Invalid phase to start public sale\");\n        // Add logic to start public sale\n        salePhase = SalePhase.PublicSale;\n    }\n\n    function endSale() external onlyOwner {\n        // Add logic to end the sale\n        salePhase = SalePhase.Revealed;\n    }\n\n    // Minting Functionality\n    function mint(uint256 _quantity) external payable duringPhase(SalePhase.Presale) {\n        // Add logic to mint tokens\n    }\n\n    // Promotional Tokens\n    function createPromoToken(address _recipient) external onlyOwner {\n        require(promoTokensCount < maxSupply, \"Maximum promo tokens created\");\n        // Add logic to create a promotional token\n    }\n\n    // Randomness for Reveal\n    function requestRandomNumber() external onlyOwner {\n        require(salePhase == SalePhase.PublicSale, \"Can only request in Public Sale phase\");\n        // Add logic to request random number from Chainlink VRF\n    }\n\n    function fulfillRandomness(bytes32 _requestID, uint256 _randomNumber) internal override {\n        require(_requestID == requestId, \"Fulfillment with wrong request ID\");\n        // Add logic to handle randomness fulfillment for revealing traits\n    }\n\n    // Dynamic NFT Metadata - URI Management\n    function setBaseURI(string memory _baseURI) external onlyOwner {\n        // Add logic to set the base URI for metadata\n    }\n\n    function _baseURI() internal view override(ERC721, ERC721URIStorage) returns (string memory) {\n        // Add logic to fetch base URI\n    }\n\n    function tokenURI(uint256 _tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\n        // Add logic to fetch token-specific URI\n    }\n}", "pragma solidity ^0.4.17;\n\nimport \"./ERC721.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Counters.sol\";\n\ncontract V1Phunks is ERC721, Ownable {\n    using SafeMath for uint256;\n    using Counters for Counters.Counter;\n\n    uint256 constant MAX_SUPPLY = 10000;\n    uint256 constant MAX_PER_MINT = 10;\n    uint256 constant FREE_STAGE_MINTING = 250;\n    uint256 constant PUBLIC_PRICE = 15000000000000000; // 0.015 ETH in Wei\n    uint256 constant MAX_RESERVED_MINTS = 500;\n\n    Counters.Counter private _tokenIdCounter;\n    mapping(address => uint256) private _reservedMints;\n    bool private _paused;\n    string private _baseTokenURI;\n\n    event TokenMinted(address indexed owner, uint256 indexed tokenId, uint256 timestamp);\n    event ContractPaused(bool paused);\n    event PriceChanged(uint256 newPrice);\n\n    modifier whenNotPaused() {\n        require(!_paused, \"Contract is paused\");\n        _;\n    }\n\n    function setBaseTokenURI(string memory baseTokenURI) public onlyOwner {\n        _baseTokenURI = baseTokenURI;\n    }\n\n    function _baseURI() internal view returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    function pauseContract() public onlyOwner {\n        _paused = true;\n        emit ContractPaused(true);\n    }\n\n    function unpauseContract() public onlyOwner {\n        _paused = false;\n        emit ContractPaused(false);\n    }\n\n    function changePrice(uint256 newPrice) public onlyOwner {\n        PUBLIC_PRICE = newPrice;\n        emit PriceChanged(newPrice);\n    }\n\n    function reserveTokens(address recipient, uint256 amount) public onlyOwner {\n        require(_tokenIdCounter.current().add(amount) <= MAX_SUPPLY, \"Exceeds MAX_SUPPLY\");\n        require(_reservedMints[recipient].add(amount) <= MAX_RESERVED_MINTS, \"Exceeds MAX_RESERVED_MINTS\");\n\n        for (uint256 i = 0; i < amount; i++) {\n            _reservedMints[recipient]++;\n            _safeMint(recipient, _tokenIdCounter.current());\n            emit TokenMinted(recipient, _tokenIdCounter.current(), now);\n            _tokenIdCounter.increment();\n        }\n    }\n\n    function mint() public payable whenNotPaused {\n        uint256 totalSupply = _tokenIdCounter.current();\n\n        require(totalSupply < MAX_SUPPLY, \"MAX_SUPPLY reached\");\n        require(msg.value >= PUBLIC_PRICE, \"Insufficient funds\");\n\n        if (totalSupply < FREE_STAGE_MINTING) {\n            require(totalSupply.add(MAX_PER_MINT) <= FREE_STAGE_MINTING, \"Exceeds FREE_STAGE_MINTING\");\n        } else {\n            require(totalSupply.add(MAX_PER_MINT) <= MAX_SUPPLY, \"Exceeds MAX_SUPPLY\");\n        }\n\n        for (uint256 i = 0; i < MAX_PER_MINT; i++) {\n            if (totalSupply < FREE_STAGE_MINTING) {\n                _safeMint(msg.sender, _tokenIdCounter.current());\n            } else {\n                _safeMint(msg.sender, _tokenIdCounter.current());\n                msg.sender.transfer(msg.value.sub(PUBLIC_PRICE));\n            }\n            emit TokenMinted(msg.sender, _tokenIdCounter.current(), now);\n            _tokenIdCounter.increment();\n            totalSupply++;\n        }\n    }\n\n    function withdrawBalance() public onlyOwner {\n        address payable owner = address(uint160(owner()));\n        owner.transfer(address(this).balance);\n    }\n\n    // Additional functions can be added as needed based on the requirements\n}", "pragma solidity ^0.4.17;\n\ncontract OKEXTOKEN {\n    string public name = \"EXTOKEN\";\n    string public symbol = \"0KB\";\n    uint8 public decimals = 4;\n    \n    uint256 public totalSupply = 90000000000 * 10**uint256(decimals); // 90 billion tokens\n    \n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Burn(address indexed burner, uint256 value);\n\n    address public owner;\n\n    function OKEXTOKEN() public {\n        owner = msg.sender;\n        balanceOf[owner] = totalSupply;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        require(_to != address(0), \"Cannot transfer to zero address\");\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        \n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        \n        emit Transfer(msg.sender, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public {\n        require(_to != address(0), \"Cannot transfer to zero address\");\n        require(balanceOf[_from] >= _value, \"Insufficient balance\");\n        require(allowance[_from][msg.sender] >= _value, \"Allowance exceeded\");\n        \n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        \n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n    }\n\n    function burn(uint256 _value) public {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance to burn\");\n        \n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        \n        emit Burn(msg.sender, _value);\n    }\n\n    function burnFrom(address _from, uint256 _value) public {\n        require(balanceOf[_from] >= _value, \"Insufficient balance to burn\");\n        require(allowance[_from][msg.sender] >= _value, \"Allowance exceeded\");\n        \n        balanceOf[_from] -= _value;\n        totalSupply -= _value;\n        \n        allowance[_from][msg.sender] -= _value;\n        emit Burn(_from, _value);\n    }\n}", "pragma solidity 0.4.17;\n\ninterface ERC721Enumerable {\n    // ERC721Enumerable interface functions\n}\n\ncontract Ownable {\n    // Ownable contract functions\n}\n\ncontract AshesOfLight is ERC721Enumerable, Ownable {\n    // State variables\n    string public baseURI;\n    uint256 public mintPrice;\n    uint256 public maxMintPerTx;\n    uint256 public maxMintPerAddress;\n    uint256 public totalSupplyCap;\n    bool public paused;\n\n    // Mapping to store reveal status of each token\n    mapping(uint256 => bool) public revealStatus;\n\n    // Mapping to store whitelist status for each address\n    mapping(address => bool) public whitelist;\n\n    // Mapping to store reward status for each address\n    mapping(address => bool) public rewards;\n\n    // Events\n    event Mint(address indexed minter, uint256 amount);\n    event Reveal(uint256 indexed tokenId);\n    event WhitelistUpdated(address indexed addr, bool status);\n    event RewardUpdated(address indexed addr, bool status);\n    event Pause(bool status);\n\n    // Constructor\n    constructor() public {\n        // Initialize contract with default values\n        baseURI = \"\";\n        mintPrice = 0.1 ether;\n        maxMintPerTx = 5;\n        maxMintPerAddress = 20;\n        totalSupplyCap = 1000;\n        paused = false;\n    }\n\n    // Modifiers\n    modifier notPaused() {\n        require(!paused, \"Minting is paused\");\n        _;\n    }\n\n    // Function to mint NFTs\n    function mint(uint256 amount) external payable notPaused {\n        // Implement minting logic\n    }\n\n    // Function to update reveal status of NFT\n    function updateRevealStatus(uint256 tokenId) external onlyOwner {\n        // Implement reveal status update\n    }\n\n    // Function to update whitelist status of an address\n    function updateWhitelistStatus(address addr, bool status) external onlyOwner {\n        // Implement whitelist status update\n    }\n\n    // Function to update reward status of an address\n    function updateRewardStatus(address addr, bool status) external onlyOwner {\n        // Implement reward status update\n    }\n\n    // Function to pause/unpause minting\n    function togglePause() external onlyOwner {\n        paused = !paused;\n        emit Pause(paused);\n    }\n\n    // Function to withdraw contract balance\n    function withdraw(address receiver) external onlyOwner {\n        // Implement withdrawal logic\n    }\n\n    // Other functions as per the requirements\n\n    // Implement base URI management, ownership utilities, security considerations, and economic model as specified\n}"]