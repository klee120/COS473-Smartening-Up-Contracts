[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract Bitfex_Token is ERC20, MinterRole {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    // Sets the values for `name`, `symbol`, and `decimals`. All three of these values are immutable: they can only be set once during construction.\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    // Returns the name of the token.\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    // Returns the symbol of the token, usually a shorter version of the name.\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    // Returns the number of decimals used to get its user representation.\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n   \n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract VectorField is ERC721URIStorage, VRFConsumerBase, Ownable {\n    uint256 public tokenCounter;\n    uint256 public constant MAX_SUPPLY = 300;\n    uint256 public constant PRICE = .25 ether;\n    \n    mapping(bytes32 => address) public requestIdToSender;\n    mapping(uint256 => uint256) public tokenIdToRandomNumber;\n    mapping(bytes32 => uint256) public requestIdToTokenId;\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public height;\n    uint256 public price;\n    uint256 public width;\n    string[] public colors;\n\n    constructor(address _VRFCoordinator, address _LinkToken, bytes32 _keyhash, uint256 _fee) \n    VRFConsumerBase(_VRFCoordinator, _LinkToken)\n    ERC721(\"Vector Field\", \"VCFD\")\n    {\n        tokenCounter = 1;\n        keyHash = _keyhash;\n        fee = _fee;\n        price = PRICE;\n        height = 2000;\n        width = 1500;\n        colors = [\n\"#FAFAFA\",\n\"#F5F5F5\",\n\"#EEEEEE\",\n\"#E0E0E0\",\n\"#BDBDBD\",\n\"#9E9E9E\",\n\"#757575\",\n\"#616161\",\n\"#424242\",\n\"#212121\",\n\"#ECEFF1\",\n\"#CFD8DC\",\n\"#B0BEC5\",\n\"#90A4AE\",\n\"#78909C\",\n\"#607D8B\",\n\"#546E7A\",\n\"#455A64\",\n\"#37474F\",\n\"#263238\",\n\"#b71c1c\",\n\"#DB3A3D\",\n\"#E1C1A7\",\n\"#D88C73\",\n\"#D0C1AB\"\n];\n    }\n    \n       \n function withdraw() public payable onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n   \n    function Claim() public payable returns (bytes32 requestId) {\n        require(msg.value >= price, \"Please send more ETH\");\n        require(tokenCounter <= MAX_SUPPLY, \"All Fields have been minted\");\n        requestId = requestRandomness(keyHash, fee);\n        requestIdToSender[requestId] = msg.sender;\n        uint256 tokenId = tokenCounter; \n        requestIdToTokenId[requestId] = tokenId;\n        tokenCounter = tokenCounter + 1;\n        \n    }\n\n    function Mint(uint256 tokenId) public {\n        require(bytes(tokenURI(tokenId)).length <= 0, \"tokenURI is already set!\"); \n        require(tokenCounter > tokenId, \"TokenId has not been minted yet!\");\n        require(tokenIdToRandomNumber[tokenId] > 0, \"Need to wait for the Chainlink node to respond!\");\n        uint256 randomNumber = tokenIdToRandomNumber[tokenId];\n        string memory svg = generateSVG(randomNumber);\n        string memory TokenID = uint2str(tokenId);\n        string memory imageURI = svgToImageURI(svg);\n        _setTokenURI(tokenId, formatTokenURI(imageURI, TokenID));\n        \n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomNumber) internal override {\n        address nftOwner = requestIdToSender[requestId];\n        uint256 tokenId = requestIdToTokenId[requestId];\n        _safeMint(nftOwner, tokenId);\n        tokenIdToRandomNumber[tokenId] = randomNumber;\n        \n    }\n\n    function generateSVG(uint256 _randomness) public view returns (string memory finalSvg) {\n       uint256 bgopacity = uint256(keccak256(abi.encode(_randomness + 1))) % 6;\n        finalSvg = string(abi.encodePacked(\"<svg xmlns='http://www.w3.org/2000/svg' height='\", uint2str(height), \"' width='\", uint2str(width), \"' fill='none' viewBox='500 100 1500 2000'><path d='M500 100h1500v2000H0z' fill= '#f4ebe2'/><path d='M500 100h1500v2000H0z'\"));\n        string memory color = colors[_randomness % colors.length];\n        \n        finalSvg = string(abi.encodePacked(finalSvg, \" fill='\", color, \"' opacity='.\", uint2str(bgopacity), \"'/>\"));\n        \n        for(uint i = 0; i < 3; i++) {\n           \n            string memory pathSvg = generatePath(uint256(keccak256(abi.encode(_randomness, i))));\n            finalSvg = string(abi.encodePacked(finalSvg, pathSvg));\n        }\n        finalSvg = string(abi.encodePacked(finalSvg, \"</svg>\"));\n    }\n\n    function generatePath(uint256 _randomness) public view returns(string memory pathSvg) {\n        uint256 x = uint256(keccak256(abi.encode(_randomness, height * 2 + 1))) % width;\n        uint256 y = uint256(keccak256(abi.encode(_randomness, width + 1))) % height;\n        uint256 w = uint256(keccak256(abi.encode(_randomness, width + 3))) % width;\n        uint256 h = uint256(keccak256(abi.encode(_randomness, height * 3 + 1))) % height;\n        uint256 opacity = uint256(keccak256(abi.encode(_randomness + 2))) % 9;\n\n        pathSvg = string(abi.encodePacked( \"<rect x='\", uint2str(x), \"' y= '\", uint2str(y),\"' width= '\", uint2str(w), \"' height='\", uint2str(h), \"' opacity='.\", uint2str(opacity), \"'\"));\n\n        string memory color = colors[_randomness % colors.length];\n        pathSvg = string(abi.encodePacked(pathSvg, \" fill='\", color,\"'/>\"));\n    }\n\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function svgToImageURI(string memory svg) public pure returns (string memory) {\n        string memory baseURL = \"data:image/svg+xml;base64,\";\n        string memory svgBase64Encoded = Base64.encode(bytes(string(abi.encodePacked(svg))));\n        return string(abi.encodePacked(baseURL,svgBase64Encoded));\n    }\n\n    function formatTokenURI(string memory imageURI, string memory TokenID) public pure returns (string memory) {\n        return string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"Field #',TokenID,'\", \"description\":\"300 Vector Fields randomly generated and stored on the Ethereum blockchain\", \"attributes\":\"\", \"image\":\"',imageURI,'\"}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    }\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    // Function to check the amount of tokens that an owner allowed to a spender. Param owner address The address which owns the funds. Param spender address The address which will spend the funds. return A uint256 specifying the amount of tokens still available for the spender.\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    // Transfer token to a specified address. Param to The address to transfer to. Param value The amount to be transferred.\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: Param spender The address which will spend the funds. Param value The amount of tokens to be spent.\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    // Transfer tokens from one address to another. Note that while this function emits an Approval event, this is not required as per the specification, and other compliant implementations may not emit the event. Param from address The address which you want to send tokens from param to address The address which you want to transfer to param value uint256 the amount of tokens to be transferred\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n    // Increase the amount of tokens that an owner allowed to a spender. Approve should be called when _allowed[msg.sender][spender] == 0. \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    // Decrease the amount of tokens that an owner allowed to a spender.\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    // Transfer token for a specified addresses.\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    // Internal function that mints an amount of the token and assigns it to an account\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    // Internal function that burns an amount of the token of a given account.\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    // Approve an address to spend another addresses' tokens.\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n\n        _allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    // Internal function that burns an amount of the token of a given account, deducting from the sender's allowance for said account. \n    function _burnFrom(address account, uint256 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract Strategy_YFI_DForceUSDT {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    \n    address constant public want = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    address constant public d = address(0x868277d475E0e475E38EC5CdA2d9C83B5E1D9fc8);\n    address constant public pool = address(0x324EebDAa45829c6A8eE903aFBc7B61AF48538df);\n    address constant public df = address(0x431ad2ff6a9C365805eBaD47Ee021148d6f7DBe0);\n    address constant public uni = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address constant public weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    \n    uint public performanceFee = 5000;\n    uint constant public performanceMax = 10000;\n    \n    uint public withdrawalFee = 50;\n    uint constant public withdrawalMax = 10000;\n    \n    address public governance;\n    address public controller;\n    address public strategist;\n    \n    constructor(address _controller) public {\n        governance = msg.sender;\n        strategist = msg.sender;\n        controller = _controller;\n    }\n    \n    function getName() external pure returns (string memory) {\n        return \"StrategyDForceUSDT\";\n    }\n    \n    function setStrategist(address _strategist) external {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n    \n    function setWithdrawalFee(uint _withdrawalFee) external {\n        require(msg.sender == governance, \"!governance\");\n        withdrawalFee = _withdrawalFee;\n    }\n    \n    function setPerformanceFee(uint _performanceFee) external {\n        require(msg.sender == governance, \"!governance\");\n        performanceFee = _performanceFee;\n    }\n    \n    function deposit() public {\n        uint _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            IERC20(want).safeApprove(d, 0);\n            IERC20(want).safeApprove(d, _want);\n            IDERC20(d).mint(address(this), _want);\n        }\n        \n        uint _d = IERC20(d).balanceOf(address(this));\n        if (_d > 0) {\n            IERC20(d).safeApprove(pool, 0);\n            IERC20(d).safeApprove(pool, _d);\n            IDRewards(pool).stake(_d);\n        }\n        \n    }\n    \n    // Controller only function for creating additional rewards from dust\n    function withdraw(IERC20 _asset) external returns (uint balance) {\n        require(msg.sender == controller, \"!controller\");\n        require(want != address(_asset), \"want\");\n        require(d != address(_asset), \"d\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(controller, balance);\n    }\n    \n    // Withdraw partial funds, normally used with a vault withdrawal\n    function withdraw(uint _amount) external {\n        require(msg.sender == controller, \"!controller\");\n        uint _balance = IERC20(want).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n        \n        uint _fee = _amount.mul(withdrawalFee).div(withdrawalMax);\n        \n        \n        IERC20(want).safeTransfer(Controller(controller).rewards(), _fee);\n        address _vault = Controller(controller).vaults(address(want));\n        require(_vault != address(0), \"!vault\"); // additional protection so we don't burn the funds\n        \n        IERC20(want).safeTransfer(_vault, _amount.sub(_fee));\n    }\n    \n    // Withdraw all funds, normally used when migrating strategies\n    function withdrawAll() external returns (uint balance) {\n        require(msg.sender == controller, \"!controller\");\n        _withdrawAll();\n        \n        \n        balance = IERC20(want).balanceOf(address(this));\n        \n        address _vault = Controller(controller).vaults(address(want));\n        require(_vault != address(0), \"!vault\"); // additional protection so we don't burn the funds\n        IERC20(want).safeTransfer(_vault, balance);\n    }\n    \n    function _withdrawAll() internal {\n        IDRewards(pool).exit();\n        uint _d = IERC20(d).balanceOf(address(this));\n        if (_d > 0) {\n            IDERC20(d).redeem(address(this),_d);\n        }\n    }\n    \n    function harvest() public {\n        require(msg.sender == strategist || msg.sender == governance, \"!authorized\");\n        IDRewards(pool).getReward();\n        uint _df = IERC20(df).balanceOf(address(this));\n        if (_df > 0) {\n            IERC20(df).safeApprove(uni, 0);\n            IERC20(df).safeApprove(uni, _df);\n            \n            address[] memory path = new address[](3);\n            path[0] = df;\n            path[1] = weth;\n            path[2] = want;\n            \n            IUniV2(uni).swapExactTokensForTokens(_df, uint(0), path, address(this), now.add(1800));\n        }\n        uint _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            uint _fee = _want.mul(performanceFee).div(performanceMax);\n            IERC20(want).safeTransfer(Controller(controller).rewards(), _fee);\n            deposit();\n        }\n    }\n    \n    function _withdrawSome(uint256 _amount) internal returns (uint) {\n        uint _d = _amount.mul(1e18).div(IDERC20(d).getExchangeRate());\n        uint _before = IERC20(d).balanceOf(address(this));\n        IDRewards(pool).withdraw(_d);\n        uint _after = IERC20(d).balanceOf(address(this));\n        uint _withdrew = _after.sub(_before);\n        _before = IERC20(want).balanceOf(address(this));\n        IDERC20(d).redeem(address(this), _withdrew);\n        _after = IERC20(want).balanceOf(address(this));\n        _withdrew = _after.sub(_before);\n        return _withdrew;\n    }\n    \n    function balanceOfWant() public view returns (uint) {\n        return IERC20(want).balanceOf(address(this));\n    }\n    \n    function balanceOfPool() public view returns (uint) {\n        return (IDRewards(pool).balanceOf(address(this))).mul(IDERC20(d).getExchangeRate()).div(1e18);\n    }\n    \n    function getExchangeRate() public view returns (uint) {\n        return IDERC20(d).getExchangeRate();\n    }\n    \n    function balanceOfD() public view returns (uint) {\n        return IDERC20(d).getTokenBalance(address(this));\n    }\n    \n    function balanceOf() public view returns (uint) {\n        return balanceOfWant()\n               .add(balanceOfD())\n               .add(balanceOfPool());\n    }\n    \n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n    \n    function setController(address _controller) external {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract Legends_of_Crypto is ERC20Detailed {\n\n  using SafeMath for uint256;\n  mapping (address => uint256) private _balances;\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  string constant tokenName = \"Legends of Crypto\";\n  string constant tokenSymbol = \"LOCG\";\n  uint8  constant tokenDecimals = 18;\n  uint256 _totalSupply = 150000000000000000000000000;\n  uint256 public basePercent = 100;\n\n  constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n    _mint(msg.sender, _totalSupply);\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  function allowance(address owner, address spender) public view returns (uint256) {\n    return _allowed[owner][spender];\n  }\n\n  function findOnePercentb(uint256 value) public view returns (uint256)  {\n    uint256 roundValue = value.ceil(basePercent);\n    uint256 onePercent = roundValue.mul(basePercent).div(10000);\n    return onePercent;\n  }\n\n  function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender]);\n    require(to != address(0));\n\n    uint256 tokensToBurn = 0;\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(tokensToTransfer);\n\n    _totalSupply = _totalSupply.sub(tokensToBurn);\n\n    emit Transfer(msg.sender, to, tokensToTransfer);\n    emit Transfer(msg.sender, address(0), tokensToBurn);\n    return true;\n  }\n\n  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n    for (uint256 i = 0; i < receivers.length; i++) {\n      transfer(receivers[i], amounts[i]);\n    }\n  }\n\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n\n    uint256 tokensToBurn = 0;\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n    _balances[to] = _balances[to].add(tokensToTransfer);\n    _totalSupply = _totalSupply.sub(tokensToBurn);\n\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n    emit Transfer(from, to, tokensToTransfer);\n    emit Transfer(from, address(0), tokensToBurn);\n\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  // 1-time token mint/creation function. Tokens are only minted during contract creation, and cannot be done again.\n  function _mint(address account, uint256 amount) internal {\n    require(amount != 0);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal {\n    require(amount != 0);\n    require(amount <= _balances[account]);\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[account] = _balances[account].sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function burnFrom(address account, uint256 amount) external {\n    require(amount <= _allowed[account][msg.sender]);\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);\n    _burn(account, amount);\n  }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract GrouchyTigerCubs is ERC721, ERC721Enumerable, ERC721Burnable, Ownable {\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n  uint256 public cost = 0.01 ether;\n\n  constructor() ERC721(\"GrouchyTigerCubs\", \"GTSCC\") {}\n\n  function _baseURI() internal pure override returns (string memory) {\n      return \"https://grouchytigersocialclub.com/cubs/metadata/\";\n  }\n\n  function safeMint(address to) public payable {\n      uint256 tokenId = _tokenIdCounter.current();\n\n      require(msg.value >= cost);\n\n      _tokenIdCounter.increment();\n      _safeMint(to, tokenId);\n  }\n\n  function setCost(uint256 _newCost) public onlyOwner {\n      cost = _newCost;\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n      super._beforeTokenTransfer(from, to, tokenId);\n  }\n\n  function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n      return super.supportsInterface(interfaceId);\n  }\n  \n  function withdraw() public payable onlyOwner {\n      (bool success, ) = payable(msg.sender).call{\n          value: address(this).balance\n      }(\"\");\n      require(success);\n  }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => Account) _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    \n    struct Account {\n        uint256 total;\n        uint256 locked;\n        uint32 release_time;\n    }\n\n    // Total number of tokens in existence.\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    // Gets the balance of the specified address.\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner].total;\n    }\n    \n    function lockedOf(address owner) public view returns(uint256) {\n        return _balances[owner].locked;\n    }\n\n    // Function to check the amount of tokens that an owner allowed to a spender.\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    // Transfer token to a specified address.\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    // Transfer tokens from one address to another.\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\n        return true;\n    }\n\n    // Increase the amount of tokens that an owner allowed to a spender.\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    // Decrease the amount of tokens that an owner allowed to a spender.\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    // Transfer token for a specified addresses.\n    function _transfer(address from, address to, uint256 value) internal {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        uint256 total;\n        if(_balances[from].locked>0) {\n            //release time reached\n            if(_balances[from].release_time<block.timestamp) {\n                _balances[from].locked = 0;\n                total = _balances[from].total;\n            }else {\n                total = _balances[from].total.sub(_balances[from].locked);\n            }\n        }else {\n            total = _balances[from].total;\n        }\n        _balances[from].total = total.sub(value).add(_balances[from].locked);\n        _balances[to].total = _balances[to].total.add(value);\n        emit Transfer(from, to, value);\n    }\n\n    // Internal function that mints an amount of the token and assigns it to an account.\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account].total = _balances[account].total.add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    // Internal function that burns an amount of the token of a given account.\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        uint256 total;\n        if(_balances[account].locked>0) {\n            //release time reached\n            if(_balances[account].release_time<block.timestamp) {\n                _balances[account].locked = 0;\n                total = _balances[account].total;\n            }else {\n                total = _balances[account].total.sub(_balances[account].locked);\n            }\n        }else {\n            total = _balances[account].total;\n        }\n        \n        _totalSupply = _totalSupply.sub(value);\n        _balances[account].total = total.sub(value).add(_balances[account].locked);\n        emit Transfer(account, address(0), value);\n    }\n\n    // Approve an address to spend another addresses' tokens.\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    // Internal function that burns an amount of the token of a given account, deducting from the sender's allowance for said account. \n    function _burnFrom(address account, uint256 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));\n    }\n    \n    function _lockTransfer(address account, uint256 value,uint32 release_time) internal {\n        transfer(account, value);\n        require(_balances[account].total >= _balances[account].locked.add(value));\n        _balances[account].locked = _balances[account].locked.add(value);\n        _balances[account].release_time = release_time;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract ANTIHYPE is ERC20Detailed {\n\n  using SafeMath for uint256;\n    \n\n  \n  mapping (address => uint256) private _balances;\n  mapping (address => mapping (address => uint256)) private _allowed;\n  string constant tokenName = \"ANTIHYPE Token\";\n  string constant tokenSymbol = \"ANTIHYPE\";\n  uint8  constant tokenDecimals = 18;\n  uint256 constant eighteen = 1000000000000000000;\n  uint256 _totalSupply = 10000 * eighteen;\n  \n  //any tokens sent here ? \n  IERC20 currentToken ;\n  \taddress payable public _owner;\n    \n    //modifiers\t\n\tmodifier onlyOwner() {\n      require(msg.sender == _owner);\n      _;\n  }\n  \n  \n    \n  \n\n  constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n      \n    _owner = msg.sender;\n    require(_totalSupply != 0);\n    //create initialSupply\n    _balances[_owner] = _balances[_owner].add(_totalSupply);\n    emit Transfer(address(0), _owner, _totalSupply);\n    \n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  function allowance(address owner, address spender) public view returns (uint256) {\n    return _allowed[owner][spender];\n  }\n\n\n function transfer(address to, uint256 value) public returns (bool) \n    {\n        _executeTransfer(msg.sender, to, value);\n        return true;\n    }\n    \n    function multiTransfer(address[] memory receivers, uint256[] memory values) public\n    {\n        require(receivers.length == values.length);\n        for(uint256 i = 0; i < receivers.length; i++)\n            _executeTransfer(msg.sender, receivers[i], values[i]);\n    }\n    \n    function transferFrom(address from, address to, uint256 value) public returns (bool) \n    {\n        require(value <= _allowed[from][msg.sender]);\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _executeTransfer(from, to, value);\n        return true;\n    }\n   \n\n\n\n\n    //   transfer \n    function _executeTransfer(address _from, address _to, uint256 _value) private\n    {\n        if (_to == address(0)) revert();                               // Prevent transfer to 0x0 address. Use burn() instead\n\t\tif (_value <= 0) revert(); \n        if (_balances[_from] < _value) revert();           // Check if the sender has enough\n        if (_balances[_to] + _value < _balances[_to]) revert(); // Check for overflows\n        \n        _balances[_from] = SafeMath.sub(_balances[_from], _value);                     // Subtract from the sender\n        _balances[_to] = SafeMath.add(_balances[_to], _value);                            // Add the same to the recipient\n        \n\n        emit Transfer(_from, _to, _value);                   // Notify anyone listening that this transfer took place\n    }  \n\n\n\n\n\n\n  \n  \n  \n  //no zeros for decimals necessary \n  function multiTransferEqualAmount(address[] memory receivers, uint256 amount) public {\n    uint256 amountWithDecimals = amount * 10**uint256(tokenDecimals);\n\n    for (uint256 i = 0; i < receivers.length; i++) {\n      transfer(receivers[i], amountWithDecimals);\n    }\n  }\n\n\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  \n  \n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n\n\n\t\n        \n //take back unclaimed tokens\n  function withdrawUnclaimedTokens(address contractUnclaimed) external onlyOwner {\n      currentToken = IERC20(contractUnclaimed);\n      uint256 amount = currentToken.balanceOf(address(this));\n      currentToken.transfer(_owner, amount);\n  }\n   \n    \n\n\n\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract DCREDITY is SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    address public owner;\n\n    /* This creates an array with all balances */\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) public freezeOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /* This notifies clients about the amount burnt */\n    event Burn(address indexed from, uint256 value);\n\n    /* This notifies clients about the amount frozen */\n    event Freeze(address indexed from, uint256 value);\n\n    /* This notifies clients about the amount unfrozen */\n    event Unfreeze(address indexed from, uint256 value);\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    constructor() public {\n        balanceOf[msg.sender] = 5000000000000; // Give the creator all initial tokens\n        totalSupply = 5000000000000; // Update total supply\n        name = \"ycredit\"; // Set the name for display purposes\n        symbol = \"YCR\"; // Set the symbol for display purposes\n        decimals = 8; // Amount of decimals for display purposes\n        owner = msg.sender;\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        if (_to == 0x0) return false; // Prevent transfer to 0x0 address. Use burn() instead\n        if (_value <= 0) return false;\n        if (balanceOf[msg.sender] < _value) revert(); // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); // Check for overflows\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); // Subtract from the sender\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value); // Add the same to the recipient\n        emit Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens in your behalf */\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require((_value == 0) || (allowance[msg.sender][_spender] == 0));\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /* Transfer tokens */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        if (_to == 0x0) revert(); // Prevent transfer to 0x0 address. Use burn() instead\n        if (_value <= 0) revert();\n        if (balanceOf[_from] < _value) revert(); // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); // Check for overflows\n        if (_value > allowance[_from][msg.sender]) revert(); // Check allowance\n        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value); // Subtract from the sender\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value); // Add the same to the recipient\n        allowance[_from][msg.sender] = SafeMath.safeSub(\n            allowance[_from][msg.sender],\n            _value\n        );\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /* Destruction of the token */\n    function burn(uint256 _value) public returns (bool success) {\n        if (balanceOf[msg.sender] < _value) revert(); // Check if the sender has enough\n        if (_value <= 0) revert();\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); // Subtract from the sender\n        totalSupply = SafeMath.safeSub(totalSupply, _value); // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function freeze(uint256 _value) public returns (bool success) {\n        if (balanceOf[msg.sender] < _value) revert(); // Check if the sender has enough\n        if (_value <= 0) revert();\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value); // Subtract from the sender\n        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value); // Updates frozen tokens\n        emit Freeze(msg.sender, _value);\n        return true;\n    }\n\n    function unfreeze(uint256 _value) public returns (bool success) {\n        if (freezeOf[msg.sender] < _value) revert(); // Check if the sender has enough\n        if (_value <= 0) revert();\n        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value); // Updates frozen tokens\n        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); // Add to the sender\n        emit Unfreeze(msg.sender, _value);\n        return true;\n    }\n\n    function() public {\n        revert();\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract REGUDEFI is ERC20, Ownable {\n    using SafeMath for uint256;\n\n    IUniswapV2Router02 public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n\n    mapping (address => bool) public isSniper;\n    bool private _swapping;\n    uint256 private _launchTime;\n\n    address public feeWallet;\n    address public burnAddress = 0x000000000000000000000000000000000000dEaD;\n    \n    uint256 public maxTransactionAmount;\n    uint256 public swapTokensAtAmount;\n    uint256 public maxWallet;\n        \n    bool public limitsInEffect = true;\n    bool public dynamicFeesInEffect = false;\n    bool public tradingActive = false;\n\n    uint256 public fireSaleActive;\n    uint256 public fireSaleTimer;\n    uint256 public fireSaleAmt;\n    uint256 public fireSaleRequirement;\n\n    uint256 public resetRequirement;\n    mapping (address => uint256) public userBurned;\n\n    uint256 public buyFeeThreshold;\n    uint256 public buyFeeRate;\n    uint256 public buyTotalFees;\n    uint256 private _buyMarketingFee;\n    uint256 private _buyLiquidityFee;\n    uint256 private _buyDevFee;\n    \n    uint256 public sellFeeThreshold;\n    uint256 public sellFeeRate;\n    uint256 public sellTotalFees;\n    uint256 private _sellMarketingFee;\n    uint256 private _sellLiquidityFee;\n    uint256 private _sellDevFee;\n    \n    uint256 private _tokensForMarketing;\n    uint256 private _tokensForLiquidity;\n    uint256 private _tokensForDev;\n\n    // exlcude from fees and max transaction amount\n    mapping (address => bool) public isExcludedFromFees;\n    mapping (address => bool) public isExcludedMaxTransactionAmount;\n\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\n    // could be subject to a maximum transfer amount\n    mapping (address => bool) public automatedMarketMakerPairs;\n\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\n    event Burn(uint256 burnAmount);\n    event FeesReset();\n    event FireSaleBy(address user);\n    event FireSale();\n\n    constructor() ERC20(\"Regulated DeFi\", \"REGU\") {\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        \n        isExcludedMaxTransactionAmount[address(_uniswapV2Router)] = true;\n        uniswapV2Router = _uniswapV2Router;\n        \n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n        isExcludedMaxTransactionAmount[address(uniswapV2Pair)] = true;\n        automatedMarketMakerPairs[address(uniswapV2Pair)] = true;\n\n        uint256 totalSupply = 1e9 * 1e9;\n        \n        _buyMarketingFee = 6;\n        _buyLiquidityFee = 2;\n        _buyDevFee = 2;\n        buyTotalFees = _buyMarketingFee + _buyLiquidityFee + _buyDevFee;\n        \n        _sellMarketingFee = 6;\n        _sellLiquidityFee = 2;\n        _sellDevFee = 2;\n        sellTotalFees = _sellMarketingFee + _sellLiquidityFee + _sellDevFee;\n\n        buyFeeRate = totalSupply * 5 / 1000;  // 0.5%\n        sellFeeRate = totalSupply * 25 / 10000;  // 0.25%\n\n        resetRequirement = totalSupply * 1 / 10000;  // 0.01%\n        fireSaleRequirement = totalSupply * 1 / 100;  // 1%\n\n        maxTransactionAmount = totalSupply * 1 / 100; // 1%\n        maxWallet = totalSupply * 2 / 100; // 2%\n        swapTokensAtAmount = totalSupply * 2 / 1000; // 0.2%\n        \n        feeWallet = address(owner());\n\n        // exclude from paying fees or having max transaction amount\n        excludeFromFees(owner(), true);\n        excludeFromFees(address(this), true);\n        excludeFromFees(address(burnAddress), true);\n        \n        isExcludedMaxTransactionAmount[owner()] = true;\n        isExcludedMaxTransactionAmount[address(this)] = true;\n        isExcludedMaxTransactionAmount[address(burnAddress)] = true;\n        \n        // _mint is an internal function in ERC20.sol that is only called here,\n        // and CANNOT be called ever again\n        _mint(msg.sender, totalSupply);\n    }\n\n    // once enabled, can never be turned off\n    function enableTrading() external onlyOwner {\n        tradingActive = true;\n        _launchTime = block.timestamp + 1; //Let's make sure the snipers don't just set 1 block ahead\n    }\n    \n    // remove limits after token is stable\n    function removeLimits() external onlyOwner returns (bool) {\n        limitsInEffect = false;\n        dynamicFeesInEffect = true;\n        fireSaleTimer = block.timestamp + 1 days;\n        return true;\n    }\n    \n     // change the minimum amount of tokens to sell from fees\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool) {\n  \t    require(newAmount >= totalSupply() * 1 / 100000, \"Swap amount cannot be lower than 0.001% total supply.\");\n  \t    require(newAmount <= totalSupply() * 5 / 1000, \"Swap amount cannot be higher than 0.5% total supply.\");\n  \t    swapTokensAtAmount = newAmount;\n  \t    return true;\n  \t}\n    \n    function excludeFromFees(address account, bool excluded) public onlyOwner() {\n        isExcludedFromFees[account] = excluded;\n    }\n    \n    function updateFeeWallet(address newWallet) external onlyOwner {\n        feeWallet = newWallet;\n    }\n    \n    function setSnipers(address[] memory snipers_) external onlyOwner() {\n        for (uint i = 0; i < snipers_.length; i++) {\n            if (snipers_[i] != uniswapV2Pair && snipers_[i] != address(uniswapV2Router)) {\n                isSniper[snipers_[i]] = true;\n            }\n        }\n    }\n    \n    function delSnipers(address[] memory snipers_) external onlyOwner() {\n        for (uint i = 0; i < snipers_.length; i++) {\n            isSniper[snipers_[i]] = false;\n        }\n    }\n    \n    function setResetRequirement(uint256 requirement) external onlyOwner() {\n        require(requirement >= totalSupply() * 1 / 100000, \"Burn requirement cannot be lower than 0.001% total supply\");\n  \t    require(requirement <= totalSupply() * 5 / 1000, \"Burn requirement cannot be higher than 0.5% total supply.\");\n  \t    resetRequirement = requirement;\n    }\n\n    function setfireSaleRequirement(uint256 requirement) external onlyOwner() {\n        require(requirement >= totalSupply() * 1 / 100000, \"Burn requirement cannot be lower than 0.001% total supply\");\n  \t    require(requirement <= totalSupply() * 5 / 1000, \"Burn requirement cannot be higher than 0.5% total supply.\");\n  \t    fireSaleRequirement = requirement;\n    }\n\n    function _resetFees() private {\n        _buyMarketingFee = 6;\n        _buyLiquidityFee = 2;\n        _buyDevFee = 2;\n        buyTotalFees = _buyMarketingFee + _buyLiquidityFee + _buyDevFee;\n        \n        _sellMarketingFee = 6;\n        _sellLiquidityFee = 2;\n        _sellDevFee = 2;\n        sellTotalFees = _sellMarketingFee + _sellLiquidityFee + _sellDevFee;\n    }\n\n    function resetFees() external {\n        require(balanceOf(msg.sender) > resetRequirement, \"You do not have enough tokens to reset fees!\");\n\n        _resetFees();\n\n        fireSaleAmt += resetRequirement;\n\n        transfer(burnAddress, resetRequirement);\n        emit FeesReset();\n    }\n\n    function fireSale() public {\n        require(balanceOf(msg.sender) > fireSaleRequirement, \"You do not have enough tokens to start a fire sale!\");\n        fireSaleActive = block.timestamp + 2 hours;\n        fireSaleTimer = block.timestamp + 1 days;\n        fireSaleAmt = 0;\n\n        transfer(burnAddress, fireSaleRequirement);\n        emit FireSaleBy(msg.sender);\n    }\n\n    function _startFireSale() private {\n        fireSaleActive = block.timestamp + 2 hours;\n        fireSaleTimer = block.timestamp + 1 days;\n        fireSaleAmt = 0;\n        \n        emit FireSale();\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(!isSniper[from], \"Your address has been marked as a sniper, you are unable to transfer or swap.\");\n        \n        if (amount == 0) {\n            super._transfer(from, to, 0);\n            return;\n        }\n        \n        if (block.timestamp <= _launchTime) {\n            isSniper[to] = true;\n        }\n        \n        if (limitsInEffect) {\n            if (\n                from != owner() &&\n                to != owner() &&\n                to != address(0) &&\n                to != address(burnAddress) &&\n                !_swapping\n            ) {\n                if (!tradingActive) require(isExcludedFromFees[from] || isExcludedFromFees[to], \"Trading is not active.\");\n                 \n                // when buy\n                if (automatedMarketMakerPairs[from] && !isExcludedMaxTransactionAmount[to]) {\n                    require(amount <= maxTransactionAmount, \"Buy transfer amount exceeds the maxTransactionAmount.\");\n                    require(amount + balanceOf(to) <= maxWallet, \"Max wallet exceeded\");\n                }\n                \n                // when sell\n                else if (automatedMarketMakerPairs[to] && !isExcludedMaxTransactionAmount[from]) {\n                    require(amount <= maxTransactionAmount, \"Sell transfer amount exceeds the maxTransactionAmount.\");\n                }\n            }\n        }\n        \n\t\tuint256 contractTokenBalance = balanceOf(address(this));\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n        if (\n            canSwap &&\n            !_swapping &&\n            !automatedMarketMakerPairs[from] &&\n            !isExcludedFromFees[from] &&\n            !isExcludedFromFees[to]\n        ) {\n            _swapping = true;\n            swapBack();\n            _swapping = false;\n        }\n\n        \n        // dynamic change\n        if (dynamicFeesInEffect && block.timestamp > fireSaleActive) {\n            // on sell\n            if (automatedMarketMakerPairs[to]) {\n                sellFeeThreshold += amount;\n                \n                uint256 feeAdd = sellFeeThreshold.div(sellFeeRate);\n                if (feeAdd > 0) {\n                    if (_sellLiquidityFee < 12) {\n                        if (feeAdd > 10) {\n                            _sellLiquidityFee += 10;\n                        } else {\n                            _sellLiquidityFee += feeAdd;\n                        }\n                    }\n\n                    sellFeeThreshold -= feeAdd.mul(sellFeeRate);\n                }\n            } \n            // on buy\n            else if (automatedMarketMakerPairs[from]) {\n                buyFeeThreshold += amount;\n                \n                uint256 feeAdd = buyFeeThreshold.div(buyFeeRate);\n                if (feeAdd > 0) {\n                    if (_buyLiquidityFee > 0) {\n                        if (feeAdd > 2) {\n                            _buyLiquidityFee -= 2;\n                        } else {\n                            _buyLiquidityFee -= feeAdd;\n                        }\n                    }\n\n                    buyFeeThreshold -= feeAdd.mul(buyFeeRate);\n                }\n            }\n        }\n\n        // set new totals\n        buyTotalFees = _buyMarketingFee + _buyLiquidityFee + _buyDevFee;\n        sellTotalFees = _sellMarketingFee + _sellLiquidityFee + _sellDevFee;\n\n        bool takeFee = !_swapping;\n\n        // if any account belongs to _isExcludedFromFee account then remove the fee\n        if (isExcludedFromFees[from] || isExcludedFromFees[to]) takeFee = false;\n        \n        uint256 fees = 0;\n        // only take fees on buys/sells, do not take on wallet transfers\n        if (takeFee) {\n            // on sell\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0) {\n                fees = amount.mul(sellTotalFees).div(100);\n                _tokensForLiquidity += fees * _sellLiquidityFee / sellTotalFees;\n                _tokensForDev += fees * _sellDevFee / sellTotalFees;\n                _tokensForMarketing += fees * _sellMarketingFee / sellTotalFees;\n            }\n            // on buy\n            else if (automatedMarketMakerPairs[from] && buyTotalFees > 0) {\n        \t    fees = amount.mul(buyTotalFees).div(100);\n        \t    _tokensForLiquidity += fees * _buyLiquidityFee / buyTotalFees;\n                _tokensForDev += fees * _buyDevFee / buyTotalFees;\n                _tokensForMarketing += fees * _buyMarketingFee / buyTotalFees;\n            }\n            \n            if (fees > 0) super._transfer(from, address(this), fees);\n        \t\n        \tamount -= fees;\n        }\n\n        if (block.timestamp > fireSaleActive && fireSaleActive > 0) {\n            fireSaleActive = 0;\n            _resetFees();\n        }\n\n        // reset firesale if time passed\n        if (block.timestamp > fireSaleTimer) {\n            fireSaleTimer = block.timestamp + 1 days;\n            fireSaleAmt = 0;\n        }\n\n        // if it's a burn\n        if (to == burnAddress) {\n            userBurned[msg.sender] += amount;\n            fireSaleAmt += amount;\n\n            if (fireSaleAmt >= fireSaleRequirement) _startFireSale();\n            \n            emit Burn(amount);\n        }\n\n        super._transfer(from, to, amount);\n    }\n\n    function _swapTokensForEth(uint256 tokenAmount) private {\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n    \n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        // approve token transfer to cover all possible scenarios\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // add the liquidity\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n    }\n\n    function swapBack() private {\n        uint256 contractBalance = balanceOf(address(this));\n        uint256 totalTokensToSwap = _tokensForLiquidity + _tokensForMarketing + _tokensForDev;\n        \n        if (contractBalance == 0 || totalTokensToSwap == 0) return;\n        if (contractBalance > swapTokensAtAmount * 20) contractBalance = swapTokensAtAmount * 20;\n        \n        \n        // Halve the amount of liquidity tokens\n        uint256 liquidityTokens = contractBalance * _tokensForLiquidity / totalTokensToSwap / 2;\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\n        \n        uint256 initialETHBalance = address(this).balance;\n\n        _swapTokensForEth(amountToSwapForETH); \n        \n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\n        uint256 ethForMarketing = ethBalance.mul(_tokensForMarketing).div(totalTokensToSwap);\n        uint256 ethForDev = ethBalance.mul(_tokensForDev).div(totalTokensToSwap);\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\n        \n        _tokensForLiquidity = 0;\n        _tokensForMarketing = 0;\n        _tokensForDev = 0;\n                \n        if (liquidityTokens > 0 && ethForLiquidity > 0) {\n            _addLiquidity(liquidityTokens, ethForLiquidity);\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, _tokensForLiquidity);\n        }\n    }\n\n    function withdrawFees() external {\n        payable(feeWallet).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract AbstractToken is Token, SafeMath {\n    // Create new Abstract Token contract.\n    constructor() public {\n        // Do nothing\n    }\n\n    // Get number of tokens currently belonging to given owner.\n    // Parameter _owner: address to get number of tokens currently belonging to the owner of\n    // Parameter return: number of tokens currently belonging to the owner of given address\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return accounts[_owner];\n    }\n\n    // Transfer given number of tokens from message sender to given recipient.\n    // Paramter _to: address to transfer tokens to the owner of\n    // Parameter _value: number of tokens to transfer to the owner of given address\n    // return true if tokens were transferred successfully, false otherwise\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_to != address(0));\n        if (accounts[msg.sender] < _value) return false;\n        if (_value > 0 && msg.sender != _to) {\n            accounts[msg.sender] = safeSub(accounts[msg.sender], _value);\n            accounts[_to] = safeAdd(accounts[_to], _value);\n        }\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    // Transfer given number of tokens from given owner to given recipient.\n    // Parameter _from: address to transfer tokens from the owner of\n    // Paramter _to: address to transfer tokens to the owner of\n    // Parameter _value: number of tokens to transfer from given owner to given recipient\n    // return true if tokens were transferred successfully, false otherwise\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_to != address(0));\n        if (allowances[_from][msg.sender] < _value) return false;\n        if (accounts[_from] < _value) return false;\n\n        if (_value > 0 && _from != _to) {\n            allowances[_from][msg.sender] = safeSub(\n                allowances[_from][msg.sender],\n                _value\n            );\n            accounts[_from] = safeSub(accounts[_from], _value);\n            accounts[_to] = safeAdd(accounts[_to], _value);\n        }\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    // Allow given spender to transfer given number of tokens from message sender.\n    // Parameter _spender: address to allow the owner of to transfer tokens from message sender\n    // Parameter _value: number of tokens to allow to transfer\n    // return true if token transfer was successfully approved, false otherwise\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    // Tell how many tokens given spender is currently allowed to transfer from given owner.\n    // Parameter _owner: address to get number of tokens allowed to be transferred from the owner of\n    // Parameter _spender: address to get number of tokens allowed to be transferred by the owner of\n    // return number of tokens given spender is currently allowed to transfer from given owner\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowances[_owner][_spender];\n    }\n\n    // Mapping from addresses of token holders to the numbers of tokens belonging to these token holders.\n    mapping(address => uint256) accounts;\n\n    // Mapping from addresses of token holders to the mapping of addresses of\n    // spenders to the allowances set by these token holders to these spenders.\n    mapping(address => mapping(address => uint256)) private allowances;\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract RealmToken is ERC20Interface, Owned {\n    using SafeMath for uint;\n \n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n    bool public mintable;\n \n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n \n    event MintingDisabled();\n \n \n    // Constructor\n    function RealmToken() public {\n        symbol = \"RLMA\";\n        name = \"Realm2\";\n        decimals = 18;\n        mintable = true;\n    }\n \n \n    // Total supply\n    function totalSupply() public constant returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n \n \n    // Disable minting\n    function disableMinting() public onlyOwner {\n        require(mintable);\n        mintable = false;\n        MintingDisabled();\n    }\n \n \n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n        return balances[tokenOwner];\n    }\n \n \n    // Transfer the balance from token owner's account to `to` account\n    // Owner's account must have sufficient balance to transfer\n    // 0 value transfers are allowed\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        Transfer(msg.sender, to, tokens);\n        return true;\n    }\n \n \n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        Approval(msg.sender, spender, tokens);\n        return true;\n    }\n \n \n    // Transfer `tokens` from the `from` account to the `to` account\n    //\n    // The calling account must already have sufficient tokens approved\n    // for spending from the `from` account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = balances[from].sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        Transfer(from, to, tokens);\n        return true;\n    }\n \n \n    // Returns the amount of tokens approved by the owner that can be transferred to the spender's account\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n \n \n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account. The `spender` contract function\n    // `receiveApproval(...)` is then executed\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n        return true;\n    }\n \n \n    // Mint tokens\n    function mint(address tokenOwner, uint tokens) public onlyOwner returns (bool success) {\n        require(mintable);\n        balances[tokenOwner] = balances[tokenOwner].add(tokens);\n        _totalSupply = _totalSupply.add(tokens);\n        Transfer(address(0), tokenOwner, tokens);\n        return true;\n    }\n \n \n    // Don't accept ethers\n    function () public payable {\n        revert();\n    }\n \n \n    // Owner can transfer out any accidentally sent ERC20 tokens\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract MiceForce is ERC721Enumerable {\n    // Mappings\n    mapping(uint256 => bytes16) internal tokenIdToHash;\n\n    uint public constant MAX_SUPPLY = 7500;\n\n    // team + giveaway reserve, not possible to mint directly\n    uint public constant RESERVED_SUPPLY = 150;\n    uint public constant BRAINS_MINT_COST = 12 ether;\n    uint public pumpkinMinted;\n    uint public brainsMinted;\n    uint SEED_NONCE = 0;\n\n    uint public scientistTotal;\n    uint public militaryTotal;\n\n    uint16[][8] TIERS;\n\n    bytes32 entropySauce;\n\n    bool public MINT_ENABLED;\n\n    address constant burnAddress=0x000000000000000000000000000000000D15ea5E;\n    address public _owner;\n    address metaVaultAddress;\n    address pumpkinJackAddress;\n    address brainzAddress;\n\n    constructor() ERC721(\"MiceForce\", \"MFORCE\") {\n        _owner = msg.sender;\n        // eyes\n        TIERS[0]=[0,375,750,1875,2250,2250];\n        // hair\n        TIERS[1]=[0,375,750,1875,2250,2250];\n        // suit\n        TIERS[2]=[0,1125,2625,3750];\n        // nose\n        TIERS[3]=[0,3000,3000,1500];\n        // mouth\n        TIERS[4]=[0,375,750,1125,1500,1875,1875];\n        // whiskers\n        TIERS[5]=[0,3750,3750];\n        // body\n        TIERS[6]=[4,1873,1873,1875,1875];\n    }\n\n    // Generate 16 bytes hash with all trait rolls. Does not guarantee the uniquness of every MiceForce unit.\n    // Parameter _milisci: MiceForce unit type\n    function hash(uint8 _milisci, uint256 _t, address _a) internal returns (bytes16) {\n        // hash kept as 16 bytes\n        // 1 byte: 0 - military, 1 - scientist\n        // 2 byte: 0 - alive, 2 - dead\n        // 3-16 bytes: 7 pairs of bytes for trait rolls   \n        \n        // 0 byte is always 0x00 as MiceForce unit is alive\n        bytes16 currentHash=bytes16(0);\n        // set 1 byte to MiceForce unit type\n        currentHash=setHashByte(currentHash, 1, bytes1(_milisci));\n        // generate random uint256\n        uint randomUint256 = uint256(\n                    keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        _t,\n                        _a,\n                        ++SEED_NONCE,\n                        entropySauce\n                    )));\n\n        uint16 _randinput;\n        // iterating through traits\n        for (uint8 i = 0; i < 7; i++) {\n            // take 4 digits from random uint256 as roll for trait\n            _randinput = uint16((randomUint256 / 10000**i % 10000) % MAX_SUPPLY);\n            // write roll to coresponding trait position within the hash \n            currentHash = setTraitRollToHash(currentHash,i,_randinput);\n        }\n\n        return currentHash;\n    }\n\n    // Mint tokens for free, usable by giveaway contract only\n    // Parameter _winner: Address to mint tokens\n    // Parameter _amount: Amount of tokens to mint\n    // Parameter _class: Class to mint (0 - mili, 1 - sci, 3 - random)\n    function getPrize(address _winner, uint8 _amount, uint8 _class) external onlyPumpkinJack {\n        uint256 _startMintId = totalSupply();\n        require(\n            (_startMintId + _amount) <= MAX_SUPPLY,\n            \"The amount exceed max supply\"\n        );\n\n        bool randomize = _class==3;\n        pumpkinMinted += _amount;\n\n        for (uint i = 0; i < _amount; i++) {\n            uint8 rand = randomize?uint8(uint256(keccak256(abi.encodePacked(_winner, _amount, block.timestamp, block.difficulty, SEED_NONCE++)))%2):_class;\n            uint256 _mintId = _startMintId + i;\n\n            tokenIdToHash[_mintId] = hash(rand, _mintId, _winner);\n            rand==0?militaryTotal++:scientistTotal++;\n            _mint(_winner, _mintId);\n        }\n        \n    }\n\n    // Mint several tokens in exchange to BRAIN$\n    // Parameter _milisci: MiceForce unit type (0 - mili, 1 - sci)\n    // Parameter _amount: Amount to mint\n    function mintFew(uint8 _milisci, uint _amount) external noCheaters mintAllowed {\n        require(_milisci < 2, \"Wrong class chosen\");\n\n        require(_amount <= 10, \"Max amount per tx exceed\");\n        uint256 _startMintId = totalSupply();\n\n        require((_startMintId + _amount) <= MAX_SUPPLY, \"The amount exceed max supply\");\n        require(_startMintId + _amount <= MAX_SUPPLY - RESERVED_SUPPLY, \"No unreserved mice force available\");\n        \n        IBrainz(brainzAddress).burnFrom(msg.sender, BRAINS_MINT_COST*_amount);\n        brainsMinted+=_amount;\n\n        for (uint i = 0; i < _amount; i++) {\n            uint256 _mintId = _startMintId + i;\n            _milisci==0?militaryTotal++:scientistTotal++;\n            tokenIdToHash[_mintId] = hash(_milisci,_mintId, msg.sender);\n            _mint(msg.sender, _mintId);\n        }\n    }\n\n    // Mint one token in exchange to BRAIN$\n    // Parameter _milisci: MiceForce unit type (0 - mili, 1 - sci)\n    function mintOne(uint8 _milisci) external noCheaters mintAllowed {\n        require(_milisci < 2, \"Wrong class chosen\");\n\n        uint _mintId = totalSupply();\n\n        require(_mintId < MAX_SUPPLY, \"No more mice force available\");\n        require(brainsMinted < MAX_SUPPLY - RESERVED_SUPPLY, \"No unreserved mice force available\");\n\n        IBrainz(brainzAddress).burnFrom(msg.sender, BRAINS_MINT_COST);\n        brainsMinted++;\n\n        _milisci==0?militaryTotal++:scientistTotal++;\n        bytes16 _h=hash(_milisci, _mintId, msg.sender);\n        tokenIdToHash[_mintId] = _h;\n\n        _mint(msg.sender, _mintId);\n    }\n\n    // Burn the token\n    // Parameter _tokenId: Token ID\n    function burn(uint _tokenId) external {\n        _transfer(\n            msg.sender,\n            burnAddress,\n            _tokenId\n        );\n    }\n\n    // Return all metadata for token ID\n    // Parameter _tokenId: Token ID\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n        require(_exists(_tokenId));\n\n        bytes9 packedHash = getPackedHashByTokenId(_tokenId);\n        return IMFMetaVault(metaVaultAddress).getMetadataByHash(_tokenId, packedHash);\n    }\n\n    // Return the wallet of a given address. Mainly for ease for frontend devs\n    // Parameter _wallet The wallet to get the tokens of\n    function walletOfOwner(address _wallet) external view returns (uint256[] memory) {\n        uint256 tokenCount = balanceOf(_wallet);\n\n        uint256[] memory tokensId = new uint256[](tokenCount);\n        for (uint256 i; i < tokenCount; i++) {\n            tokensId[i] = tokenOfOwnerByIndex(_wallet, i);\n        }\n        return tokensId;\n    }\n\n    // Get bytes9 hash by tokenID\n    // Parameter _tokenId: Token ID\n    function getPackedHashByTokenId(uint _tokenId) public view returns(bytes9) {\n        require(_exists(_tokenId));\n\n        bytes16 _hash=tokenIdToHash[_tokenId];\n        bytes1 burned=0x00;\n        if (ownerOf(_tokenId) == burnAddress) {\n            burned=0x01;\n        }\n\n        bytes9 phash=burned;\n        phash=setPackedHashByte(phash,1,_hash[1]);\n\n        if (getTraitRollFromHash(_hash, 6)<TIERS[6][0]) {\n            return phash;\n        }\n\n        for (uint8 i = 0; i < 7; i++) {\n            uint16 edge;\n            uint16 trait_roll=getTraitRollFromHash(_hash, i);\n            for (uint8 j = 0; j < TIERS[i].length; j++) {\n                if (trait_roll < (edge+=TIERS[i][j])) \n                {\n                    phash=setPackedHashByte(phash,i+2,bytes1(j));\n                    break;\n                }\n            }  \n        }\n        return(phash);\n    }\n\n    // Set addresses\n    // Parameter _brainzAddress: BRAIN$ contract address\n    // Parameter _metavaultAddress: MetaBault contract address\n    // Parameter _pumpkinJackAddress: PumpkinJack contract address\n    function setAddress(address _brainzAddress, address _metavaultAddress, address _pumpkinJackAddress) external onlyOwner {\n        brainzAddress=_brainzAddress;\n        metaVaultAddress=_metavaultAddress;\n        pumpkinJackAddress = _pumpkinJackAddress;\n    }\n\n    // Switch the mint phase state from true -> false and vice versa\n    function mintSwitch() external onlyOwner {\n        MINT_ENABLED=!MINT_ENABLED;\n    }\n\n    // Transfers ownership\n    // Parameter _newOwner: The new owner\n    function transferOwnership(address _newOwner) public onlyOwner {\n        _owner = _newOwner;\n    }\n\n    function getTraitRoll(uint _tokenId, uint8 _traitId) internal view returns(uint16) {\n        return getTraitRollFromHash(tokenIdToHash[_tokenId], _traitId);\n    }\n\n    //Modifiers\n\n    // Modifier to only allow owner to call function\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    // Modifier to only allow PJ contract to call function\n    modifier onlyPumpkinJack() {\n        require(pumpkinJackAddress == msg.sender);\n        _;\n    }\n\n    // Modifier to only allow function to be used if MINT_ENABLED\n    modifier mintAllowed() {\n        require(MINT_ENABLED);\n        _;\n    }\n\n    // Modifier to not allow contracts call the function\n    modifier noCheaters() {\n        uint256 size = 0;\n        address acc = msg.sender;\n        assembly { size := extcodesize(acc)}\n\n        require(msg.sender == tx.origin , \"No contracts allowed\");\n        require(size == 0,                \"No contracts allowed\");\n        _;\n\n        // We'll use the last caller hash to add entropy to next caller\n        entropySauce = keccak256(abi.encodePacked(acc, block.coinbase));\n    }\n\n    // Utility functions\n\n    // Get string representation of uint\n    function _toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    // Write trait roll number to bytes16 hash\n    function setTraitRollToHash(bytes16 _hash, uint8 _traitId, uint16 roll) internal pure returns (bytes16) {\n        return (_hash & ~(bytes16(0xffff0000000000000000000000000000) >> (16+_traitId * 16))) | (bytes16(bytes2(roll)) >> (16+_traitId * 16));\n    }\n\n    // Get trait roll number from bytes16 hash\n    function getTraitRollFromHash(bytes16 _hash, uint8 _traitId) internal pure returns (uint16) {\n        uint16 number;\n        uint8 start_pos=2+_traitId*2;\n        number = uint16(uint8(_hash[start_pos])*(2**(8)) + uint8(_hash[start_pos+1]));\n        return number;\n    }\n\n    // Write byte to bytes9 hash\n    function setPackedHashByte(bytes9 _hash, uint _index, bytes1 _byte) internal pure returns (bytes9) {\n        return (_hash & ~(bytes9(0xff0000000000000000) >> (_index * 8))) | (bytes9(_byte) >> (_index * 8));\n    }\n\n    // Write byte to bytes16 hash\n    function setHashByte(bytes16 _hash, uint _index, bytes1 _byte) internal pure returns (bytes16) {\n        return (_hash & ~(bytes16(0xff000000000000000000000000000000) >> (_index * 8))) | (bytes16(_byte) >> (_index * 8));\n    }\n}"}]
