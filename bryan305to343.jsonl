[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract Bitfex_Token is ERC20, MinterRole {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    // Sets the values for `name`, `symbol`, and `decimals`. All three of these values are immutable: they can only be set once during construction.\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    // Returns the name of the token.\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    // Returns the symbol of the token, usually a shorter version of the name.\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    // Returns the number of decimals used to get its user representation.\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n   \n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract VectorField is ERC721URIStorage, VRFConsumerBase, Ownable {\n    uint256 public tokenCounter;\n    uint256 public constant MAX_SUPPLY = 300;\n    uint256 public constant PRICE = .25 ether;\n    \n    mapping(bytes32 => address) public requestIdToSender;\n    mapping(uint256 => uint256) public tokenIdToRandomNumber;\n    mapping(bytes32 => uint256) public requestIdToTokenId;\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public height;\n    uint256 public price;\n    uint256 public width;\n    string[] public colors;\n\n    constructor(address _VRFCoordinator, address _LinkToken, bytes32 _keyhash, uint256 _fee) \n    VRFConsumerBase(_VRFCoordinator, _LinkToken)\n    ERC721(\"Vector Field\", \"VCFD\")\n    {\n        tokenCounter = 1;\n        keyHash = _keyhash;\n        fee = _fee;\n        price = PRICE;\n        height = 2000;\n        width = 1500;\n        colors = [\n\"#FAFAFA\",\n\"#F5F5F5\",\n\"#EEEEEE\",\n\"#E0E0E0\",\n\"#BDBDBD\",\n\"#9E9E9E\",\n\"#757575\",\n\"#616161\",\n\"#424242\",\n\"#212121\",\n\"#ECEFF1\",\n\"#CFD8DC\",\n\"#B0BEC5\",\n\"#90A4AE\",\n\"#78909C\",\n\"#607D8B\",\n\"#546E7A\",\n\"#455A64\",\n\"#37474F\",\n\"#263238\",\n\"#b71c1c\",\n\"#DB3A3D\",\n\"#E1C1A7\",\n\"#D88C73\",\n\"#D0C1AB\"\n];\n    }\n    \n       \n function withdraw() public payable onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n   \n    function Claim() public payable returns (bytes32 requestId) {\n        require(msg.value >= price, \"Please send more ETH\");\n        require(tokenCounter <= MAX_SUPPLY, \"All Fields have been minted\");\n        requestId = requestRandomness(keyHash, fee);\n        requestIdToSender[requestId] = msg.sender;\n        uint256 tokenId = tokenCounter; \n        requestIdToTokenId[requestId] = tokenId;\n        tokenCounter = tokenCounter + 1;\n        \n    }\n\n    function Mint(uint256 tokenId) public {\n        require(bytes(tokenURI(tokenId)).length <= 0, \"tokenURI is already set!\"); \n        require(tokenCounter > tokenId, \"TokenId has not been minted yet!\");\n        require(tokenIdToRandomNumber[tokenId] > 0, \"Need to wait for the Chainlink node to respond!\");\n        uint256 randomNumber = tokenIdToRandomNumber[tokenId];\n        string memory svg = generateSVG(randomNumber);\n        string memory TokenID = uint2str(tokenId);\n        string memory imageURI = svgToImageURI(svg);\n        _setTokenURI(tokenId, formatTokenURI(imageURI, TokenID));\n        \n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomNumber) internal override {\n        address nftOwner = requestIdToSender[requestId];\n        uint256 tokenId = requestIdToTokenId[requestId];\n        _safeMint(nftOwner, tokenId);\n        tokenIdToRandomNumber[tokenId] = randomNumber;\n        \n    }\n\n    function generateSVG(uint256 _randomness) public view returns (string memory finalSvg) {\n       uint256 bgopacity = uint256(keccak256(abi.encode(_randomness + 1))) % 6;\n        finalSvg = string(abi.encodePacked(\"<svg xmlns='http://www.w3.org/2000/svg' height='\", uint2str(height), \"' width='\", uint2str(width), \"' fill='none' viewBox='500 100 1500 2000'><path d='M500 100h1500v2000H0z' fill= '#f4ebe2'/><path d='M500 100h1500v2000H0z'\"));\n        string memory color = colors[_randomness % colors.length];\n        \n        finalSvg = string(abi.encodePacked(finalSvg, \" fill='\", color, \"' opacity='.\", uint2str(bgopacity), \"'/>\"));\n        \n        for(uint i = 0; i < 3; i++) {\n           \n            string memory pathSvg = generatePath(uint256(keccak256(abi.encode(_randomness, i))));\n            finalSvg = string(abi.encodePacked(finalSvg, pathSvg));\n        }\n        finalSvg = string(abi.encodePacked(finalSvg, \"</svg>\"));\n    }\n\n    function generatePath(uint256 _randomness) public view returns(string memory pathSvg) {\n        uint256 x = uint256(keccak256(abi.encode(_randomness, height * 2 + 1))) % width;\n        uint256 y = uint256(keccak256(abi.encode(_randomness, width + 1))) % height;\n        uint256 w = uint256(keccak256(abi.encode(_randomness, width + 3))) % width;\n        uint256 h = uint256(keccak256(abi.encode(_randomness, height * 3 + 1))) % height;\n        uint256 opacity = uint256(keccak256(abi.encode(_randomness + 2))) % 9;\n\n        pathSvg = string(abi.encodePacked( \"<rect x='\", uint2str(x), \"' y= '\", uint2str(y),\"' width= '\", uint2str(w), \"' height='\", uint2str(h), \"' opacity='.\", uint2str(opacity), \"'\"));\n\n        string memory color = colors[_randomness % colors.length];\n        pathSvg = string(abi.encodePacked(pathSvg, \" fill='\", color,\"'/>\"));\n    }\n\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function svgToImageURI(string memory svg) public pure returns (string memory) {\n        string memory baseURL = \"data:image/svg+xml;base64,\";\n        string memory svgBase64Encoded = Base64.encode(bytes(string(abi.encodePacked(svg))));\n        return string(abi.encodePacked(baseURL,svgBase64Encoded));\n    }\n\n    function formatTokenURI(string memory imageURI, string memory TokenID) public pure returns (string memory) {\n        return string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"Field #',TokenID,'\", \"description\":\"300 Vector Fields randomly generated and stored on the Ethereum blockchain\", \"attributes\":\"\", \"image\":\"',imageURI,'\"}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    }\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    // Function to check the amount of tokens that an owner allowed to a spender. Param owner address The address which owns the funds. Param spender address The address which will spend the funds. return A uint256 specifying the amount of tokens still available for the spender.\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    // Transfer token to a specified address. Param to The address to transfer to. Param value The amount to be transferred.\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: Param spender The address which will spend the funds. Param value The amount of tokens to be spent.\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    // Transfer tokens from one address to another. Note that while this function emits an Approval event, this is not required as per the specification, and other compliant implementations may not emit the event. Param from address The address which you want to send tokens from param to address The address which you want to transfer to param value uint256 the amount of tokens to be transferred\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n    // Increase the amount of tokens that an owner allowed to a spender. Approve should be called when _allowed[msg.sender][spender] == 0. \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    // Decrease the amount of tokens that an owner allowed to a spender.\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    // Transfer token for a specified addresses.\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    // Internal function that mints an amount of the token and assigns it to an account\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    // Internal function that burns an amount of the token of a given account.\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    // Approve an address to spend another addresses' tokens.\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n\n        _allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    // Internal function that burns an amount of the token of a given account, deducting from the sender's allowance for said account. \n    function _burnFrom(address account, uint256 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract Strategy_YFI_DForceUSDT {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    \n    address constant public want = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    address constant public d = address(0x868277d475E0e475E38EC5CdA2d9C83B5E1D9fc8);\n    address constant public pool = address(0x324EebDAa45829c6A8eE903aFBc7B61AF48538df);\n    address constant public df = address(0x431ad2ff6a9C365805eBaD47Ee021148d6f7DBe0);\n    address constant public uni = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address constant public weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    \n    uint public performanceFee = 5000;\n    uint constant public performanceMax = 10000;\n    \n    uint public withdrawalFee = 50;\n    uint constant public withdrawalMax = 10000;\n    \n    address public governance;\n    address public controller;\n    address public strategist;\n    \n    constructor(address _controller) public {\n        governance = msg.sender;\n        strategist = msg.sender;\n        controller = _controller;\n    }\n    \n    function getName() external pure returns (string memory) {\n        return \"StrategyDForceUSDT\";\n    }\n    \n    function setStrategist(address _strategist) external {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n    \n    function setWithdrawalFee(uint _withdrawalFee) external {\n        require(msg.sender == governance, \"!governance\");\n        withdrawalFee = _withdrawalFee;\n    }\n    \n    function setPerformanceFee(uint _performanceFee) external {\n        require(msg.sender == governance, \"!governance\");\n        performanceFee = _performanceFee;\n    }\n    \n    function deposit() public {\n        uint _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            IERC20(want).safeApprove(d, 0);\n            IERC20(want).safeApprove(d, _want);\n            IDERC20(d).mint(address(this), _want);\n        }\n        \n        uint _d = IERC20(d).balanceOf(address(this));\n        if (_d > 0) {\n            IERC20(d).safeApprove(pool, 0);\n            IERC20(d).safeApprove(pool, _d);\n            IDRewards(pool).stake(_d);\n        }\n        \n    }\n    \n    // Controller only function for creating additional rewards from dust\n    function withdraw(IERC20 _asset) external returns (uint balance) {\n        require(msg.sender == controller, \"!controller\");\n        require(want != address(_asset), \"want\");\n        require(d != address(_asset), \"d\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(controller, balance);\n    }\n    \n    // Withdraw partial funds, normally used with a vault withdrawal\n    function withdraw(uint _amount) external {\n        require(msg.sender == controller, \"!controller\");\n        uint _balance = IERC20(want).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n        \n        uint _fee = _amount.mul(withdrawalFee).div(withdrawalMax);\n        \n        \n        IERC20(want).safeTransfer(Controller(controller).rewards(), _fee);\n        address _vault = Controller(controller).vaults(address(want));\n        require(_vault != address(0), \"!vault\"); // additional protection so we don't burn the funds\n        \n        IERC20(want).safeTransfer(_vault, _amount.sub(_fee));\n    }\n    \n    // Withdraw all funds, normally used when migrating strategies\n    function withdrawAll() external returns (uint balance) {\n        require(msg.sender == controller, \"!controller\");\n        _withdrawAll();\n        \n        \n        balance = IERC20(want).balanceOf(address(this));\n        \n        address _vault = Controller(controller).vaults(address(want));\n        require(_vault != address(0), \"!vault\"); // additional protection so we don't burn the funds\n        IERC20(want).safeTransfer(_vault, balance);\n    }\n    \n    function _withdrawAll() internal {\n        IDRewards(pool).exit();\n        uint _d = IERC20(d).balanceOf(address(this));\n        if (_d > 0) {\n            IDERC20(d).redeem(address(this),_d);\n        }\n    }\n    \n    function harvest() public {\n        require(msg.sender == strategist || msg.sender == governance, \"!authorized\");\n        IDRewards(pool).getReward();\n        uint _df = IERC20(df).balanceOf(address(this));\n        if (_df > 0) {\n            IERC20(df).safeApprove(uni, 0);\n            IERC20(df).safeApprove(uni, _df);\n            \n            address[] memory path = new address[](3);\n            path[0] = df;\n            path[1] = weth;\n            path[2] = want;\n            \n            IUniV2(uni).swapExactTokensForTokens(_df, uint(0), path, address(this), now.add(1800));\n        }\n        uint _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            uint _fee = _want.mul(performanceFee).div(performanceMax);\n            IERC20(want).safeTransfer(Controller(controller).rewards(), _fee);\n            deposit();\n        }\n    }\n    \n    function _withdrawSome(uint256 _amount) internal returns (uint) {\n        uint _d = _amount.mul(1e18).div(IDERC20(d).getExchangeRate());\n        uint _before = IERC20(d).balanceOf(address(this));\n        IDRewards(pool).withdraw(_d);\n        uint _after = IERC20(d).balanceOf(address(this));\n        uint _withdrew = _after.sub(_before);\n        _before = IERC20(want).balanceOf(address(this));\n        IDERC20(d).redeem(address(this), _withdrew);\n        _after = IERC20(want).balanceOf(address(this));\n        _withdrew = _after.sub(_before);\n        return _withdrew;\n    }\n    \n    function balanceOfWant() public view returns (uint) {\n        return IERC20(want).balanceOf(address(this));\n    }\n    \n    function balanceOfPool() public view returns (uint) {\n        return (IDRewards(pool).balanceOf(address(this))).mul(IDERC20(d).getExchangeRate()).div(1e18);\n    }\n    \n    function getExchangeRate() public view returns (uint) {\n        return IDERC20(d).getExchangeRate();\n    }\n    \n    function balanceOfD() public view returns (uint) {\n        return IDERC20(d).getTokenBalance(address(this));\n    }\n    \n    function balanceOf() public view returns (uint) {\n        return balanceOfWant()\n               .add(balanceOfD())\n               .add(balanceOfPool());\n    }\n    \n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n    \n    function setController(address _controller) external {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract Legends_of_Crypto is ERC20Detailed {\n\n  using SafeMath for uint256;\n  mapping (address => uint256) private _balances;\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  string constant tokenName = \"Legends of Crypto\";\n  string constant tokenSymbol = \"LOCG\";\n  uint8  constant tokenDecimals = 18;\n  uint256 _totalSupply = 150000000000000000000000000;\n  uint256 public basePercent = 100;\n\n  constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n    _mint(msg.sender, _totalSupply);\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  function allowance(address owner, address spender) public view returns (uint256) {\n    return _allowed[owner][spender];\n  }\n\n  function findOnePercentb(uint256 value) public view returns (uint256)  {\n    uint256 roundValue = value.ceil(basePercent);\n    uint256 onePercent = roundValue.mul(basePercent).div(10000);\n    return onePercent;\n  }\n\n  function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender]);\n    require(to != address(0));\n\n    uint256 tokensToBurn = 0;\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(tokensToTransfer);\n\n    _totalSupply = _totalSupply.sub(tokensToBurn);\n\n    emit Transfer(msg.sender, to, tokensToTransfer);\n    emit Transfer(msg.sender, address(0), tokensToBurn);\n    return true;\n  }\n\n  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n    for (uint256 i = 0; i < receivers.length; i++) {\n      transfer(receivers[i], amounts[i]);\n    }\n  }\n\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n\n    uint256 tokensToBurn = 0;\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n    _balances[to] = _balances[to].add(tokensToTransfer);\n    _totalSupply = _totalSupply.sub(tokensToBurn);\n\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n    emit Transfer(from, to, tokensToTransfer);\n    emit Transfer(from, address(0), tokensToBurn);\n\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  // 1-time token mint/creation function. Tokens are only minted during contract creation, and cannot be done again.\n  function _mint(address account, uint256 amount) internal {\n    require(amount != 0);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal {\n    require(amount != 0);\n    require(amount <= _balances[account]);\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[account] = _balances[account].sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function burnFrom(address account, uint256 amount) external {\n    require(amount <= _allowed[account][msg.sender]);\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);\n    _burn(account, amount);\n  }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract GrouchyTigerCubs is ERC721, ERC721Enumerable, ERC721Burnable, Ownable {\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n  uint256 public cost = 0.01 ether;\n\n  constructor() ERC721(\"GrouchyTigerCubs\", \"GTSCC\") {}\n\n  function _baseURI() internal pure override returns (string memory) {\n      return \"https://grouchytigersocialclub.com/cubs/metadata/\";\n  }\n\n  function safeMint(address to) public payable {\n      uint256 tokenId = _tokenIdCounter.current();\n\n      require(msg.value >= cost);\n\n      _tokenIdCounter.increment();\n      _safeMint(to, tokenId);\n  }\n\n  function setCost(uint256 _newCost) public onlyOwner {\n      cost = _newCost;\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n      super._beforeTokenTransfer(from, to, tokenId);\n  }\n\n  function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n      return super.supportsInterface(interfaceId);\n  }\n  \n  function withdraw() public payable onlyOwner {\n      (bool success, ) = payable(msg.sender).call{\n          value: address(this).balance\n      }(\"\");\n      require(success);\n  }\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => Account) _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    \n    struct Account {\n        uint256 total;\n        uint256 locked;\n        uint32 release_time;\n    }\n\n    // Total number of tokens in existence.\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    // Gets the balance of the specified address.\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner].total;\n    }\n    \n    function lockedOf(address owner) public view returns(uint256) {\n        return _balances[owner].locked;\n    }\n\n    // Function to check the amount of tokens that an owner allowed to a spender.\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    // Transfer token to a specified address.\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    // Transfer tokens from one address to another.\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\n        return true;\n    }\n\n    // Increase the amount of tokens that an owner allowed to a spender.\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    // Decrease the amount of tokens that an owner allowed to a spender.\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    // Transfer token for a specified addresses.\n    function _transfer(address from, address to, uint256 value) internal {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        uint256 total;\n        if(_balances[from].locked>0) {\n            //release time reached\n            if(_balances[from].release_time<block.timestamp) {\n                _balances[from].locked = 0;\n                total = _balances[from].total;\n            }else {\n                total = _balances[from].total.sub(_balances[from].locked);\n            }\n        }else {\n            total = _balances[from].total;\n        }\n        _balances[from].total = total.sub(value).add(_balances[from].locked);\n        _balances[to].total = _balances[to].total.add(value);\n        emit Transfer(from, to, value);\n    }\n\n    // Internal function that mints an amount of the token and assigns it to an account.\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account].total = _balances[account].total.add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    // Internal function that burns an amount of the token of a given account.\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        uint256 total;\n        if(_balances[account].locked>0) {\n            //release time reached\n            if(_balances[account].release_time<block.timestamp) {\n                _balances[account].locked = 0;\n                total = _balances[account].total;\n            }else {\n                total = _balances[account].total.sub(_balances[account].locked);\n            }\n        }else {\n            total = _balances[account].total;\n        }\n        \n        _totalSupply = _totalSupply.sub(value);\n        _balances[account].total = total.sub(value).add(_balances[account].locked);\n        emit Transfer(account, address(0), value);\n    }\n\n    // Approve an address to spend another addresses' tokens.\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    // Internal function that burns an amount of the token of a given account, deducting from the sender's allowance for said account. \n    function _burnFrom(address account, uint256 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));\n    }\n    \n    function _lockTransfer(address account, uint256 value,uint32 release_time) internal {\n        transfer(account, value);\n        require(_balances[account].total >= _balances[account].locked.add(value));\n        _balances[account].locked = _balances[account].locked.add(value);\n        _balances[account].release_time = release_time;\n    }\n}\n"}]
