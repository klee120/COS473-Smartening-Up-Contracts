[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract DegenerateDachshunds is Ownable, ERC721 {\r\n    using SafeMath for uint256;\r\n    using Counters for Counters.Counter;\r\n\r\n    Counters.Counter private _tokenIds;\r\n\r\n    uint public constant MAX_SUPPLY = 8888;\r\n    uint public constant MAX_PER_MINT = 5;\r\n\r\n    string public baseTokenURI;\r\n\r\n    bool public saleIsActive = false;\r\n    uint public price = 0.06 ether;\r\n\r\n    constructor(string memory baseURI) ERC721(\"Degenerate Dachshunds\", \"DD\") {\r\n        setBaseURI(baseURI);\r\n    }\r\n\r\n    // Reserve a few NFTs\r\n    function reserveNfts(uint _count, address _to) public onlyOwner {\r\n        uint totalMinted = _tokenIds.current();\r\n\r\n        require(totalMinted.add(_count) < MAX_SUPPLY, \"Not enough NFTs left to reserve\");\r\n\r\n        for (uint i = 0; i < _count; i++) {\r\n            _mintSingleNft(_to);\r\n        }\r\n    }\r\n\r\n    // Get total supply minted\r\n    function totalSupply() public view returns (uint) {\r\n        return _tokenIds.current();\r\n    }\r\n\r\n    // Override empty _baseURI function \r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n\r\n    // Allow owner to set baseTokenURI\r\n    function setBaseURI(string memory _baseTokenURI) public onlyOwner {\r\n        baseTokenURI = _baseTokenURI;\r\n    }\r\n\r\n    // Set Sale state\r\n    function setSaleState(bool _activeState) public onlyOwner {\r\n        saleIsActive = _activeState;\r\n    }\r\n\r\n    // Update price\r\n    function updatePrice(uint _newPrice) public onlyOwner {\r\n        price = _newPrice;\r\n    }\r\n\r\n    // Mint NFTs\r\n    function mintNft(uint _count) public payable {\r\n        uint totalMinted = _tokenIds.current();\r\n\r\n        require(totalMinted.add(_count) <= MAX_SUPPLY, \"Not enough NFTs left!\");\r\n        require(_count >0 && _count <= MAX_PER_MINT, \"Cannot mint specified number of NFTs.\");\r\n        require(saleIsActive, \"Sale is not currently active!\");\r\n        require(msg.value >= price.mul(_count), \"Not enough ether to purchase NFTs.\");\r\n\r\n        for (uint i = 0; i < _count; i++) {\r\n            _mintSingleNft(msg.sender);\r\n        }\r\n    }\r\n\r\n    // Mint a single NFT\r\n    function _mintSingleNft(address _to) private {\r\n        _tokenIds.increment();\r\n        uint newTokenID = _tokenIds.current();\r\n        _safeMint(_to, newTokenID);\r\n    }\r\n\r\n    // Withdraw ether\r\n    function withdraw() public onlyOwner {\r\n        uint balance = address(this).balance;\r\n        require(balance > 0, \"No ether left to withdraw\");\r\n\r\n        (bool success, ) = (msg.sender).call{value: balance}(\"\");\r\n        require(success, \"Transfer failed.\");\r\n    }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract PACLEXAction is ERC721Enumerable {\n\n    /* VARIABLES */\n    uint256 public currentId;\n    address payable public beneficiary;\n    address public owner;\n\n    address public pacdao = 0xf27AC88ac7e80487f21e5c2C847290b2AE5d7B8e;\n    address public lexarmy = 0xBe9aAF4113B5a4aFCdb7E20c21eAa53C6EE20b10;\n    address public artist = 0x82fDAF8ceD639567dEd54447400b037C4D0719d5;\n\n    mapping(uint256 => string) private _tokenURIs;\n    mapping(bytes32 => uint256) private leafMints;\n\n    uint256 maxMintsPerLeaf = 1;\n\n    string public baseURI = \"ipfs://\";\n    string public defaultMetadata = \"QmTYvCgKunY8W18kSpCK5eUpHSEzGCmzqQp185AU451ALV\";\n    string private _contractURI = \"Qma4VAp8giZ74Ny7jJVW1e5V8kmC5VVaSeF6cbXWFizxsr\";\n\n    bool isPublicMint = true;\n\n    bytes32 private merkleRoot;\n\n    /* CONSTRUCTOR */\n    constructor () ERC721 (\"PAC/LEX Action\", \"PACLEX-A1\"){\n       owner = msg.sender;\n       beneficiary = payable(0xf27AC88ac7e80487f21e5c2C847290b2AE5d7B8e);\n       merkleRoot = 0xbec6093988d4c88c0ee9b16c888f45b54e42106c79b3244b0a5551c0d4191f26; \n    }\n\n\n    /* PUBLIC VIEWS */\n\n    // Return token URI if set or Default URI\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n\t    require(_exists(tokenId)); // dev: \"ERC721URIStorage: URI query for nonexistent token\";\n\n\t    string memory _tokenURI = _tokenURIs[tokenId];\n\t    string memory base = baseURI;\n\n\t    // If there is no base URI, return the token URI.\n\t    if (bytes(base).length == 0 && bytes(_tokenURI).length > 0) {\n\t        return _tokenURI;\n\t    }\n\n\t    // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n\t    if (bytes(_tokenURI).length > 0) {\n\t        return string(abi.encodePacked(base, _tokenURI));\n\t    }\n\n\t    // No Token URI, return default\n\t    return string(abi.encodePacked(base, defaultMetadata)); \n    }\n\n    // Return contract URI\n    function contractURI() public view returns(string memory) {\n\t    return string(abi.encodePacked(baseURI, _contractURI));\n    }\n    \n\n    /*f = PUBLIC WRITEABLE */\n\n    // Mint NFT if eligible.\n    function mint(bytes32 leaf, bytes32[] memory proof) public\n\t{\n\t\trequire(isPublicMint); // dev: Minting period over\n\t\trequire(verifyMerkle(leaf, proof)); // dev: Invalid Merkle Tree\n\t\trequire(leafMints[leaf] < maxMintsPerLeaf); // dev: Leaf already used\n\t\tleafMints[leaf] += 1;\n\t\t_mint(msg.sender);\n\t\tif(currentId < 3) {\n\t\t\t_mint(artist);\n\t\t}\n\t\tif(currentId < 36) {\n\t\t\t_mint(pacdao);\n\t\t\t_mint(lexarmy);\n\t\t}\n\t}\n\n\n    // Recover funds inadvertently sent to the contract\n    function withdraw() public \n    {\n\t    beneficiary.transfer(address(this).balance);\n    }\n\n\n    /* ADMIN FUNCTIONS */\n    // Admin function to mint an NFT for an address\n    function mintFor(address _mintAddress) public payable\n    {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    require(_mintAddress != address(0));\n\t    _mint(_mintAddress);\n    }\n\n    function updateRoot(bytes32 newRoot) public {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    merkleRoot = newRoot;\n    }\n\n    // Transfer ownership to new admin\n    function updateBeneficiary(address payable newBeneficiary) public \n    {\t\t\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    beneficiary = newBeneficiary;\n    }\n\n    function transferOwner(address newOwner) public {\n\t    require(msg.sender == beneficiary || msg.sender == owner); // dev: Only Owner\n\t    owner = newOwner;\n    }\n\n    function updatePublicMint(bool isMint) public {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    isPublicMint = isMint;\n    }\n\n    function updateMaxMintsPerLeaf(uint256 newMax) public {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    maxMintsPerLeaf = newMax;\n    }\n\n    // Stoke token URL for specific token\n    function setTokenUri(uint256 _tokenId, string memory _newUri) public \n    {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    _setTokenURI(_tokenId, _newUri);\n    }\n\n    // Update default token URL when not set\n    function setDefaultMetadata(string memory _newUri) public \n    {\n\t    require(msg.sender == beneficiary); //dev: Only Admin\n\t    defaultMetadata = _newUri;\n    }\n\n    // Update contract URI\n    function setContractURI(string memory _newData) public {\n\t    require(msg.sender == beneficiary); //dev: Only Admin\n\t    _contractURI = _newData;\n    }\t    \n\n\n    /* INTERNAL FUNCTIONS */\n    // Update ID and mint\n    function _mint(address _mintAddress) private {\n\t    currentId += 1;\n\t    _safeMint(_mintAddress, currentId);\n    }\n\n\n    // Sets `_tokenURI` as the tokenURI of `tokenId` Requirements: `tokenId` must exist.\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId)); // dev: ERC721URIStorage: URI set of nonexistent token\n        _tokenURIs[tokenId] =  _tokenURI;\n    }\n\n\n    function verifyMerkle(bytes32 leaf, bytes32[] memory proof) public view returns (bool) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided rootA\n        return computedHash == merkleRoot;\n\n    }\n\n\n    // fallback\n\treceive() external payable { }\n\tfallback() external payable { }\n\n\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "\ncontract PACLEXAction is ERC721Enumerable {\n\n    /* VARIABLES */\n    uint256 public currentId;\n    address payable public beneficiary;\n    address public owner;\n\n    address public pacdao = 0xf27AC88ac7e80487f21e5c2C847290b2AE5d7B8e;\n    address public lexarmy = 0xBe9aAF4113B5a4aFCdb7E20c21eAa53C6EE20b10;\n    address public artist = 0x82fDAF8ceD639567dEd54447400b037C4D0719d5;\n\n    mapping(uint256 => string) private _tokenURIs;\n    mapping(bytes32 => uint256) private leafMints;\n\n    uint256 maxMintsPerLeaf = 1;\n\n    string public baseURI = \"ipfs://\";\n    string public defaultMetadata = \"QmTYvCgKunY8W18kSpCK5eUpHSEzGCmzqQp185AU451ALV\";\n    string private _contractURI = \"Qma4VAp8giZ74Ny7jJVW1e5V8kmC5VVaSeF6cbXWFizxsr\";\n\n    bool isPublicMint = true;\n\n    bytes32 private merkleRoot;\n\n    /* CONSTRUCTOR */\n    constructor () ERC721 (\"PAC/LEX Action\", \"PACLEX-A1\"){\n       owner = msg.sender;\n       beneficiary = payable(0xf27AC88ac7e80487f21e5c2C847290b2AE5d7B8e);\n       merkleRoot = 0xbec6093988d4c88c0ee9b16c888f45b54e42106c79b3244b0a5551c0d4191f26; \n    }\n\n\n    /* PUBLIC VIEWS */\n\n    // Return token URI if set or Default URI\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n\t    require(_exists(tokenId)); // dev: \"ERC721URIStorage: URI query for nonexistent token\";\n\n\t    string memory _tokenURI = _tokenURIs[tokenId];\n\t    string memory base = baseURI;\n\n\t    // If there is no base URI, return the token URI.\n\t    if (bytes(base).length == 0 && bytes(_tokenURI).length > 0) {\n\t        return _tokenURI;\n\t    }\n\n\t    // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n\t    if (bytes(_tokenURI).length > 0) {\n\t        return string(abi.encodePacked(base, _tokenURI));\n\t    }\n\n\t    // No Token URI, return default\n\t    return string(abi.encodePacked(base, defaultMetadata)); \n    }\n\n    // Return contract URI\n    function contractURI() public view returns(string memory) {\n\t    return string(abi.encodePacked(baseURI, _contractURI));\n    }\n    \n\n    /*f = PUBLIC WRITEABLE */\n\n    // Mint NFT if eligible.\n    function mint(bytes32 leaf, bytes32[] memory proof) public\n\t{\n\t\trequire(isPublicMint); // dev: Minting period over\n\t\trequire(verifyMerkle(leaf, proof)); // dev: Invalid Merkle Tree\n\t\trequire(leafMints[leaf] < maxMintsPerLeaf); // dev: Leaf already used\n\t\tleafMints[leaf] += 1;\n\t\t_mint(msg.sender);\n\t\tif(currentId < 3) {\n\t\t\t_mint(artist);\n\t\t}\n\t\tif(currentId < 36) {\n\t\t\t_mint(pacdao);\n\t\t\t_mint(lexarmy);\n\t\t}\n\t}\n\n\n    // Recover funds inadvertently sent to the contract\n    function withdraw() public \n    {\n\t    beneficiary.transfer(address(this).balance);\n    }\n\n\n    /* ADMIN FUNCTIONS */\n    // Admin function to mint an NFT for an address\n    function mintFor(address _mintAddress) public payable\n    {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    require(_mintAddress != address(0));\n\t    _mint(_mintAddress);\n    }\n\n    function updateRoot(bytes32 newRoot) public {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    merkleRoot = newRoot;\n    }\n\n    // Transfer ownership to new admin\n    function updateBeneficiary(address payable newBeneficiary) public \n    {\t\t\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    beneficiary = newBeneficiary;\n    }\n\n    function transferOwner(address newOwner) public {\n\t    require(msg.sender == beneficiary || msg.sender == owner); // dev: Only Owner\n\t    owner = newOwner;\n    }\n\n    function updatePublicMint(bool isMint) public {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    isPublicMint = isMint;\n    }\n\n    function updateMaxMintsPerLeaf(uint256 newMax) public {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    maxMintsPerLeaf = newMax;\n    }\n\n    // Stoke token URL for specific token\n    function setTokenUri(uint256 _tokenId, string memory _newUri) public \n    {\n\t    require(msg.sender == beneficiary); // dev: Only Admin\n\t    _setTokenURI(_tokenId, _newUri);\n    }\n\n    // Update default token URL when not set\n    function setDefaultMetadata(string memory _newUri) public \n    {\n\t    require(msg.sender == beneficiary); //dev: Only Admin\n\t    defaultMetadata = _newUri;\n    }\n\n    // Update contract URI\n    function setContractURI(string memory _newData) public {\n\t    require(msg.sender == beneficiary); //dev: Only Admin\n\t    _contractURI = _newData;\n    }\t    \n\n\n    /* INTERNAL FUNCTIONS */\n    // Update ID and mint\n    function _mint(address _mintAddress) private {\n\t    currentId += 1;\n\t    _safeMint(_mintAddress, currentId);\n    }\n\n\n    // Sets `_tokenURI` as the tokenURI of `tokenId` Requirements: `tokenId` must exist.\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId)); // dev: ERC721URIStorage: URI set of nonexistent token\n        _tokenURIs[tokenId] =  _tokenURI;\n    }\n\n\n    function verifyMerkle(bytes32 leaf, bytes32[] memory proof) public view returns (bool) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided rootA\n        return computedHash == merkleRoot;\n\n    }\n\n\n    // fallback\n\treceive() external payable { }\n\tfallback() external payable { }\n\n\n}\n"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract CrymCoin {\r\n        \r\n        string public constant name = \"CrymCoin\";\r\n        string public constant symbol = \"CRYM\";\r\n        uint8 public constant decimals = 8;\r\n        uint public _totalSupply = 88888888800000000;\r\n        uint256 public RATE = 1;\r\n        bool public isMinting = false;\r\n        string public constant generatedBy  = \"Togen.io by Proof Suite\";\r\n        \r\n        using SafeMath for uint256;\r\n        address public owner;\r\n        \r\n         // Functions with this modifier can only be executed by the owner\r\n         modifier onlyOwner() {\r\n            if (msg.sender != owner) {\r\n                throw;\r\n            }\r\n             _;\r\n         }\r\n     \r\n        // Balances for each account\r\n        mapping(address => uint256) balances;\r\n        // Owner of account approves the transfer of an amount to another account\r\n        mapping(address => mapping(address=>uint256)) allowed;\r\n\r\n        // Its a payable function works as a token factory.\r\n        function () payable{\r\n            createTokens();\r\n        }\r\n\r\n        // Constructor\r\n        constructor() public {\r\n            owner = 0xf525f66d9207c273748be7dda455d185b950ee12; \r\n            balances[owner] = _totalSupply;\r\n        }\r\n\r\n        //allows owner to burn tokens that are not sold in a crowdsale\r\n        function burnTokens(uint256 _value) onlyOwner {\r\n\r\n             require(balances[msg.sender] >= _value && _value > 0 );\r\n             _totalSupply = _totalSupply.sub(_value);\r\n             balances[msg.sender] = balances[msg.sender].sub(_value);\r\n             \r\n        }\r\n\r\n\r\n\r\n        // This function creates Tokens  \r\n         function createTokens() payable {\r\n            if(isMinting == true){\r\n                require(msg.value > 0);\r\n                uint256  tokens = msg.value.div(100000000000000).mul(RATE);\r\n                balances[msg.sender] = balances[msg.sender].add(tokens);\r\n                _totalSupply = _totalSupply.add(tokens);\r\n                owner.transfer(msg.value);\r\n            }\r\n            else{\r\n                throw;\r\n            }\r\n        }\r\n\r\n\r\n        function endCrowdsale() onlyOwner {\r\n            isMinting = false;\r\n        }\r\n\r\n        function changeCrowdsaleRate(uint256 _value) onlyOwner {\r\n            RATE = _value;\r\n        }\r\n\r\n\r\n        \r\n        function totalSupply() constant returns(uint256){\r\n            return _totalSupply;\r\n        }\r\n        // What is the balance of a particular account?\r\n        function balanceOf(address _owner) constant returns(uint256){\r\n            return balances[_owner];\r\n        }\r\n\r\n         // Transfer the balance from owner's account to another account   \r\n        function transfer(address _to, uint256 _value)  returns(bool) {\r\n            require(balances[msg.sender] >= _value && _value > 0 );\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        \r\n    // Send _value amount of tokens from address _from to address _to\r\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n    // fees in sub-currencies; the command should fail unless the _from account has\r\n    // deliberately authorized the sender of the message via some mechanism; we propose\r\n    // these standardized APIs for approval:\r\n    function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {\r\n        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _value) returns(bool){\r\n        allowed[msg.sender][_spender] = _value; \r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) constant returns(uint256){\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract Page is ERC721, ERC721Enumerable, Ownable, RoyaltiesV2Impl {\r\n    event CollaboratorsChanged(address[] fromCollaboratorsAddress, address[] toCollaboratorsAddress, uint[] fromCollaboratorsSplit,  uint[] toCollaboratorsSplit);\r\n    event CollectorChanged(address from, address to, uint256 tokenId);\r\n    event GiveawayReleased(address to, uint256 amount);\r\n    event GiveawayReceived(address from, uint256 amount);\r\n    \r\n    using Counters for Counters.Counter;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n    \r\n    uint256 private _mintingPrice = 0.42 ether;\r\n\r\n    uint256 private _totalReleased;\r\n    string private _currentBaseURI;\r\n    uint private _maxSupply;\r\n    \r\n    mapping(uint256 => uint256) private _released;\r\n    mapping(uint => Counters.Counter) private _timesMinted;\r\n    mapping(uint => bool) private _chapterOpenForMinting;\r\n    \r\n    address[] private _collaboratorsAddress = [0xDF5529D9AC4F342387a525B8495712967FD9dB83, 0x0AA457e8914618a5Fc26b4bc36B7B34385725883, 0x110920f43E2e4ff3F3dbcb839b70734d66bde8F2, address(this)];\r\n    uint[] private _collaboratorsSplit =  [\r\n        // This is the initial split\r\n        21, // Token Collaborator 1\r\n        21, // Token Collaborator 2\r\n        42, // Artist\r\n        16  // Token Holder Community\r\n    ];\r\n\r\n    CollaboratorsPaymentSplitter private _collaboratorsPaymentSplitter;\r\n    \r\n    constructor() ERC721(\"100 Pages\", \"PAGE\") {\r\n        _currentBaseURI = \"https://batistaonthebeat.com/100pages/token/\";\r\n        _collaboratorsPaymentSplitter = new CollaboratorsPaymentSplitter(_collaboratorsAddress, _collaboratorsSplit);\r\n    }\r\n\r\n    function mintPage(uint8 page) external payable {\r\n        require(address(_collaboratorsPaymentSplitter) != address(0), \"PagesToken: CollectorPaymentSplitter not set\");\r\n        require(msg.value == _mintingPrice, \"PagesToken: incorrect minting prince\");\r\n        require(1 <= page && page <= 100, \"PagesToken: page must be between 1 and 100\");\r\n\r\n        uint chapter = getChapter(page);\r\n        require(_chapterOpenForMinting[chapter] == true, \"PagesToken: chapter is not opened for minting\");\r\n        \r\n        uint nOfHundred = _timesMinted[page].current();\r\n        require(nOfHundred < 100, \"PagesToken: each page can only be minted 100 times\");\r\n        uint256 tokenId = id(page, nOfHundred+1);\r\n        safeMint(msg.sender, tokenId);\r\n        _timesMinted[page].increment();\r\n        payable(_collaboratorsPaymentSplitter).transfer(_mintingPrice);\r\n        // auto release to collaborators on mint\r\n        _collaboratorsPaymentSplitter.release(payable(address(this)));\r\n    }\r\n\r\n    function safeMint(address to, uint256 tokenId) internal {\r\n        _safeMint(to, tokenId);\r\n        _setRoyalties(tokenId, payable(_collaboratorsPaymentSplitter), 1000);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\r\n        internal\r\n        override(ERC721, ERC721Enumerable)\r\n    {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n        if (from != address(0) && _pendingGiveaway(tokenId) > 0){\r\n            changeCollector(from, to, tokenId);\r\n        }\r\n    }\r\n\r\n   /**\r\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\r\n     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\r\n     * reliability of the events, and not the actual splitting of Ether.\r\n     *\r\n     * To learn more about this see the Solidity documentation for\r\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\r\n     * functions].\r\n     */\r\n    receive() external payable virtual {\r\n        emit GiveawayReceived(_msgSender(), msg.value);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(ERC721, ERC721Enumerable)\r\n        returns (bool)\r\n    {\r\n        if(interfaceId == LibRoyaltiesV2._INTERFACE_ID_ROYALTIES) {\r\n            return true;\r\n        }\r\n        if(interfaceId == _INTERFACE_ID_ERC2981) {\r\n            return true;\r\n        }\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n    \r\n    function setBaseURI(string memory baseURI) public onlyOwner {\r\n        _currentBaseURI = baseURI;\r\n    }\r\n\r\n    function setMintingPrice(uint256 newPrice) public onlyOwner {\r\n        _mintingPrice = newPrice;\r\n    }\r\n\r\n    function getMintingPrice() public view returns (uint) {\r\n        return _mintingPrice;\r\n    }\r\n\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return _currentBaseURI;\r\n    }\r\n    \r\n    function getChapter(uint page) public pure returns (uint) {\r\n        require(1 <= page && page <= 100, \"PagesToken: page must be between 1 and 100\");\r\n        return (uint(page-1)/20) + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Change Collector for a tokenID.\r\n     */\r\n    function changeCollector(address from, address to, uint256 tokenId) internal {\r\n        // this is to skip on minting\r\n        if (from != address(0)){\r\n            require(ownerOf(tokenId) == from, \"CollectorsGiveawaySplitter: from account is not the owner for tokenId\");\r\n            // if tokenId has balance, pay it out then emit CollectorChanged\r\n            if (_pendingGiveaway(tokenId) != 0){\r\n                release(tokenId);\r\n            }\r\n        }\r\n        emit CollectorChanged(from, to, tokenId);\r\n    }\r\n\r\n    function ReleaseMyGiveaway() public virtual {\r\n        release(payable(_msgSender()));\r\n    }\r\n\r\n    function release(address payable account) public virtual {\r\n        uint256 _ownedTokens = balanceOf(account);\r\n        require(_ownedTokens > 0, \"CollectorsGiveawaySplitter: account has no tokens\");\r\n        uint256 totalGiveaway = _pendingGiveaway(account);\r\n        require(totalGiveaway > 0, \"GiveawaySplitter: account is not due giveaway\");\r\n\r\n        Address.sendValue(account, totalGiveaway);\r\n        \r\n        _totalReleased += totalGiveaway;\r\n        for (uint256 i = 0; i < (_ownedTokens ); i++) {\r\n            uint currentToken = tokenOfOwnerByIndex(account, i);\r\n            uint256 giveawayForToken = _pendingGiveaway(currentToken);\r\n            _released[currentToken] += giveawayForToken;\r\n        }\r\n        emit GiveawayReleased(account, totalGiveaway);\r\n    }\r\n\r\n    function release(uint256 tokenId) public virtual {\r\n        address tokenOwner = ownerOf(tokenId);\r\n        require(tokenOwner != address(0), \"CollectorsGiveawaySplitter: tokenId owner is the zero address\");\r\n\r\n        uint256 _tokenPendingGiveaways = _pendingGiveaway(tokenId);\r\n        require(_tokenPendingGiveaways > 0, \"CollectorsGiveawaySplitter: tokenId is not due any giveaways\");\r\n        Address.sendValue(payable(tokenOwner), _tokenPendingGiveaways);\r\n        _totalReleased += _tokenPendingGiveaways;\r\n        _released[tokenId]+= _tokenPendingGiveaways;\r\n        emit GiveawayReleased(tokenOwner, _tokenPendingGiveaways);\r\n    }\r\n\r\n    function _pendingGiveaway(uint256 tokenId) private view returns (uint256) {\r\n        return (address(this).balance + totalReleased()) / maxSupply() - _released[tokenId];\r\n    }\r\n\r\n    function PendingGiveaway() public view returns (uint256) {\r\n        uint256 _ownedTokens = balanceOf(_msgSender());\r\n        require(_ownedTokens > 0, \"CollectorsGiveawaySplitter: account has no tokens\");\r\n        return _pendingGiveaway(_msgSender());\r\n    }\r\n\r\n    function _pendingGiveaway(address account) private view returns (uint256) {\r\n        uint256 _ownedTokens = balanceOf(account);\r\n\r\n        uint256 totalGiveaway = 0;\r\n        for (uint256 i = 0; i < (_ownedTokens); i++) {\r\n            uint currentToken = tokenOfOwnerByIndex(account, i);\r\n            uint256 giveawayForToken = _pendingGiveaway(currentToken);\r\n            totalGiveaway += giveawayForToken;\r\n        }\r\n        return totalGiveaway;\r\n    }\r\n\r\n    function totalReleased() public view returns (uint256) {\r\n        return _totalReleased;\r\n    }\r\n\r\n    function setCollaboratorsPaymentSplitter(address[] memory collaboratorsAddress, uint[] memory collaboratorsSplit) public onlyOwner () {\r\n        _collaboratorsPaymentSplitter = new CollaboratorsPaymentSplitter(_collaboratorsAddress, _collaboratorsSplit);\r\n        emit CollaboratorsChanged(_collaboratorsAddress, collaboratorsAddress, _collaboratorsSplit, collaboratorsSplit);\r\n        _collaboratorsAddress = collaboratorsAddress;\r\n        _collaboratorsSplit = collaboratorsSplit;\r\n    }\r\n\r\n    function getCollaboratorsPaymentSplitter() public view returns (address) {\r\n        return address(_collaboratorsPaymentSplitter);\r\n    }\r\n\r\n    function id(uint page, uint nOfHundred) internal pure returns (uint) {\r\n        require(1 <= page && page <= 100 && nOfHundred > 0 && nOfHundred < 101, \"PagesToken: page must be between 1 and 100 and nOfHundred 1-100\");\r\n        return (uint((page * 100) - (100 - nOfHundred)));\r\n    }\r\n\r\n    function ownerOf(uint page, uint nOfHundred) public view returns (address) {\r\n        require(1 <= page && page <= 100 && nOfHundred > 0 && nOfHundred < 101, \"PagesToken: page must be between 1 and 100 and nOfHundred 1-100\");\r\n        return ownerOf(id(page, nOfHundred));\r\n    }\r\n\r\n    function openChapterForMinting(uint chapter) public onlyOwner {\r\n        require(1 <= chapter && chapter <= 5 , \"PagesToken: chapter must be between 1 and 5\");\r\n        require(_chapterOpenForMinting[chapter] == false , \"PagesToken: chapter is already opened\");\r\n        if (chapter > 1 ){\r\n            require(_chapterOpenForMinting[chapter-1] == true , \"PagesToken: previous chapter is not opened\");\r\n        }\r\n        _chapterOpenForMinting[chapter] = true;\r\n        _maxSupply = chapter * 2000;\r\n    }\r\n\r\n    function maxSupply() public view returns (uint) {\r\n        return _maxSupply;\r\n    }\r\n    \r\n    function canMintPage(uint page) public view returns (bool) {\r\n        require(1 <= page && page <= 100, \"PagesToken: page must be between 1 and 100\");\r\n        return _chapterOpenForMinting[getChapter(page)] && (timesMinted(page) < 100);\r\n    }\r\n\r\n    function timesMinted(uint page) public view returns (uint) {\r\n        require(1 <= page && page <= 100, \"page must be between 1 and 100\");\r\n        return _timesMinted[page].current();\r\n    }\r\n\r\n    function _setRoyalties(uint _tokenId, address payable _royaltiesReceipientAddress, uint96 _percentageBasisPoints) internal {\r\n        LibPart.Part[] memory _royalties = new LibPart.Part[](1);\r\n        _royalties[0].value = _percentageBasisPoints;\r\n        _royalties[0].account = _royaltiesReceipientAddress;\r\n        _saveRoyalties(_tokenId, _royalties);\r\n    }\r\n\r\n    function setRoyalties(uint _tokenId, address payable _royaltiesReceipientAddress, uint96 _percentageBasisPoints) public onlyOwner {\r\n        _setRoyalties(_tokenId, _royaltiesReceipientAddress, _percentageBasisPoints);\r\n    }\r\n\r\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount) {\r\n        LibPart.Part[] memory _royalties = royalties[_tokenId];\r\n        if(_royalties.length > 0) {\r\n            return (_royalties[0].account, (_salePrice * _royalties[0].value)/10000);\r\n        }\r\n        return (address(0), 0);\r\n    }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract Yggdrasil is ERC1155, Ownable, ERC1155Burnable {\n    constructor()\n        ERC1155(\"ipfs://QmUwpygdcrpdCbuQwLV4dw8xmfQSR21jnXAj9vz8AZHECF\")\n    {}\n\n    //  Total token supply\n    //  Altered by mint & burn functions\n    uint256 supply;\n\n    //  Address of the relayer used for token distribution\n    address public relayerAddress;\n\n    //  Address used for token minting and storage\n    address public anthroWalletAddress;\n\n    //  Getter function for front-ends\n    function totalSupply() public view returns(uint256) {\n        return (supply);\n    }\n\n    //  Set relayer address, can only be used by Owner\n    function setRelayerAddress(address relayer) public onlyOwner {\n        relayerAddress = relayer;\n        setApprovalForAll(relayer, true);\n    }\n\n    //  Set anthromancer wallet address, can only be used by Owner\n    function setAnthroWalletAddress(address anthroWallet) public onlyOwner {\n        anthroWalletAddress = anthroWallet;\n    }\n\n    //  Main mint function, can only be used by Owner\n    function mintBatch(uint total)\n        public\n        onlyOwner{\n\n         uint[] memory tokenId = new uint[](1);\n        tokenId[0] = 1;  \n\n        uint[] memory amount = new uint[](1);\n        amount[0] = total;\n        \n\n        supply = supply + total;\n        \n        _mintBatch(anthroWalletAddress, tokenId, amount, abi.encodePacked(\"1\"));\n    }\n\n    //  Main distro function, can only be used by Owner & Relayer\n    function transferToBacker(address backerAddress) public {\n        require (msg.sender == owner() || msg.sender == relayerAddress);\n        _safeTransferFrom(anthroWalletAddress, backerAddress, 1, 1, abi.encodePacked(\"1\"));\n    }\n    \n    //  Burn token function, can only be used by Token Owner or Approved\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public override virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n        supply= supply - value;\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract EtchedNFT1155 is ERC1155, ERC165Storage, Ownable, IERC2981 {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _id;\n\n    // royalty rate vars\n    // scale: how many zeroes should follow the royalty rate\n    // in the default values, there would be a 10% tax on a 18 decimal asset\n    uint256 private rate = 10_000;\n    uint256 private scale = 1e5;\n\n    mapping(uint256 => string) private _tokenURIs;\n    mapping(uint256 => address) private _creators;\n    mapping(uint256 => uint256) private _totalSupply;\n    // id => user => if they're a minter\n    mapping(address => bool) private minters;\n\n    event TokenURI(\n        uint256 indexed id,\n        string tokenUri,\n        uint256 amount,\n        address creator,\n        address owner\n    );\n    event RoyaltyRateSet(uint256 indexed rate, uint256 indexed scale);\n    event MinterUpdated(\n        address indexed minter,\n        bool indexed canMint,\n        string userIdentifier\n    );\n    event CapSet(uint256 indexed id, uint256 indexed cap);\n\n    constructor() ERC1155(\"\") {\n        ERC165Storage._registerInterface(type(IERC2981).interfaceId);\n        ERC165Storage._registerInterface(type(IERC1155).interfaceId);\n        ERC165Storage._registerInterface(type(IERC1155MetadataURI).interfaceId);\n\n        // ids 1,2 reserved for airdrop\n        _id.increment();\n        _id.increment();\n\n        // hardcoding for HDA airdrop\n        _creators[1] = address(0xeb7b2f62BFBac835CCb3e1ddE38CE79D89a8445C);\n        _tokenURIs[1] = \"QmT4RVQwvY8tghLa2HzZEFvEGxNRsZf3Fxb8byooMK6Ff4\";\n\n        // hardcoding for founder's key\n        _creators[2] = address(0xeb7b2f62BFBac835CCb3e1ddE38CE79D89a8445C);\n        _tokenURIs[2] = \"QmWrhHtZLEkUg46MjjkyhYW8uuijPm89842CcRTeHxUJ6j\";\n    }\n\n    //  Queries the URI of an NFT\n    // parameter: id is the index of the NFT to query\n    // returns the URI string of the NFT\n    function uri(uint256 id) public view override returns (string memory) {\n        return _tokenURIs[id];\n    }\n\n    //  Queries the supply of a particular NFT\n    // parameter: id is the index of the NFT to query the supply of\n    // returns the total number of NFTs in circulation for this NFT\n    function totalSupply(uint256 id) external view returns (uint256) {\n        require(id <= _id.current(), \"id has not been minted\");\n        return _totalSupply[id];\n    }\n\n    //  Given an NFT and the amount of a price, returns pertinent royalty information\n    //  This function is specified in EIP-2981\n    // parameter: id is the index of the NFT to calculate royalties on\n    // parameter: _salePrice is the amount the NFT is being sold for\n    // returns the address to send the royalties to, and the amount to send\n    function royaltyInfo(uint256 id, uint256 _salePrice)\n        external\n        view\n        override\n        returns (address, uint256)\n    {\n        require(_exists(id), \"royaltyInfo: nonexistent token\");\n        uint256 royaltyAmount = (_salePrice * rate) / scale;\n        return (getCreator(id), royaltyAmount);\n    }\n\n    //  gets the global royalty rate\n    //  divide rate by scale to get the percentage taken as royalties\n    // @return a tuple of (rate, scale)\n    function getRoyaltyRate() external view returns (uint256, uint256) {\n        return (rate, scale);\n    }\n\n    //  Queries if an address is allowed to mint\n    // parameter: minter is the address to check\n    // returns bool if the address is a minter or not\n    function isMinter(address minter) external view returns (bool) {\n        return minters[minter];\n    }\n\n    //  gets the address of a creator for an NFT\n    //  The first 450 tokenIds are reserved for the HDA airdrop\n    // parameter: id is the index of the NFT to return the creator of\n    // returns the address of the creator\n    function getCreator(uint256 id) public view returns (address) {\n        require(_exists(id), \"getCreator: nonexistent token\");\n        return _creators[id];\n    }\n\n    //  Sets the global variables relating to royalties\n    // parameter: _rate is the amount, that when adjusted with the scale, represents the royalty rate\n    // parameter: _scale is the amount of decimal places to scale the rate when applying\n    // example: given an 18-decimal currency, a rate of 5 with a scale of 1e16 would be 5%\n    // since this is 0.05 to an 18-decimal currency\n    function setRoyaltyRate(uint256 _rate, uint256 _scale) external onlyOwner {\n        rate = _rate;\n        scale = _scale;\n        emit RoyaltyRateSet(_rate, _scale);\n    }\n\n    //  Allows contract owner to add or remove minters to a specific id\n    // parameter: minter is the address to update\n    // parameter: canMint is the status the address should be set to\n    function setMinter(\n        address minter,\n        bool canMint,\n        string calldata userIdentifier\n    ) external onlyOwner {\n        minters[minter] = canMint;\n        emit MinterUpdated(minter, canMint, userIdentifier);\n    }\n\n    //  Allows a whitelisted address to mint a single NFT\n    // parameter: creator is the address to be recorded as the NFT's creator\n    // parameter: to is the address to mint the NFT to\n    // parameter: amount is the amount of NFTs to mint\n    // parameter: tokenUri is the IPFS hash of the NFT metadata\n    function mint(\n        address creator,\n        address to,\n        uint256 amount,\n        string memory tokenUri\n    ) external {\n        _id.increment();\n        uint256 id = _id.current();\n        require(\n            minters[msg.sender] == true || msg.sender == owner(),\n            \"unauthorized minter\"\n        );\n        _mint(to, id, amount, \"\");\n        _totalSupply[id] = amount;\n        _tokenURIs[id] = tokenUri;\n        _creators[id] = creator;\n        emit TokenURI(id, tokenUri, amount, creator, to);\n    }\n\n    //  batch mint function\n    //  can only be called by owner, will mint all NFTs to one address for distribution\n    // parameter: to is the address to mint all NFTs to\n    // parameter: creators is an ordered array of the addresses to list as creators for each NFT\n    // parameter: amounts is an ordered array of the amount of each NFT to mint\n    // parameter: uris is the uri of each NFT being minted\n    function mintBatch(\n        address to,\n        address[] memory creators,\n        uint256[] memory amounts,\n        string[] memory uris\n    ) external onlyOwner {\n        uint256 len = amounts.length;\n        uint256[] memory ids = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            _id.increment();\n            uint256 tokenId = _id.current();\n            ids[i] = tokenId;\n        }\n        _mintBatch(to, ids, amounts, \"\");\n        for (uint256 i = 0; i < len; i++) {\n            _tokenURIs[ids[i]] = uris[i];\n            _creators[ids[i]] = creators[i];\n            _totalSupply[ids[i]] = amounts[i];\n            emit TokenURI(ids[i], uris[i], amounts[i], _creators[ids[i]], to);\n        }\n    }\n\n    //  Bespoke function for airdropping the HDA NFT and founder's key\n    //  Cycles through an array of addresses and mints\n    // parameter: id 1 (HDA) or 2(Founder's Key)\n    // parameter: to is an array of addresses to send the NFT to\n    // parameter: amount is the amount to send to the corresponding address in `to`\n    function airdrop(\n        uint256 id,\n        address[] memory to,\n        uint256[] memory amount\n    ) external onlyOwner {\n        require(id == 1 || id == 2, \"only ids 1,2 can be airdropped\");\n        // HDA cap: 450, founder's key cap: 75\n        uint256 cap = id == 1 ? 450 : 75;\n        uint256 len = to.length;\n        require(len == amount.length, \"arrays must have equal length\");\n        for (uint256 i = 0; i < len; i++) {\n            uint256 amt = amount[i];\n            require(_totalSupply[id] + amt <= cap, \"airdrop exceeds cap\");\n            address _to = to[i];\n            _totalSupply[id] += amt;\n            _mint(_to, id, amt, \"\");\n        }\n    }\n\n    //  returns true if this contract implements the interface defined by `interfaceId`\n    //  for more on interface ids, see https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Storage, IERC165, ERC1155)\n        returns (bool)\n    {\n        return ERC165Storage.supportsInterface(interfaceId);\n    }\n\n    function _exists(uint256 id) internal view returns (bool) {\n        return\n            _totalSupply[id] > 0 ||\n            _creators[id] != address(0) ||\n            keccak256(bytes(_tokenURIs[id])) != \"\";\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract EtchedNFT1155 is ERC1155, ERC165Storage, Ownable, IERC2981 {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _id;\n\n    // royalty rate vars\n    // scale: how many zeroes should follow the royalty rate\n    // in the default values, there would be a 10% tax on a 18 decimal asset\n    uint256 private rate = 10_000;\n    uint256 private scale = 1e5;\n\n    mapping(uint256 => string) private _tokenURIs;\n    mapping(uint256 => address) private _creators;\n    mapping(uint256 => uint256) private _totalSupply;\n    // id => user => if they're a minter\n    mapping(address => bool) private minters;\n\n    event TokenURI(\n        uint256 indexed id,\n        string tokenUri,\n        uint256 amount,\n        address creator,\n        address owner\n    );\n    event RoyaltyRateSet(uint256 indexed rate, uint256 indexed scale);\n    event MinterUpdated(\n        address indexed minter,\n        bool indexed canMint,\n        string userIdentifier\n    );\n    event CapSet(uint256 indexed id, uint256 indexed cap);\n\n    constructor() ERC1155(\"\") {\n        ERC165Storage._registerInterface(type(IERC2981).interfaceId);\n        ERC165Storage._registerInterface(type(IERC1155).interfaceId);\n        ERC165Storage._registerInterface(type(IERC1155MetadataURI).interfaceId);\n\n        // ids 1,2 reserved for airdrop\n        _id.increment();\n        _id.increment();\n\n        // hardcoding for HDA airdrop\n        _creators[1] = address(0xeb7b2f62BFBac835CCb3e1ddE38CE79D89a8445C);\n        _tokenURIs[1] = \"QmT4RVQwvY8tghLa2HzZEFvEGxNRsZf3Fxb8byooMK6Ff4\";\n\n        // hardcoding for founder's key\n        _creators[2] = address(0xeb7b2f62BFBac835CCb3e1ddE38CE79D89a8445C);\n        _tokenURIs[2] = \"QmWrhHtZLEkUg46MjjkyhYW8uuijPm89842CcRTeHxUJ6j\";\n    }\n\n    //  Queries the URI of an NFT\n    // parameter: id is the index of the NFT to query\n    // returns the URI string of the NFT\n    function uri(uint256 id) public view override returns (string memory) {\n        return _tokenURIs[id];\n    }\n\n    //  Queries the supply of a particular NFT\n    // parameter: id is the index of the NFT to query the supply of\n    // returns the total number of NFTs in circulation for this NFT\n    function totalSupply(uint256 id) external view returns (uint256) {\n        require(id <= _id.current(), \"id has not been minted\");\n        return _totalSupply[id];\n    }\n\n    //  Given an NFT and the amount of a price, returns pertinent royalty information\n    //  This function is specified in EIP-2981\n    // parameter: id is the index of the NFT to calculate royalties on\n    // parameter: _salePrice is the amount the NFT is being sold for\n    // returns the address to send the royalties to, and the amount to send\n    function royaltyInfo(uint256 id, uint256 _salePrice)\n        external\n        view\n        override\n        returns (address, uint256)\n    {\n        require(_exists(id), \"royaltyInfo: nonexistent token\");\n        uint256 royaltyAmount = (_salePrice * rate) / scale;\n        return (getCreator(id), royaltyAmount);\n    }\n\n    //  gets the global royalty rate\n    //  divide rate by scale to get the percentage taken as royalties\n    // @return a tuple of (rate, scale)\n    function getRoyaltyRate() external view returns (uint256, uint256) {\n        return (rate, scale);\n    }\n\n    //  Queries if an address is allowed to mint\n    // parameter: minter is the address to check\n    // returns bool if the address is a minter or not\n    function isMinter(address minter) external view returns (bool) {\n        return minters[minter];\n    }\n\n    //  gets the address of a creator for an NFT\n    //  The first 450 tokenIds are reserved for the HDA airdrop\n    // parameter: id is the index of the NFT to return the creator of\n    // returns the address of the creator\n    function getCreator(uint256 id) public view returns (address) {\n        require(_exists(id), \"getCreator: nonexistent token\");\n        return _creators[id];\n    }\n\n    //  Sets the global variables relating to royalties\n    // parameter: _rate is the amount, that when adjusted with the scale, represents the royalty rate\n    // parameter: _scale is the amount of decimal places to scale the rate when applying\n    // example: given an 18-decimal currency, a rate of 5 with a scale of 1e16 would be 5%\n    // since this is 0.05 to an 18-decimal currency\n    function setRoyaltyRate(uint256 _rate, uint256 _scale) external onlyOwner {\n        rate = _rate;\n        scale = _scale;\n        emit RoyaltyRateSet(_rate, _scale);\n    }\n\n    //  Allows contract owner to add or remove minters to a specific id\n    // parameter: minter is the address to update\n    // parameter: canMint is the status the address should be set to\n    function setMinter(\n        address minter,\n        bool canMint,\n        string calldata userIdentifier\n    ) external onlyOwner {\n        minters[minter] = canMint;\n        emit MinterUpdated(minter, canMint, userIdentifier);\n    }\n\n    //  Allows a whitelisted address to mint a single NFT\n    // parameter: creator is the address to be recorded as the NFT's creator\n    // parameter: to is the address to mint the NFT to\n    // parameter: amount is the amount of NFTs to mint\n    // parameter: tokenUri is the IPFS hash of the NFT metadata\n    function mint(\n        address creator,\n        address to,\n        uint256 amount,\n        string memory tokenUri\n    ) external {\n        _id.increment();\n        uint256 id = _id.current();\n        require(\n            minters[msg.sender] == true || msg.sender == owner(),\n            \"unauthorized minter\"\n        );\n        _mint(to, id, amount, \"\");\n        _totalSupply[id] = amount;\n        _tokenURIs[id] = tokenUri;\n        _creators[id] = creator;\n        emit TokenURI(id, tokenUri, amount, creator, to);\n    }\n\n    //  batch mint function\n    //  can only be called by owner, will mint all NFTs to one address for distribution\n    // parameter: to is the address to mint all NFTs to\n    // parameter: creators is an ordered array of the addresses to list as creators for each NFT\n    // parameter: amounts is an ordered array of the amount of each NFT to mint\n    // parameter: uris is the uri of each NFT being minted\n    function mintBatch(\n        address to,\n        address[] memory creators,\n        uint256[] memory amounts,\n        string[] memory uris\n    ) external onlyOwner {\n        uint256 len = amounts.length;\n        uint256[] memory ids = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            _id.increment();\n            uint256 tokenId = _id.current();\n            ids[i] = tokenId;\n        }\n        _mintBatch(to, ids, amounts, \"\");\n        for (uint256 i = 0; i < len; i++) {\n            _tokenURIs[ids[i]] = uris[i];\n            _creators[ids[i]] = creators[i];\n            _totalSupply[ids[i]] = amounts[i];\n            emit TokenURI(ids[i], uris[i], amounts[i], _creators[ids[i]], to);\n        }\n    }\n\n    //  Bespoke function for airdropping the HDA NFT and founder's key\n    //  Cycles through an array of addresses and mints\n    // parameter: id 1 (HDA) or 2(Founder's Key)\n    // parameter: to is an array of addresses to send the NFT to\n    // parameter: amount is the amount to send to the corresponding address in `to`\n    function airdrop(\n        uint256 id,\n        address[] memory to,\n        uint256[] memory amount\n    ) external onlyOwner {\n        require(id == 1 || id == 2, \"only ids 1,2 can be airdropped\");\n        // HDA cap: 450, founder's key cap: 75\n        uint256 cap = id == 1 ? 450 : 75;\n        uint256 len = to.length;\n        require(len == amount.length, \"arrays must have equal length\");\n        for (uint256 i = 0; i < len; i++) {\n            uint256 amt = amount[i];\n            require(_totalSupply[id] + amt <= cap, \"airdrop exceeds cap\");\n            address _to = to[i];\n            _totalSupply[id] += amt;\n            _mint(_to, id, amt, \"\");\n        }\n    }\n\n    //  returns true if this contract implements the interface defined by `interfaceId`\n    //  for more on interface ids, see https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Storage, IERC165, ERC1155)\n        returns (bool)\n    {\n        return ERC165Storage.supportsInterface(interfaceId);\n    }\n\n    function _exists(uint256 id) internal view returns (bool) {\n        return\n            _totalSupply[id] > 0 ||\n            _creators[id] != address(0) ||\n            keccak256(bytes(_tokenURIs[id])) != \"\";\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract Ghost_Core_Finance is ERC20Detailed {\n\n  using SafeMath for uint256;\n  mapping (address => uint256) private _balances;\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  string constant tokenName = \"Ghost Core Finance\";\n  string constant tokenSymbol = \"GHCO\";\n  uint8  constant tokenDecimals = 18;\n  uint256 _totalSupply = 76000000000000000000000;\n  uint256 public basePercent = 100;\n\n  constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n    _mint(msg.sender, _totalSupply);\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  function allowance(address owner, address spender) public view returns (uint256) {\n    return _allowed[owner][spender];\n  }\n\n  function findOnePercent(uint256 value) public view returns (uint256)  {\n    uint256 roundValue = value.ceil(basePercent);\n    uint256 onePercent = roundValue.mul(basePercent).div(10000);\n    return onePercent;\n  }\n// Allow token to be traded/sent from account to account \n// allow for staking and governance plug-in\n\n  function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender]);\n    require(to != address(0));\n\n    uint256 tokensToBurn = 0;\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(tokensToTransfer);\n\n    _totalSupply = _totalSupply.sub(tokensToBurn);\n\n    emit Transfer(msg.sender, to, tokensToTransfer);\n    emit Transfer(msg.sender, address(0), tokensToBurn);\n    return true;\n  }\n\n  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n    for (uint256 i = 0; i < receivers.length; i++) {\n      transfer(receivers[i], amounts[i]);\n    }\n  }\n\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n\n    uint256 tokensToBurn = 0;\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n    _balances[to] = _balances[to].add(tokensToTransfer);\n    _totalSupply = _totalSupply.sub(tokensToBurn);\n\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n    emit Transfer(from, to, tokensToTransfer);\n    emit Transfer(from, address(0), tokensToBurn);\n\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n//  1-time token mint/creation function. Tokens are only minted during contract creation, and cannot be done again.\n  function _mint(address account, uint256 amount) internal {\n    require(amount != 0);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal {\n    require(amount != 0);\n    require(amount <= _balances[account]);\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[account] = _balances[account].sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function burnFrom(address account, uint256 amount) external {\n    require(amount <= _allowed[account][msg.sender]);\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);\n    _burn(account, amount);\n  }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract dolopManNFT is ERC721Enumerable, Ownable {\n  using Strings for uint256;\n\n  string public baseURI;\n  string public baseExtension = \".json\";\n  uint256 public cost = .025 ether;\n  uint256 public maxSupply = 5000;\n  uint256 public maxMintAmount = 20;\n  bool public paused = false;\n  mapping(address => bool) public whitelisted;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    string memory _initBaseURI\n  ) ERC721(_name, _symbol) {\n    setBaseURI(_initBaseURI);\n    mint(msg.sender, 20);\n  }\n\n  // internal\n  function _baseURI() internal view virtual override returns (string memory) {\n    return baseURI;\n  }\n\n  // public\n  function mint(address _to, uint256 _mintAmount) public payable {\n    uint256 supply = totalSupply();\n    require(!paused);\n    require(_mintAmount > 0);\n    require(_mintAmount <= maxMintAmount);\n    require(supply + _mintAmount <= maxSupply);\n\n    if (msg.sender != owner()) {\n        if(whitelisted[msg.sender] != true) {\n          require(msg.value >= cost * _mintAmount);\n        }\n    }\n\n    for (uint256 i = 1; i <= _mintAmount; i++) {\n      _safeMint(_to, supply + i);\n    }\n  }\n\n  function walletOfOwner(address _owner)\n    public\n    view\n    returns (uint256[] memory)\n  {\n    uint256 ownerTokenCount = balanceOf(_owner);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\n    }\n    return tokenIds;\n  }\n\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    require(\n      _exists(tokenId),\n      \"ERC721Metadata: URI query for nonexistent token\"\n    );\n\n    string memory currentBaseURI = _baseURI();\n    return bytes(currentBaseURI).length > 0\n        ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\n        : \"\";\n  }\n\n  //only owner\n  function setCost(uint256 _newCost) public onlyOwner() {\n    cost = _newCost;\n  }\n\n  function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner() {\n    maxMintAmount = _newmaxMintAmount;\n  }\n\n  function setBaseURI(string memory _newBaseURI) public onlyOwner {\n    baseURI = _newBaseURI;\n  }\n\n  function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\n    baseExtension = _newBaseExtension;\n  }\n\n  function pause(bool _state) public onlyOwner {\n    paused = _state;\n  }\n \n function whitelistUser(address _user) public onlyOwner {\n    whitelisted[_user] = true;\n  }\n \n  function removeWhitelistUser(address _user) public onlyOwner {\n    whitelisted[_user] = false;\n  }\n\n  function withdraw() public payable onlyOwner {\n    require(payable(msg.sender).send(address(this).balance));\n  }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "abstract contract ERC721EnumerableSimple is ERC721, IERC721Enumerable {\n    // user => tokenId[]\n    mapping(address => mapping(uint => uint)) private _ownedTokens;\n\n    // tokenId => index of _ownedTokens[user] (used when changing token ownership)\n    mapping(uint => uint) private _ownedTokensIndex;\n\n    // current total amount of token minted\n    uint private _totalSupply;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function tokenByIndex(uint index) public view virtual override returns (uint) {\n        require(index < ERC721EnumerableSimple.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return index;\n    }\n\n    /// Hook that is called before any token transfer. This includes minting\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            assert(tokenId == _totalSupply); // Ensure token is minted sequentially\n            _totalSupply += 1;\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n\n        if (to == address(0)) {\n            // do nothing\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    // Private function to add a token to this extension's ownership-tracking data structures.\n    // Parameter: to is address representing the new owner of the given token ID\n    // Parameter: tokenId is the ID of the token to be added to the tokens list of the given address\n    function _addTokenToOwnerEnumeration(address to, uint tokenId) private {\n        uint length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    // Paramter: from is the address representing the previous owner of the given token ID\n    // Parameter: tokenId is the ID of the token to be removed from the tokens list of the given address\n    function _removeTokenFromOwnerEnumeration(address from, uint tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract WStakingRewards is ERC1155('WStakingRewards'), ReentrancyGuard, IERC20Wrapper {\n  using SafeMath for uint;\n  using HomoraMath for uint;\n  using SafeERC20 for IERC20;\n\n  address public immutable staking; // Staking reward contract address\n  address public immutable underlying; // Underlying token address\n  address public immutable reward; // Reward token address\n\n  constructor(\n    address _staking,\n    address _underlying,\n    address _reward\n  ) public {\n    staking = _staking;\n    underlying = _underlying;\n    reward = _reward;\n    IERC20(_underlying).safeApprove(_staking, uint(-1));\n  }\n\n  //  Return the underlying ERC20 for the given ERC1155 token id.\n  function getUnderlyingToken(uint) external view override returns (address) {\n    return underlying;\n  }\n\n  // Return the conversion rate from ERC1155 to ERC20, multiplied 2**112.\n  function getUnderlyingRate(uint) external view override returns (uint) {\n    return 2**112;\n  }\n\n  // Mint ERC1155 token for the specified amount\n  // Parameter: amount is the Token amount to wrap\n  function mint(uint amount) external nonReentrant returns (uint) {\n    IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\n    IStakingRewards(staking).stake(amount);\n    uint rewardPerToken = IStakingRewards(staking).rewardPerToken();\n    _mint(msg.sender, rewardPerToken, amount, '');\n    return rewardPerToken;\n  }\n\n  // Burn ERC1155 token to redeem ERC20 token back.\n  // Parameter: id is the Token id to burn\n  // Parameter: amount is the Token amount to burn\n  function burn(uint id, uint amount) external nonReentrant returns (uint) {\n    if (amount == uint(-1)) {\n      amount = balanceOf(msg.sender, id);\n    }\n    _burn(msg.sender, id, amount);\n    IStakingRewards(staking).withdraw(amount);\n    IStakingRewards(staking).getReward();\n    IERC20(underlying).safeTransfer(msg.sender, amount);\n    uint stRewardPerToken = id;\n    uint enRewardPerToken = IStakingRewards(staking).rewardPerToken();\n    uint stReward = stRewardPerToken.mul(amount).divCeil(1e18);\n    uint enReward = enRewardPerToken.mul(amount).div(1e18);\n    if (enReward > stReward) {\n      IERC20(reward).safeTransfer(msg.sender, enReward.sub(stReward));\n    }\n    return enRewardPerToken;\n  }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract Goofballs is ERC721Enumerable, Ownable, ReentrancyGuard {\n    uint8 public constant BLOCK_SIZE = 32;\n    uint8 public constant MAX_PURCHASE = 20;\n\n    uint256 public MAX_SUPPLY;\n    uint256 public dropped;\n    bool public saleIsActive = true;\n    uint256 private _price = 0.05 ether;\n    string private _baseTokenURI;\n\n    uint16[] public _availableBlocks;\n    uint8[] public _numAvailableInBlock;\n\n    address private allowedMinter = address(0);\n    uint256 public reserved = 0;\n\n    constructor(uint256 maxSupply, uint256 initialDrop, string memory baseTokenURI) ERC721(\"Goofball\", \"GOOF\") {\n        require(maxSupply % BLOCK_SIZE == 0);\n        MAX_SUPPLY = maxSupply;\n        _baseTokenURI = baseTokenURI;\n        _drop(initialDrop);\n    }\n\n    function getNFTPrice() public view returns (uint256) {\n        return _price;\n    }\n\n    function mint(uint256 num) public payable nonReentrant {\n        uint256 supply = totalSupply();\n        require(saleIsActive, \"Sale must be active!\");\n        require(num <= MAX_PURCHASE, \"Exceeds maximum mint amount\");\n        require(supply + num + reserved <= dropped, \"Exceeds maximum supply\");\n        require(msg.value >= getNFTPrice() * num, \"Ether sent is not correct\");\n        for (uint8 i; i < num; i++) {\n            mintToken(msg.sender, i);\n        }\n    }\n\n    function mintToken(address _newOwner, uint256 num) private {\n        uint256 seed = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty, num)));\n        uint8 indexInBlock = uint8(seed % BLOCK_SIZE);\n        uint16 blockIndex = uint16((seed / BLOCK_SIZE) % _availableBlocks.length);\n        uint16 blockStart = _availableBlocks[blockIndex];\n        while (_exists(blockStart + indexInBlock + 1)) {\n            indexInBlock = (indexInBlock + 1) % BLOCK_SIZE;\n        }\n        _safeMint(_newOwner, blockStart + indexInBlock + 1);\n        if (_numAvailableInBlock[blockIndex] <= 1) {\n            uint256 lastIndex = _availableBlocks.length - 1;\n            if (blockIndex != lastIndex) {\n                _availableBlocks[blockIndex] = _availableBlocks[lastIndex];\n                _numAvailableInBlock[blockIndex] = _numAvailableInBlock[lastIndex];\n            }\n            _numAvailableInBlock.pop();\n            _availableBlocks.pop();\n        } else {\n            _numAvailableInBlock[blockIndex]--;\n        }\n    }\n\n    function _drop(uint256 num) internal {\n        require(num % BLOCK_SIZE == 0);\n        require(dropped + num <= MAX_SUPPLY);\n        uint16 lastBlock = uint16((dropped + num) / BLOCK_SIZE);\n        for (uint16 i = uint16(dropped / BLOCK_SIZE); i < lastBlock; i++) {\n            _availableBlocks.push(i * BLOCK_SIZE);\n            _numAvailableInBlock.push(BLOCK_SIZE);\n        }\n        dropped += num;\n    }\n\n    function drop(uint256 num) external onlyOwner {\n        _drop(num);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    // https://docs.opensea.io/docs/contract-level-metadata\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked(_baseURI(), \"contract\"));\n    }\n\n    function walletOfOwner(address _owner) public view returns (uint256[] memory) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        uint256[] memory tokensId = new uint256[](tokenCount);\n        for (uint256 i; i < tokenCount; i++) {\n            tokensId[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n        return tokensId;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _baseTokenURI = baseURI;\n    }\n\n    function withdrawBalance(uint256 amount) external onlyOwner {\n        if (amount == 0) {\n            amount = address(this).balance;\n        }\n        // https://consensys.github.io/smart-contract-best-practices/recommendations/#dont-use-transfer-or-send\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function giveAway(address to, uint256 num) external onlyOwner nonReentrant {\n        uint256 supply = totalSupply();\n        require(supply + num + reserved <= dropped, \"Exceeds maximum supply\");\n        for (uint256 i; i < num; i++) {\n            mintToken(to, i);\n        }\n    }\n\n    function setRestrictedMinter(address minter, uint16 reservedCount) external onlyOwner {\n        allowedMinter = minter;\n        reserved = reservedCount;\n    }\n\n    function restrictedMint(address to, uint256 num) external nonReentrant {\n        uint256 supply = totalSupply();\n        require(allowedMinter == msg.sender, \"Contract not allowed to mint\");\n        require(num <= MAX_PURCHASE, \"Exceeds maximum mint amount\");\n        require(saleIsActive, \"Sale must be active!\");\n        require(num <= reserved, \"Exceeds reserved number\");\n        require(supply + num <= dropped, \"Exceeds maximum supply\");\n        for (uint8 i; i < num; i++) {\n            mintToken(to, i);\n        }\n        reserved -= uint16(num);\n    }\n\n    function setPrice(uint256 price) external onlyOwner {\n        _price = price;\n    }\n\n    function flipSaleState() external onlyOwner {\n        saleIsActive = !saleIsActive;\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract legendary_tkn is ERC721, ERC721URIStorage, Pausable, Ownable {\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    Counters.Counter private _tokenIdCounter;\r\n    \r\n    uint256 public maxSupply = 100;\r\n    uint256 public price = 150000000000000000; // 0.15 ETH\r\n    bool public saleOpen = false;\r\n    bool public presaleOpen = false;\r\n    string public baseURI;\r\n\r\n    mapping(address => uint256) public Whitelist;\r\n\r\n    receive() external payable {}\r\n\r\n    constructor() ERC721('Legendary K-Noids', 'LTKN') {\r\n    }\r\n\r\n    function mint(uint256 amount) public payable {\r\n        require(!Address.isContract(msg.sender), \"Contracts are not allowed to mint\");\r\n        require(msg.value >= price * amount, 'Not enough was paid');\r\n\r\n        if (!saleOpen) {\r\n            require(presaleOpen == true, 'Presale is not open');\r\n            uint256 who = Whitelist[msg.sender];\r\n            require(who > 0, 'This address is not whitelisted for the presale');\r\n            require(amount <= who, 'This address is not allowed to mint that many during the presale');\r\n            for (uint256 i = 0; i < amount; i++) \r\n                internalMint(msg.sender);\r\n                Whitelist[msg.sender] = who - amount;\r\n            return;\r\n        }\r\n\r\n        require(amount <= 10, 'Only 10 per transaction allowed');\r\n        for (uint256 i = 0; i < amount; i++) internalMint(msg.sender);\r\n    }\r\n\r\n    function internalMint(address to) internal {\r\n        require(_tokenIdCounter.current() < maxSupply, 'Supply depleted');\r\n        _tokenIdCounter.increment();\r\n        _safeMint(to, _tokenIdCounter.current());\r\n    }\r\n\r\n    function whitelistAddress(address[] memory who, uint256 amount) public onlyOwner {\r\n        for (uint256 i = 0; i < who.length; i++) Whitelist[who[i]] = amount;\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        payable(owner()).transfer(balance);\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function toggleSale() public onlyOwner {\r\n        saleOpen = !saleOpen;\r\n    }\r\n\r\n    function togglePresale() public onlyOwner {\r\n        presaleOpen = !presaleOpen;\r\n    }\r\n\r\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\r\n        baseURI = newBaseURI;\r\n    }\r\n\r\n    function setPrice(uint256 newPrice) public onlyOwner {\r\n        price = newPrice;\r\n    }\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    // The following functions are overrides required by Solidity.\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal override(ERC721) whenNotPaused {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\r\n        super._burn(tokenId);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\r\n        return super.tokenURI(tokenId);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721) returns (bool) {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract FloydiesGenerative is ERC721, ERC721Enumerable, Pausable, Ownable, RoyaltiesV2Impl{\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n    constructor() ERC721(\"Floydies - Generative\", \"FLGEN\") {}\n\n    function _baseURI() internal pure override returns (string memory) {\n        return \"ipfs://QmSYuxsBNdRk9ssiRomyNADw6pfdn4a6dXLCyN3Mhsx2P1/\";\n    }\n\n    function mint(uint256 numberOfTokens) public payable {\n        uint256 supply = totalSupply();\n        uint256 tokencount = supply;\n        require(numberOfTokens < 11, \"You can mint a maximum of 10\" );\n        require((supply + numberOfTokens) < 5000, \"Your order exceeds the maximum supply of 5,000 Floydies!\");\n        require( msg.value >= 0.006 ether * numberOfTokens, \"Not enough ETH paid, make sure to pay 0.006\" );\n        LibPart.Part[] memory _royalties = new LibPart.Part[](1);\n        _royalties[0].value = 1000;\n        _royalties[0].account =  payable(0x6088E23001ADEB5219Cf396bf7A7344211d1b21A);\n        for(uint256 i; i < numberOfTokens; i++){\n            _saveRoyalties(tokencount + i, _royalties);\n            _safeMint( msg.sender, supply + i );\n        \n        }   \n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        whenNotPaused\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n      function withdraw(address payable recipient) public onlyOwner {\n        uint256 balance = address(this).balance;\n        recipient.transfer(balance);\n      }\n    // The following functions are overrides required by Solidity.\n\n    // Royalties functions\n\n    function setRoyalties(uint _tokenId, address payable _royaltiesReceipientAddress, uint96 _percentageBasisPoints) public onlyOwner {\n        LibPart.Part[] memory _royalties = new LibPart.Part[](1);\n        _royalties[0].value = _percentageBasisPoints;\n        _royalties[0].account = _royaltiesReceipientAddress;\n        _saveRoyalties(_tokenId, _royalties);\n    }\n\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n        if(interfaceId == LibRoyaltiesV2._INTERFACE_ID_ROYALTIES) {\n            return true;\n        }\n        if(interfaceId == _INTERFACE_ID_ERC2981) {\n            return true;\n        }\n        return super.supportsInterface(interfaceId);\n    } \n\n     function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount) {\n        LibPart.Part[] memory _royalties = royalties[_tokenId];\n        if(_royalties.length > 0) {\n            return (_royalties[0].account, (_salePrice * _royalties[0].value)/10000);\n        }\n        return (address(0), 0);\n\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract LobsterBeachClub is VRFConsumerBase, ERC721, ERC721Enumerable, ERC721URIStorage, Ownable {\n\n    uint256 public maxSupply; // needed public for LobsterGenome\n    uint256 public seedNumber; // needed public for LobsterGenome\n    \n    string internal baseURI;\n\n    bytes32 internal keyHash;\n    uint256 internal linkFee;\n\n    uint16 internal maxPurchase;\n    uint256 internal mintingFee;\n\n    uint256 internal maxPresaleSupply;\n    uint256 internal revealDate;\n    uint256 internal presaleStartingSupply;\n\n    bool internal saleIsActive;\n    bool internal presaleIsActive;\n    bool internal seedNumberRequested;\n    bool internal seedNumberSet;\n\n    mapping(uint256 => uint256) internal promoLobster;\n    mapping(address => bool) internal isWhitelisted;\n\n    event SeedRequested(bool _value);\n    event SeedSet(bool _value, uint256 _seedNumber);\n    event PresaleState(bool _value, uint256 _startingSupply);\n    event SaleState(bool _value);\n    event Whitelist(address indexed _address, bool _value);\n    event Minted(uint256 _value);\n    event RevealTime(uint256 _time);\n    event MintFee(uint256 _value);\n\n    // External contract to fetch lobster genes from ILobsterGenome public lobsterGenome;\n    constructor(string memory name, string memory symbol, uint256 maxNftSupply, uint256 saleStart) ERC721(name, symbol) ERC721Enumerable() VRFConsumerBase(\n            0xf0d54349aDdcf704F77AE15b96510dEA15cb7952, // VRF Coordinator\n            0x514910771AF9Ca656af840dff83E8264EcF986CA  // LINK Token\n        )\n    {\n        mintingFee = 0.085 * 10 ** 18;\n        keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\n        linkFee = 2 * 10 ** 18; // 2 LINK required to call VRF\n        baseURI = \"https://pegnc1ml7b.execute-api.us-west-1.amazonaws.com/api/lobsters/\";\n        maxSupply = maxNftSupply;\n        maxPresaleSupply = 1500;\n        maxPurchase = 20;\n        revealDate = saleStart + (86400 * 9); // 9 days from start\n        emit RevealTime(revealDate);\n        emit MintFee(mintingFee);\n    }\n\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked(baseURI, \"metadata\"));\n    }\n\n    function setLobsterGenome(address lgAddress) public onlyOwner {\n        lobsterGenome = ILobsterGenome(lgAddress);\n    }\n\n    \n    // Set the minting fee\n    function setMintingFee(uint256 _mintingFee) public onlyOwner {\n        mintingFee = _mintingFee;\n        emit MintFee(mintingFee);\n    }\n\n    \n    // Start state of presale or sale\n    function setSaleState(bool _presale, bool _val) public onlyOwner {\n        if (_presale) {\n            presaleIsActive = _val;\n            if (_val) {\n                presaleStartingSupply = totalSupply();\n            }\n            emit PresaleState(_val, presaleStartingSupply);\n        } else {\n            saleIsActive = _val;\n            emit SaleState(_val);\n        }\n    }\n\n    \n    // Add or remove addresses from presale whitelist\n    function whitelist(address[] memory addresses, bool _val) public onlyOwner {\n        for (uint i; i < addresses.length; i++) {\n            isWhitelisted[addresses[i]] = _val;\n            emit Whitelist(addresses[i], _val);\n        }\n    }\n\n    \n    // Reserve some lobsters for these addresses\n    function reserveLobsters(address[] memory addresses) public onlyOwner {\n        for(uint i; i < addresses.length; i++) {\n            uint256 lobsterId = totalSupply();\n            _mint(addresses[i], lobsterId);\n            _setTokenURI(lobsterId, uint2str(lobsterId));\n        }\n        emit Minted(totalSupply());\n    }\n\n    \n    // Create promo lobsters for these addresses\n    // Promo lobsters are lobsters with predefined geneSequences\n    // Promo lobsters are non-transferrable so they're kept track of in a mapping\n    function createPromoLobsters(uint256[] memory geneSequences, address[] memory addresses) public onlyOwner {\n        require(geneSequences.length == addresses.length, \"Argument lengths must be equal\");\n        for(uint i = 0; i < geneSequences.length; i++) {\n            uint256 lobsterId = totalSupply();\n            _mint(addresses[i], lobsterId);\n            _setTokenURI(lobsterId, uint2str(lobsterId));\n            promoLobster[lobsterId] = geneSequences[i];\n        }\n        emit Minted(totalSupply());\n    }\n\n    \n    // Mint lobsters to an address\n    // Presale must be active or sale must be active to mint\n    // To mint during presale the msg.sender must be whitelisted and can't exceed presaleStartSupply + maxPresaleSupply\n    // To mint you must provide minting fee for each token requested and cannot exceed max token supply\n    // If minting after reveal date or minting last available supply, submit request from Chainlink VRF\n    // If maxSupply reached then sale is no longer active\n    // If presaleStartingSupply + maxPresaleSupply is reached then presale is no longer active\n    function mint(uint256 numberOfTokens, address _to) public payable {\n        require(numberOfTokens <= maxPurchase, \"Exceeded the max purchase amount\");\n        if (presaleIsActive) {\n            require(isWhitelisted[msg.sender], \"Not whitelisted\");\n            require(totalSupply() + numberOfTokens <= presaleStartingSupply + maxPresaleSupply, \"Exceeded max presale supply\");\n        } else {\n            require(saleIsActive, \"Sale must be active\");\n        }\n        require(mintingFee * numberOfTokens <= msg.value, \"Mint fee is not correct\");\n        require(totalSupply() + numberOfTokens <= maxSupply, \"Purchase would exceed max supply\");\n\n        for(uint i = 0; i < numberOfTokens; i++) {\n            uint256 lobsterId = totalSupply();\n            _mint(_to, lobsterId);\n            _setTokenURI(lobsterId, uint2str(lobsterId));\n        }\n        emit Minted(totalSupply());\n\n        if (!seedNumberRequested && (totalSupply() >= maxSupply || block.timestamp >= revealDate)) {\n            getRandomNumber();\n        }\n\n        if (totalSupply() >= maxSupply) {\n            saleIsActive = false;\n            setSaleState(false, false);\n        } else if (presaleIsActive && (totalSupply() >= (presaleStartingSupply + maxPresaleSupply))) {\n            presaleIsActive = false;\n            setSaleState(true, false);\n        }\n    }\n\n    \n    // Gives contract owner ability to manually request seed number from Chainlink VRF\n    function emergencySetSeedNumber() public onlyOwner {\n        getRandomNumber();\n    }\n\n    function setRevealTimestamp(uint256 revealTimeStamp) public onlyOwner {\n        revealDate = revealTimeStamp;\n        emit RevealTime(revealDate);\n    } \n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _baseURI) public onlyOwner {\n        baseURI = _baseURI;\n    }\n\n    \n    // Get the gene sequence of a lobster if seedNumberSet / lobsters are revealed\n    // If lobster is a promo, then return preset gene sequence\n    // Gene sequencing logic is outsourced to external LobsterGenome contract\n    function getLobster(uint256 tokenId) public view returns (uint256 geneSequence) {\n        require(seedNumberSet, \"Seed number is not set\");\n        require(_exists(tokenId), \"Token id does not exist\");\n        if (promoLobster[tokenId] != 0) {\n            return promoLobster[tokenId];\n        }\n        return lobsterGenome.getGeneSequence(tokenId);\n    }\n\n    \n    // Callback function for Chainlink VRF\n    // Randomness is set as the seedNumber, revealing all Lobsters\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        seedNumber = randomness;\n        seedNumberSet = true;\n        emit SeedSet(true, seedNumber);\n    }\n\n    \n    // Request a random number from Chainlink VRF\n    function getRandomNumber() internal {\n        require(LINK.balanceOf(address(this)) > linkFee && !seedNumberSet, \"Not enough LINK or seed set already\");\n        requestRandomness(keyHash, linkFee);\n        seedNumberRequested = true;\n        emit SeedRequested(true);\n    }\n\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n    \n    function withdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function withdrawLink() external onlyOwner {\n        LINK.transfer(msg.sender, LINK.balanceOf(address(this)));\n    }\n    \n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        require(promoLobster[tokenId] == 0, \"Token id is non-transferrable\");\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n    \n    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n        return super._burn(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override(ERC721, ERC721URIStorage) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n    \n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract V1Phunks is ERC721, Ownable {\n    using Counters for Counters.Counter;\n    using SafeMath for uint256;\n\n    Counters.Counter private _tokenIds;\n    uint256 public constant MAX_SUPPLY = 10000; //10.000 V1 Phunks\n    uint256 public constant MAX_PER_MINT = 10;\n    uint256 private constant MAX_RESERVED_MINTS = 500;\n\n    uint256 public FREE_STAGE_MINTING= 250;\n\n    uint256 private FREE_STAGE_PRICE= 0 ether;\n\n    uint256 public PUBLIC_PRICE= 0.015 ether;\n\n    uint256 private RESERVED_MINTS = 0;\n    \n\n    bool public paused = false;\n    \n    string public baseTokenURI = \"ipfs://QmYxKmX5SXfGxwgrrfNvxxEXdbxaTQn9yy3JQx15p5cwgo/\";\n\n    constructor() ERC721(\"V1 Phunks\", \"V1PHNK\") {\n        setBaseURI(baseTokenURI);\n        _mintSingleNFT();\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n       return baseTokenURI;\n    }\n    \n    function setBaseURI(string memory _baseTokenURI) public onlyOwner {\n        baseTokenURI = _baseTokenURI;\n    }\n\n    function mintNFTs(uint _number) public payable {\n        uint256 totalMinted = _tokenIds.current();\n        require(!paused, \"Sale Paused\") ;\n        require(totalMinted.add(_number) <= MAX_SUPPLY - MAX_RESERVED_MINTS, \"Not enough V1 Phunks remaining!\");\n        require(_number > 0 && _number <= MAX_PER_MINT, \"Cannot mint specified number of V1 Phunks.\");\n        require(msg.value >= Price() * _number, \"Not enough ether to purchase V1 Phunks.\");\n        \n        for (uint i = 0; i < _number; i++) {\n            _mintSingleNFT();\n        }\n    }\n\n    function _mintSingleNFT() private {\n      uint newTokenID = _tokenIds.current();\n      _safeMint(msg.sender, newTokenID);\n      _tokenIds.increment();\n    }\n    \n    //in case ETH price gets too high; expressed in ETH x 10^18\n    function setPrice(uint256 _price) external onlyOwner {\n        PUBLIC_PRICE = _price;\n    }\n\n   function Price() private view returns(uint256) {\n        uint256 totalMinted = _tokenIds.current();\n        if ( totalMinted < FREE_STAGE_MINTING) {\n            return FREE_STAGE_PRICE;\n        } else {\n            return PUBLIC_PRICE;\n        }\n    }\n    \n    function setFreeMints(uint256 freeStageNum) external onlyOwner {\n        FREE_STAGE_MINTING = freeStageNum;\n    }\n\n     function reserveNFTs(uint256 _number) public onlyOwner {\n        uint256 totalMinted = _tokenIds.current();\n        require((totalMinted.add(_number)) <= MAX_SUPPLY, \"Exceeds V1 Phunks supply\");\n        require(RESERVED_MINTS + _number <= MAX_RESERVED_MINTS, \"Exceeds reserved V1 Phunks supply\");\n        \n        for (uint256 i = 0; i < _number; i++) {\n            _mintSingleNFT();\n        }\n        RESERVED_MINTS = RESERVED_MINTS + _number;\n\n    }\n\n    //Withdraw money in contract to Owner\n    function withdraw() public payable onlyOwner {\n     uint256 balance = address(this).balance;\n     require(balance > 0, \"No ether left to withdraw\");\n\n     (bool success, ) = (msg.sender).call{value: balance}(\"\");\n\n     require(success, \"Transfer failed.\");\n    }\n\n    function giveAway(address _to, uint256 _amount) external onlyOwner() {\n        require( _amount + RESERVED_MINTS <= MAX_RESERVED_MINTS, \"Exceeds reserved V1 Phunk supply\" );\n        uint newTokenID = _tokenIds.current();\n        for(uint256 i; i < _amount; i++){\n            _safeMint(_to, newTokenID);\n            _tokenIds.increment();\n        }\n\n        RESERVED_MINTS += _amount;\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    function totalSupply() external view returns(uint256) {\n        return _tokenIds.current() ;\n    }\n\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract OKEXTOKEN {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 4;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    \n    // Constructor function. Initializes contract with initial supply tokens to the creator of the contract\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = 90000000000;  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name =\"EXTOKEN\";                                   // Set the name for display purposes\n        symbol = \"0KB\";                               // Set the symbol for display purposes\n    }\n\n    \n    // Internal transfer, only can be called by this contract\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    \n     // Transfer tokens\n     // Send `_value` tokens to `_to` from your account\n     // Parameter: _to is The address of the recipient\n     // Parameter: _value is the amount to send\n     \n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    \n     // Transfer tokens from other address\n     // Send `_value` tokens to `_to` on behalf of `_from`\n     // Parameter: _from is The address of the sender\n     // Parameter: _to is The address of the recipient\n     // Parameter: _value is the amount to send\n     \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    \n     // Set allowance for other address\n     // Allows `_spender` to spend no more than `_value` tokens on your behalf\n     // Parameter: _spender is The address authorized to spend\n     // Parameter: _value is the max amount they can spend\n     \n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    \n     // Set allowance for other address and notify. \n     // Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     // Parameter: _spender The address authorized to spend\n     // Parameter: _value the max amount they can spend\n     // Parameter: _extraData some extra information to send to the approved contract\n     \n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    \n     // Destroy tokens\n     // Remove `_value` tokens from the system irreversibly\n     // Parameter: _value is the amount of money to burn\n     \n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    \n     // Destroy tokens from other account\n     // Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     // Parameter: _from is the address of the sender\n     // Parameter: _value is the amount of money to burn\n     \n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract AshesOfLight is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n\n    string public baseURI;\n    string public notRevealedUri;\n    uint256 public cost = 0.08 ether;\n    uint256 public maxSupply = 10000;\n    uint256 public maxMintAmount = 20;\n    uint256 public nftPerAddressLimit = 1;\n    uint256 public rewardAmountTotal = 50;\n    uint256 public rewardsMinted = 0;\n    bool public paused = true;\n    bool public revealed = true;\n    bool public onlyWhitelisted = true;\n    address[] public whitelistedAddresses;\n    address[] public rewardAddresses;\n    mapping(address => uint256) public addressMintedBalance;\n    address public ms;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _initBaseURI,\n        string memory _initNotRevealedUri,\n        address _msAddress\n    ) ERC721(_name, _symbol) {\n        setBaseURI(_initBaseURI);\n        setNotRevealedURI(_initNotRevealedUri);\n        setMS(_msAddress);\n    }\n\n    // internal\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    // public\n    function mint(uint256 _mintAmount) public payable {\n        require(!paused, \"the contract is paused\");\n        uint256 supply = totalSupply();\n        require(_mintAmount > 0, \"need to mint at least 1 NFT\");\n        require(_mintAmount <= maxMintAmount, \"max mint amount per session exceeded\");\n        require(supply + _mintAmount <= maxSupply - rewardAmountTotal, \"max NFT limit exceeded\");\n\n        if (msg.sender != owner()) {\n            if(onlyWhitelisted == true) {\n                require(isWhitelisted(msg.sender), \"user is not whitelisted\");\n            }\n            require(msg.value >= cost * _mintAmount, \"insufficient funds\");\n        \n            for (uint256 i = 1; i <= _mintAmount; i++) {\n                addressMintedBalance[msg.sender]++;\n                _safeMint(msg.sender, supply + i);\n            }\n        }\n        if (msg.sender == owner()) {\n            for (uint256 i = 1; i <= _mintAmount; i++) {\n                addressMintedBalance[msg.sender]++;\n                _safeMint(msg.sender, supply + i);\n            }\n        }\n    }\n  \n    function claimReward() public payable {\n        uint256 rewardAmount = 1;\n        require(!paused, \"the contract is paused\");\n        require(\n            hasReward(msg.sender),\n            \"No rewards to claim for your account\"\n        );\n        uint256 supply = totalSupply();\n        require(supply + rewardAmount <= maxSupply - rewardAmountTotal, \"max NFT limit exceeded\");\n\n        uint256 ownerMintedCount = addressMintedBalance[msg.sender];\n        require(\n            ownerMintedCount + rewardAmount <= nftPerAddressLimit,\n            \"max NFT per address exceeded\"\n        );\n        for (uint256 i = 1; i <= rewardAmount; i++) {\n            addressMintedBalance[msg.sender]++;\n            rewardsMinted++;\n            rewardAmountTotal--;\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n  \n    function mintTo(address _to, uint256 _mintAmount) public payable onlyOwner {\n        uint256 supply = totalSupply();\n        require(_mintAmount > 0);\n        require(_mintAmount <= maxMintAmount);\n        require(supply + _mintAmount <= maxSupply - rewardAmountTotal);\n    \n        for (uint256 i = 1; i <= _mintAmount; i++) {\n            _safeMint(_to, supply + i);\n        }\n    }\n  \n    function isWhitelisted(address _user) public view returns (bool) {\n        for (uint i = 0; i < whitelistedAddresses.length; i++) {\n            if (whitelistedAddresses[i] == _user) {\n                return true;\n            }\n        }\n        return false;\n    }\n  \n    function hasReward(address _user) public view returns (bool) {\n        for (uint256 i = 0; i < rewardAddresses.length; i++) {\n            if (rewardAddresses[i] == _user) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function walletOfOwner(address _owner) public view returns (uint256[] memory) {\n        uint256 ownerTokenCount = balanceOf(_owner);\n        uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n        for (uint256 i; i < ownerTokenCount; i++) {\n        tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n        return tokenIds;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n    \n        if(revealed == false) {\n            return notRevealedUri;\n        }\n\n        string memory currentBaseURI = _baseURI();\n        return bytes(currentBaseURI).length > 0 ? string(abi.encodePacked(currentBaseURI, tokenId.toString())) : \"\";\n    }\n\n    //only owner\n    function reveal() public onlyOwner {\n        revealed = true;\n    }\n  \n    function setNftPerAddressLimit(uint256 _limit) public onlyOwner {\n        nftPerAddressLimit = _limit;\n    }\n  \n    function setCost(uint256 _newCost) public onlyOwner {\n        cost = _newCost;\n    }\n\n    function setMS(address _newMS) public onlyOwner {\n        ms = _newMS;\n    }\n\n    function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {\n        maxMintAmount = _newmaxMintAmount;\n    }\n\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {\n        notRevealedUri = _notRevealedURI;\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n    \n    function setOnlyWhitelisted(bool _state) public onlyOwner {\n        onlyWhitelisted = _state;\n    }\n    \n    function whitelistUsers(address[] calldata _users) public onlyOwner {\n        delete whitelistedAddresses;\n        whitelistedAddresses = _users;\n    }\n    \n    function rewardUsers(address[] calldata _users) public onlyOwner {\n            delete rewardAddresses;\n            rewardAddresses = _users;\n        }\n    \n    function withdraw() public payable onlyOwner {\n        \n        (bool hs, ) = payable(ms).call{value: address(this).balance * 10 / 100}(\"\");\n        require(hs);\n\n        (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(os);\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract lukasTigers is ERC721Enumerable, Ownable {\r\n  using Strings for uint256;\r\n\r\n  string public baseURI;\r\n  string public baseExtension = \".json\";\r\n  uint256 public cost = 0.06 ether;\r\n  uint256 public maxSupply = 10000;\r\n  uint256 public maxMintAmount = 20;\r\n  bool public paused = false;\r\n  mapping(address => bool) public whitelisted;\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    string memory _initBaseURI\r\n  ) ERC721(_name, _symbol) {\r\n    setBaseURI(_initBaseURI);\r\n    mint(msg.sender, 20);\r\n  }\r\n\r\n  // internal\r\n  function _baseURI() internal view virtual override returns (string memory) {\r\n    return baseURI;\r\n  }\r\n\r\n  // public\r\n  function mint(address _to, uint256 _mintAmount) public payable {\r\n    uint256 supply = totalSupply();\r\n    require(!paused);\r\n    require(_mintAmount > 0);\r\n    require(_mintAmount <= maxMintAmount);\r\n    require(supply + _mintAmount <= maxSupply);\r\n\r\n    if (msg.sender != owner()) {\r\n        if(whitelisted[msg.sender] != true) {\r\n          require(msg.value >= cost * _mintAmount);\r\n        }\r\n    }\r\n\r\n    for (uint256 i = 1; i <= _mintAmount; i++) {\r\n      _safeMint(_to, supply + i);\r\n    }\r\n  }\r\n\r\n  function walletOfOwner(address _owner)\r\n    public\r\n    view\r\n    returns (uint256[] memory)\r\n  {\r\n    uint256 ownerTokenCount = balanceOf(_owner);\r\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\r\n    for (uint256 i; i < ownerTokenCount; i++) {\r\n      tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\r\n    }\r\n    return tokenIds;\r\n  }\r\n\r\n  function tokenURI(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (string memory)\r\n  {\r\n    require(\r\n      _exists(tokenId),\r\n      \"ERC721Metadata: URI query for nonexistent token\"\r\n    );\r\n\r\n    string memory currentBaseURI = _baseURI();\r\n    return bytes(currentBaseURI).length > 0\r\n        ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\r\n        : \"\";\r\n  }\r\n\r\n  //only owner\r\n  function setCost(uint256 _newCost) public onlyOwner() {\r\n    cost = _newCost;\r\n  }\r\n\r\n  function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner() {\r\n    maxMintAmount = _newmaxMintAmount;\r\n  }\r\n\r\n  function setBaseURI(string memory _newBaseURI) public onlyOwner {\r\n    baseURI = _newBaseURI;\r\n  }\r\n\r\n  function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\r\n    baseExtension = _newBaseExtension;\r\n  }\r\n\r\n  function pause(bool _state) public onlyOwner {\r\n    paused = _state;\r\n  }\r\n \r\n function whitelistUser(address _user) public onlyOwner {\r\n    whitelisted[_user] = true;\r\n  }\r\n \r\n  function removeWhitelistUser(address _user) public onlyOwner {\r\n    whitelisted[_user] = false;\r\n  }\r\n\r\n  function withdraw() public payable onlyOwner {\r\n    require(payable(msg.sender).send(address(this).balance));\r\n  }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract RADIUM {\n    // Public variables of the token\n    string public name = \"Radium\";\n    string public symbol = \"RADM\";\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default\n    uint256 public totalSupply;\n    uint256 public RadiumSupply = 200000000000;\n    uint256 public buyPrice = 20000000;\n    address public creator;\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event FundTransfer(address backer, uint amount, bool isContribution);\n    \n    // Constrctor function\n    // Initializes contract with initial supply tokens to the creator of the contract\n    function RADIUM() public {\n        totalSupply = RadiumSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;    // Give RadiumCoin Mint the total created tokens\n        creator = msg.sender;\n    }\n\n    // Internal transfer, only can be called by this contract\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n    }\n\n    // Transfer tokens. Send `_value` tokens to `_to` from your account\n    // Parameter: _to is The address of the recipient\n    // Parameter: _value is the amount to send\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /// Buy tokens from contract by sending ether\n    function () payable internal {\n        uint amount = msg.value * buyPrice;                    // calculates the amount, made it so you can get many BOIS but to get MANY BOIS you have to spend ETH and not WEI\n        uint amountRaised;                                     \n        amountRaised += msg.value;                            //many thanks bois, couldnt do it without r/me_irl\n        require(balanceOf[creator] >= amount);               // checks if it has enough to sell\n        require(msg.value <= 10**17);                        // so any person who wants to put more then 0.1 ETH has time to think about what they are doing\n        balanceOf[msg.sender] += amount;                  // adds the amount to buyer's balance\n        balanceOf[creator] -= amount;                        // sends ETH to RadiumCoinMint\n        Transfer(creator, msg.sender, amount);               // execute an event reflecting the change\n        creator.transfer(amountRaised);\n    }\n\n }"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract ERC223Token_STA is ERC223, SafeMath, Ownable {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    mapping(address => uint) balances;\n    \n    // stable params:\n    uint256 public icoEndBlock;                              // last block number of ICO \n    uint256 public maxSupply;                                // maximum token supply\n    uint256 public minedTokenCount;                          // counter of mined tokens\n    address public icoAddress;                               // address of ICO contract    \n    uint256 private multiplier;                              // for managing token fractionals\n    struct Miner {                                           // struct for mined tokens data\n        uint256 block;\n        address minerAddress;\n    }\n    mapping (uint256 => Miner) public minedTokens;           // mined tokens data\n    event MessageClaimMiningReward(address indexed miner, uint256 block, uint256 sta);  // notifies clients about sta winning miner\n    event Burn(address indexed from, uint256 value);         // notifies clients about the amount burnt\n    \n    function ERC223Token_STA() {\n        decimals = 8;\n        multiplier = 10**uint256(decimals);\n        maxSupply = 10000000000;                             // Maximum possible supply == 100 STA\n        name = \"STABLE STA Token\";                           // Set the name for display purposes\n        symbol = \"STA\";                                      // Set the symbol for display purposes\n        icoEndBlock = 4332000;  // INIT                      // last block number for ICO\n        totalSupply = 0;                                     // Update total supply\n        // balances[msg.sender] = totalSupply;               // Give the creator all initial tokens\n    }\n \n    // trigger rewarding a miner with STA token:\n    function claimMiningReward() {  \n        if (icoAddress == address(0)) throw;                         // ICO address must be set up first\n        if (msg.sender != icoAddress && msg.sender != owner) throw;  // triggering enabled only for ICO or owner\n        if (block.number > icoEndBlock) throw;                       // rewarding enabled only before the end of ICO\n        if (minedTokenCount * multiplier >= maxSupply) throw; \n        if (minedTokenCount > 0) {\n            for (uint256 i = 0; i < minedTokenCount; i++) {\n                if (minedTokens[i].block == block.number) throw; \n            }\n        }\n        totalSupply += 1 * multiplier;\n        balances[block.coinbase] += 1 * multiplier;                  // reward miner with one STA token\n        minedTokens[minedTokenCount] = Miner(block.number, block.coinbase);\n        minedTokenCount += 1;\n        MessageClaimMiningReward(block.coinbase, block.number, 1 * multiplier);\n    } \n    \n    function selfDestroy() onlyOwner {\n        // allow to suicide STA token after around 2 weeks (25s/block) from the end of ICO\n        if (block.number <= icoEndBlock+14*3456) throw;\n        suicide(this); \n    }\n    // /stable params\n   \n    // Function to access name of token .\n    function name() constant returns (string _name) {\n        return name;\n    }\n    // Function to access symbol of token .\n    function symbol() constant returns (string _symbol) {\n        return symbol;\n    }\n    // Function to access decimals of token .\n    function decimals() constant returns (uint8 _decimals) {\n        return decimals;\n    }\n    // Function to access total supply of tokens .\n    function totalSupply() constant returns (uint256 _totalSupply) {\n        return totalSupply;\n    }\n    function minedTokenCount() constant returns (uint256 _minedTokenCount) {\n        return minedTokenCount;\n    }\n    function icoAddress() constant returns (address _icoAddress) {\n        return icoAddress;\n    }\n\n    // Function that is called when a user or another contract wants to transfer funds .\n    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n        if (isContract(_to)) {\n            transferToContract(_to, _value, _data);\n        } else {\n            transferToAddress(_to, _value, _data);\n        }\n        return true;\n    }\n  \n    // Standard function transfer similar to ERC20 transfer with no _data .\n    // Added due to backwards compatibility reasons .\n    function transfer(address _to, uint _value) returns (bool success) {\n        bytes memory empty;\n        if (isContract(_to)) {\n            transferToContract(_to, _value, empty);\n        } else {\n            transferToAddress(_to, _value, empty);\n        }\n        return true;\n    }\n\n    // assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n    function isContract(address _addr) private returns (bool is_contract) {\n        uint length;\n        _addr = _addr;  // workaround for Mist's inability to compile\n        is_contract = is_contract;  // workaround for Mist's inability to compile\n        assembly {\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n        }\n        if (length>0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // function that is called when transaction target is an address\n    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n        if (balanceOf(msg.sender) < _value) throw;\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n        balances[_to] = safeAdd(balanceOf(_to), _value);\n        Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n  \n    // function that is called when transaction target is a contract\n    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n        if (balanceOf(msg.sender) < _value) throw;\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n        balances[_to] = safeAdd(balanceOf(_to), _value);\n        ContractReceiver receiver = ContractReceiver(_to);\n        receiver.tokenFallback(msg.sender, _value, _data);\n        Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint balance) {\n        return balances[_owner];\n    }\n\t\n    function burn(address _address, uint256 _value) returns (bool success) {\n        if (icoAddress == address(0)) throw;\n        if (msg.sender != owner && msg.sender != icoAddress) throw; // only owner and ico contract are allowed\n        if (balances[_address] < _value) throw;                     // Check if the sender has enough tokens\n        balances[_address] -= _value;                               // Subtract from the sender\n        totalSupply -= _value;                               \n        Burn(_address, _value);\n        return true;\n    }\n\t\n    // setting ICO address for allowing execution from the ICO contract\n    function setIcoAddress(address _address) onlyOwner {\n        if (icoAddress == address(0)) {\n            icoAddress = _address;\n        } else {\n            throw;\n        }\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract NOSToken is IERC20, Ownable {\n    using SafeMath for uint;\n\n    struct FeeConfig {\n        uint16 fee; //percentage expressed as number between 0 and 1000\n        address destination;\n    }\n\n    FeeConfig config;\n    uint256 _totalSupply;\n\n    IUniswapV2Factory public factory;\n    IUniswapV2Router02 public router;\n\n    address public tokenUniswapPair;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowances;\n\n    string public name = \"NOS nitrous.finance\";\n    string public symbol = \"NOS\";\n\n    constructor(uint16 fee, address destination, address _router, address _factory) {\n        _totalSupply = 964910 * 1e18;\n        balances[msg.sender] = _totalSupply;\n        config.fee = fee;\n        config.destination = destination;\n        router = IUniswapV2Router02(_router);\n        factory = IUniswapV2Factory(_factory);\n    }\n\n    function fee() external view returns (uint16) {\n        return config.fee;\n    }\n\n    function decimals() external view returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() external override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account)\n        external\n        override\n        view\n        returns (uint256)\n    {\n        return balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        external\n        override\n        view\n        returns (uint256)\n    {\n        return allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            allowances[sender][msg.sender].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function createUniswapPair() public onlyOwner returns (address) {\n        require(tokenUniswapPair == address(0), \"Token: pool already created\");\n        tokenUniswapPair = factory.createPair(\n            address(router.WETH()),\n            address(this)\n        );\n        return tokenUniswapPair;\n    }\n\n    function configureFeeDestination(address destination) public onlyOwner {\n        config.destination = destination;\n    }\n\n    /*\n        1% = 10\n        10% = 100\n    */\n    function configureFee(uint16 _fee) public onlyOwner {\n        require(config.fee == 0, \"NOS: fee already set\");\n        require(_fee <= 1000, \"NOS: max fee reached\");\n        config.fee = _fee;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        uint fee;\n\n        if (config.destination != address(0)) {\n            fee = (config.fee * amount).div(1000);\n            balances[config.destination] = balances[config.destination] + fee;\n\n            if (fee != 0) {\n                emit Transfer(sender, config.destination, fee);\n            }\n        }\n\n        balances[recipient] = balances[recipient].add(amount - fee);\n        balances[sender] = balances[sender].sub(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract CryptoMomentsNextToken is ERC721, ERC721URIStorage, ERC721Enumerable, Ownable, Pausable, PaymentSplitter, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    uint256 private constant _PUBLIC_TOKENS = 100; \n    uint256 private constant _FREE_TOKENS = 70; \n\n    uint256 public constant TOKEN_LIMIT = _PUBLIC_TOKENS + _FREE_TOKENS; \n\n    uint256 private _tokenPrice;\n    uint256 private _maxTokensAtOnce = 5;\n\n    bool public publicSale = false;\n    bool public privateSale = true;\n\n\n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n\n    \n\n    mapping(address => bool) private _privateSaleAddresses;\n    uint256[] private _shares = [45,45,10];\n    address[] private _payees = [0xd903a646805873D9d86233E6746a7880796fBf08,0x96816B7F0623C92CA22B9288f08f8a84149C4210, 0x295fAC863B0Ad3dE1BeCCd40856D8fee180986d1];\n\n    address _previuosMomentsContractAddress = 0x0Edf9F38fe1bf9eB1322C5560bD5b5eb23C0056e;\n    mapping(address => bool) private _bonusAlreadyClaimed;\n\n    constructor()\n        PaymentSplitter(_payees, _shares)\n        ERC721(\"Crypto Moments - BTC Genesis\", unicode\"₿\")\n    {\n        setTokenPrice(100000000000000000);\n\n        _privateSaleAddresses[msg.sender] = true;\n\n    }\n\n\n    // Required overrides from parent contracts\n    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n        super._burn(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override(ERC721, ERC721URIStorage) returns (string memory) {\n        return string(abi.encodePacked(super.tokenURI(tokenId), \"\"));\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n\n    // _tokenPrice\n    function getTokenPrice() public view returns(uint256) {\n        return _tokenPrice;\n    }\n\n    function setTokenPrice(uint256 _price) public onlyOwner {\n        _tokenPrice = _price;\n    }\n\n    // _paused\n    function togglePaused() public onlyOwner {\n        if (paused()) {\n        _unpause();\n        } else {\n        _pause();\n        }\n    }\n\n\n    // _maxTokensAtOnce\n    function getMaxTokensAtOnce() public view returns (uint256) {\n        return _maxTokensAtOnce;\n    }\n\n    function setMaxTokensAtOnce(uint256 _count) public onlyOwner {\n        _maxTokensAtOnce = _count;\n    }\n\n\n    // Team and Public sales\n    function enablePublicSale() public onlyOwner {\n        publicSale = true;\n    }\n\n    function disablePublicSale() public onlyOwner {\n        publicSale = false;\n    }\n\n    function disablePrivateSale() public onlyOwner {\n        privateSale = false;\n    }\n\n    function setPreviousMomentsContractAddress(address _contractAddress) public onlyOwner {\n        _previuosMomentsContractAddress = _contractAddress;\n    }\n\n    // Token URIs\n    function _baseURI() internal override pure returns (string memory) {\n        return \"ipfs://Qma7x4XeJk54WuNuY2kZYYCe47epEAZBr43VoodAyPgmef/\";\n    }\n\n    // Pick a random index\n    function randomIndex() internal returns (uint256) {\n        uint256 totalSize = TOKEN_LIMIT - totalSupply();\n        uint256 index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint256 value = 0;\n\n        if (indices[index] != 0) {\n        value = indices[index];\n        } else {\n        value = index;\n        }\n\n        if (indices[totalSize - 1] == 0) {\n        indices[index] = totalSize - 1;\n        } else {\n        indices[index] = indices[totalSize - 1];\n        }\n\n        nonce++;\n\n        return value.add(1);\n    }\n\n\n    // Minting single or multiple tokens\n    function _mintWithRandomTokenId(address _to) private {\n        uint _tokenID = randomIndex();\n        _safeMint(_to, _tokenID);\n    }\n\n    function mintMultipleTokens(uint256 _amount) public payable nonReentrant whenNotPaused {\n        require(totalSupply().add(_amount) <= _PUBLIC_TOKENS, \"Purchase would exceed public sale supply.\");\n        require(publicSale, \"Public sale must be active\");\n        require(_amount <= _maxTokensAtOnce, \"Too many tokens at once\");\n        require(getTokenPrice().mul(_amount) <= msg.value, \"Insufficient funds to purchase\");\n\n        for(uint256 i = 0; i < _amount; i++) {\n        _mintWithRandomTokenId(msg.sender);\n        }\n    }\n\n    function mintMultipleTokensForPrivateSale(uint256 _amount, address _to) public payable nonReentrant {\n        require(privateSale, \"Private sale ended\");\n        require(totalSupply() < TOKEN_LIMIT, \"Purchase would exceed max supply of Crypto Moments\");\n        require(_privateSaleAddresses[address(msg.sender)], \"Not authorised\");\n\n        for(uint256 i = 0; i < _amount; i++) {\n        _mintWithRandomTokenId(_to);\n        }\n    }\n\n    function mintBonusTokenForPreviousOwners() public nonReentrant {\n        \n        require(totalSupply() >= _PUBLIC_TOKENS, \"Public sale did not end yet.\");\n        require(totalSupply().add(1) <= TOKEN_LIMIT, \"Purchase would exceed max supply of Crypto Moments\");\n        require(!_bonusAlreadyClaimed[address(msg.sender)], \"Bonus already claimed\");\n        require(balanceOfPreviousMoments(address(msg.sender))>0, \"Not a proud owner of a piece of crypto history.\");\n\n        _mintWithRandomTokenId(msg.sender);\n\n        _bonusAlreadyClaimed[address(msg.sender)] = true;\n    }\n\n    function ownerOfPreviousMoments(uint _tokenId) public view returns (address) {\n        IPreviousCollection previous = IPreviousCollection(_previuosMomentsContractAddress);\n        return previous.ownerOf(_tokenId);\n    }\n\n    function balanceOfPreviousMoments(address _owner) public view returns (uint256) {\n        IPreviousCollection previous = IPreviousCollection(_previuosMomentsContractAddress);\n        return previous.balanceOf(_owner);\n    }\n\n    \n\n\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract DraconeumToken {\n    \n    string public name = \"Draconeum\";\n    string public symbol = \"DRCM\";\n    uint8 public decimals = 8;\n    \n    uint256 public totalSupply = 14000000;\n    uint256 public initialSupply = 14000000;\n\n    \n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n\n    // Initializes contract with initial supply tokens to the creator of the contract\n    function DraconeumToken\n    (string tokenName, string tokenSymbol) \n        public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  \n        balanceOf[msg.sender] = totalSupply;                \n        name = tokenName =\"Draconeum\";                                   \n        symbol = tokenSymbol =\"DRCM\";                               \n    }\n\n    // Internal transfer, only can be called by this contract\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n     \n    }\n\n    // Transfer tokens. Send `_value` tokens to `_to` from your account\n    // Parameter: _to is The address of the recipient\n    // Parameter: _value is the amount to send\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    \n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract ADULT {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    // Constructor function. Initializes contract with initial supply tokens to the creator of the contract\n    function ADULT(\n    ) public {\n        totalSupply = 8000000000000000000000000000;                                 // Update total supply with the decimal amount\n        balanceOf[msg.sender] = 8000000000000000000000000000;                       // Give the creator all initial tokens\n        name = \"AdultCoin\";                                                         // Set the name for display purposes\n        symbol = \"ADULT\";                                                           // Set the symbol for display purposes\n    }\n\n    // Internal transfer, only can be called by this contract\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    // Transfer tokens. Send `_value` tokens to `_to` from your account\n    // Parameter: _to is the address of the recipient\n    // Parameter: _value is the amount to send\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    // Transfer tokens from other address. Send `_value` tokens to `_to` on behalf of `_from`\n    // Parameter: _from is The address of the sender\n    // Parameter: _to is The address of the recipient\n    // Parameter: _value is the amount to send\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    // Set allowance for other address. Allows `_spender` to spend no more than `_value` tokens on your behalf\n    // Parameter: _spender is The address authorized to spend\n    // Parameter: _value is the max amount they can spend\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    //Set allowance for other address and notify. Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     // Parameter: _spender is The address authorized to spend\n     // Parameter: _value is the max amount they can spend\n     // Parameter:_extraData is some extra information to send to the approved contract\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    // Destroy tokens. Remove `_value` tokens from the system irreversibly\n    // Parameter: _value is the amount of money to burn\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    // Destroy tokens from other account. Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n    // Parameter: _from is the address of the sender\n    // Parameter: _value is the amount of money to burn\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract Yukimi is ERC721Enum, Ownable, ReentrancyGuard {\n\tusing Strings for uint256;\n\tstring private baseURI;\n\tbool public revealed = false;\n\tstring public baseExtension =\".json\";\n    string public notRevealedUri;\n\tuint256 public reserved = 100;\n\t\n\tuint256 public cost = 0.07 ether;\n\tuint256 public maxSupply = 7777;\n\tuint256 public maxMint = 8;\n\tbool public publicSaleOpen = false; // Sale is not active\n    bool public preSaleIsActive = false; // Presale is not active\n\n\t\n\tbytes32 public merkleRoot = \"\"; \n\tmapping(address => uint) public whitelistRemaining; \n\tmapping(address => bool) public whitelistClaimed; \n\tuint256 public constant maxMintAmount = 4; \n\t\n\n\tevent Mint(address indexed owner, uint indexed tokenId);\n\n\tconstructor(string memory _initBaseURI,string memory _initNotRevealedUri) ERC721M(\"Yukimi\", \"DOJO\") {\n        setBaseURI(_initBaseURI);\n        setNotRevealedURI(_initNotRevealedUri);\n    }\n\n\tfunction _baseURI() internal view virtual returns (string memory) {\n\treturn baseURI;\n\t}\n\n    // Sale active/inactive\n\n\tfunction setPublicSale(bool val) public onlyOwner {\n        publicSaleOpen = val;\n    }\n\n    function setPreSale(bool val) public onlyOwner {\n        preSaleIsActive = val;\n    }\n\n\tfunction mint(uint256 amount) public payable nonReentrant{\n\t    require(publicSaleOpen, \"Sale is not Active\" );\n\t    uint256 s = totalSupply();\n        require(amount > 0, \"need to mint at least 1\" );\n        require(amount <= maxMint, \"max mint amount per session exceeded\");\n        require(s + amount <= maxSupply, \"max NFT limit exceeded\" );\n        require(msg.value >= cost * amount, \"Value is over or under price.\");\n        for (uint256 i = 0; i < amount; ++i) {\n            _safeMint(msg.sender, s + i, \"\");\n        }\n\t}\n\n\tfunction mintReserved(uint256 _amount) public onlyOwner {\n        require( _amount <= reserved, \"Can't reserve more than set amount\" );\n        reserved -= _amount;\n        uint256 s = totalSupply();\n        for (uint256 i; i < _amount; i++){\n            _safeMint( msg.sender, s + i );\n        }\n        delete s;\n\t}\n    \n\n    function whitelistMint(uint amount, bytes32 leaf, bytes32[] memory proof) external payable {\n        require(preSaleIsActive, \"Sale is not Active\" );\n        require(keccak256(abi.encodePacked(msg.sender)) == leaf, \"Sender and amount don't match Merkle leaf\");\n\n        require(verify(merkleRoot, leaf, proof), \"Not a valid leaf in the Merkle tree\");\n\n\n        uint256 s = totalSupply();\n        require(s + amount <= maxSupply, \"Sold out\");\n        require(amount <= maxMintAmount, \"Surpasses maxMintAmount\");\n\n        require(amount > 0, \"Can't mint zero\");\n\n        require(msg.value == amount * cost, \"Send proper ETH amount\");\n\n        require(whitelistRemaining[msg.sender] + amount <= maxMintAmount, \"Can't mint more than remaining allocation\");\n\n        whitelistRemaining[msg.sender] += amount;\n\n        for (uint256 i = 0; i < amount; ++i) {\n            _safeMint(msg.sender, s + i, \"\");\n        }\n\t}\n\n\tfunction verify(bytes32 _merkleRoot, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\n        return MerkleProof.verify(proof, _merkleRoot, leaf);\n    }\n\n\tfunction reveal() public onlyOwner() {\n        revealed = true;\n\t}\n\t  \n\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n    \n        if(revealed == false) {\n            return notRevealedUri;\n        }\n\n        string memory currentBaseURI = _baseURI();\n        return bytes(currentBaseURI).length > 0\n            ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\n            : \"\";\n    }\n\n\tfunction setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {\n        notRevealedUri = _notRevealedURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n\tfunction setCost(uint256 _newCost) public onlyOwner {\n\t    cost = _newCost;\n\t}\n\n\tfunction setMaxMintAmount(uint256 _newMaxMintAmount) public onlyOwner {\n\t    maxMint = _newMaxMintAmount;\n\t}\n\n\tfunction setmaxSupply(uint256 _newMaxSupply) public onlyOwner {\n\t    maxSupply = _newMaxSupply;\n\t}\n\n\tfunction setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n\tfunction withdraw() public payable onlyOwner {\n        (bool yk, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(yk);\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract MEANBANANA is Context, IERC20, Ownable {\n \n    using SafeMath for uint256;\n \n    string private constant _name = \"MEANBANANA\";//\n    string private constant _symbol = \"MEANBANANA\";//\n    uint8 private constant _decimals = 9;\n \n    mapping(address => uint256) private _rOwned;\n    mapping(address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) private _isExcludedFromFee;\n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 1000000000 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n    uint256 public launchBlock;\n \n    // Buy Fee\n    uint256 private _redisFeeOnBuy = 0;//\n    uint256 private _taxFeeOnBuy = 8;//\n \n    // Sell Fee\n    uint256 private _redisFeeOnSell = 2;//\n    uint256 private _taxFeeOnSell = 10;//\n \n    // Original Fee\n    uint256 private _redisFee = _redisFeeOnSell;\n    uint256 private _taxFee = _taxFeeOnSell;\n \n    uint256 private _previousredisFee = _redisFee;\n    uint256 private _previoustaxFee = _taxFee;\n \n    mapping(address => bool) public bots;\n    mapping(address => uint256) private cooldown;\n \n    address payable private _developmentAddress = payable(0x14946a445442c3a135733A93B967dc5185d2Ff07);\n    address payable private _marketingAddress = payable(0xD509Bd191B1dD916B04E4a3718bcB6AB72FdF564);\n \n    IUniswapV2Router02 public uniswapV2Router;\n    address public uniswapV2Pair;\n \n    bool private tradingOpen;\n    bool private inSwap = false;\n    bool private swapEnabled = true;\n \n    uint256 public _maxTxAmount = 10000000 * 10**9;\n    uint256 public _maxWalletSize = 50000000 * 10**9;\n    uint256 public _swapTokensAtAmount = 10000000 * 10**9; \n \n    event MaxTxAmountUpdated(uint256 _maxTxAmount);\n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n \n    constructor() {\n \n        _rOwned[_msgSender()] = _rTotal;\n \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        uniswapV2Router = _uniswapV2Router;\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n \n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[_developmentAddress] = true;\n        _isExcludedFromFee[_marketingAddress] = true;\n  \n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n \n    function name() public pure returns (string memory) {\n        return _name;\n    }\n \n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n \n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n \n    function totalSupply() public pure override returns (uint256) {\n        return _tTotal;\n    }\n \n    function balanceOf(address account) public view override returns (uint256) {\n        return tokenFromReflection(_rOwned[account]);\n    }\n \n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n \n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n \n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n \n    function transferFrom(address sender,address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n \n    function tokenFromReflection(uint256 rAmount) private view returns (uint256) {\n        require(\n            rAmount <= _rTotal,\n            \"Amount must be less than total reflections\"\n        );\n        uint256 currentRate = _getRate();\n        return rAmount.div(currentRate);\n    }\n \n    function removeAllFee() private {\n        if (_redisFee == 0 && _taxFee == 0) return;\n \n        _previousredisFee = _redisFee;\n        _previoustaxFee = _taxFee;\n \n        _redisFee = 0;\n        _taxFee = 0;\n    }\n \n    function restoreAllFee() private {\n        _redisFee = _previousredisFee;\n        _taxFee = _previoustaxFee;\n    }\n \n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n \n    function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n \n        if (from != owner() && to != owner()) {\n \n            //Trade start check\n            if (!tradingOpen) {\n                require(from == owner(), \"TOKEN: This account cannot send tokens until trading is enabled\");\n            }\n \n            require(amount <= _maxTxAmount, \"TOKEN: Max Transaction Limit\");\n            require(!bots[from] && !bots[to], \"TOKEN: Your account is blacklisted!\");\n \n            if(block.number <= launchBlock+1 && from == uniswapV2Pair && to != address(uniswapV2Router) && to != address(this)){   \n                bots[to] = true;\n            } \n \n            if(to != uniswapV2Pair) {\n                require(balanceOf(to) + amount < _maxWalletSize, \"TOKEN: Balance exceeds wallet size!\");\n            }\n \n            uint256 contractTokenBalance = balanceOf(address(this));\n            bool canSwap = contractTokenBalance >= _swapTokensAtAmount;\n \n            if(contractTokenBalance >= _maxTxAmount)\n            {\n                contractTokenBalance = _maxTxAmount;\n            }\n \n            if (canSwap && !inSwap && from != uniswapV2Pair && swapEnabled && !_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if (contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }\n \n        bool takeFee = true;\n \n        // Transfer Tokens\n        if ((_isExcludedFromFee[from] || _isExcludedFromFee[to]) || (from != uniswapV2Pair && to != uniswapV2Pair)) {\n            takeFee = false;\n        } else {\n \n            // Set Fee for Buys\n            if(from == uniswapV2Pair && to != address(uniswapV2Router)) {\n                _redisFee = _redisFeeOnBuy;\n                _taxFee = _taxFeeOnBuy;\n            }\n \n            // Set Fee for Sells\n            if (to == uniswapV2Pair && from != address(uniswapV2Router)) {\n                _redisFee = _redisFeeOnSell;\n                _taxFee = _taxFeeOnSell;\n            }\n \n        }\n \n        _tokenTransfer(from, to, amount, takeFee);\n    }\n \n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n \n    function sendETHToFee(uint256 amount) private {\n        _developmentAddress.transfer(amount.div(2));\n        _marketingAddress.transfer(amount.div(2));\n    }\n \n    function setTrading(bool _tradingOpen) public onlyOwner {\n        tradingOpen = _tradingOpen;\n        launchBlock = block.number;\n    }\n \n    function manualswap() external {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        uint256 contractBalance = balanceOf(address(this));\n        swapTokensForEth(contractBalance);\n    }\n \n    function manualsend() external {\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\n        uint256 contractETHBalance = address(this).balance;\n        sendETHToFee(contractETHBalance);\n    }\n \n    function blockBots(address[] memory bots_) public onlyOwner {\n        for (uint256 i = 0; i < bots_.length; i++) {\n            bots[bots_[i]] = true;\n        }\n    }\n \n    function unblockBot(address notbot) public onlyOwner {\n        bots[notbot] = false;\n    }\n \n    function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n        if (!takeFee) removeAllFee();\n        _transferStandard(sender, recipient, amount);\n        if (!takeFee) restoreAllFee();\n    }\n \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tTeam\n        ) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n \n    function _takeTeam(uint256 tTeam) private {\n        uint256 currentRate = _getRate();\n        uint256 rTeam = tTeam.mul(currentRate);\n        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n    }\n \n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n \n    receive() external payable {}\n \n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =\n            _getTValues(tAmount, _redisFee, _taxFee);\n        uint256 currentRate = _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =\n            _getRValues(tAmount, tFee, tTeam, currentRate);\n \n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n    }\n \n    function _getTValues(uint256 tAmount, uint256 redisFee, uint256 taxFee) private pure returns (uint256, uint256, uint256) {\n        uint256 tFee = tAmount.mul(redisFee).div(100);\n        uint256 tTeam = tAmount.mul(taxFee).div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n \n        return (tTransferAmount, tFee, tTeam);\n    }\n \n    function _getRValues( uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTeam = tTeam.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n \n        return (rAmount, rTransferAmount, rFee);\n    }\n \n    function _getRate() private view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n \n        return rSupply.div(tSupply);\n    }\n \n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n \n        return (rSupply, tSupply);\n    }\n \n    function setFee(uint256 redisFeeOnBuy, uint256 redisFeeOnSell, uint256 taxFeeOnBuy, uint256 taxFeeOnSell) public onlyOwner {\n        _redisFeeOnBuy = redisFeeOnBuy;\n        _redisFeeOnSell = redisFeeOnSell;\n \n        _taxFeeOnBuy = taxFeeOnBuy;\n        _taxFeeOnSell = taxFeeOnSell;\n    }\n \n    //Set minimum tokens required to swap.\n    function setMinSwapTokensThreshold(uint256 swapTokensAtAmount) public onlyOwner {\n        _swapTokensAtAmount = swapTokensAtAmount;\n    }\n \n    //Set minimum tokens required to swap.\n    function toggleSwap(bool _swapEnabled) public onlyOwner {\n        swapEnabled = _swapEnabled;\n    }\n \n \n    //Set maximum transaction\n    function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {\n        _maxTxAmount = maxTxAmount;\n    }\n \n    function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\n        _maxWalletSize = maxWalletSize;\n    }\n \n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\n        for(uint256 i = 0; i < accounts.length; i++) {\n            _isExcludedFromFee[accounts[i]] = excluded;\n        }\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract BearToken is PausableToken {\n    using SafeMath for uint;\n\n    /// Constant token specific fields\n    string public constant name = \"BearToken\";\n    string public constant symbol = \"BBC\";\n    uint public constant decimals = 18;\n\n    /// bear total tokens supply\n    uint public maxTotalSupply;\n\n    /// Fields that are only changed in constructor\n    address public minter; \n\n    modifier onlyMinter {\n        assert(msg.sender == minter);\n        _;\n    }\n\n    modifier isLaterThan (uint x){\n        assert(now > x);\n        _;\n    }\n\n    modifier maxTokenAmountNotReached (uint amount){\n        assert(totalSupply.add(amount) <= maxTotalSupply);\n        _;\n    }\n\n    modifier validAddress( address addr ) {\n        require(addr != address(0x0));\n        require(addr != address(this));\n        _;\n    }\n\n    // CONSTRUCTOR. \n    // Initialize the Bear Token\n    // Parameter: _minter is The BearCrowdSale Contract \n    // Parameter: _admin is owner of the contract\n    // Parameter: _maxTotalSupply is total supply token    \n    function BearToken(address _minter, address _admin, uint _maxTotalSupply) \n        public \n        validAddress(_admin)\n        validAddress(_minter)\n        {\n        minter = _minter;\n        maxTotalSupply = _maxTotalSupply;\n        transferOwnership(_admin);\n    }\n\n    // EXTERNAL FUNCTION\n    // BearCrowdSale contract instance mint token\n    // Parameter: receipent is The destination account owned mint tokens    \n    // Parameter: amount is The amount of mint token be sent to this address.\n    function mint(address receipent, uint amount)\n        external\n        onlyMinter\n        maxTokenAmountNotReached(amount)\n        returns (bool)\n    {\n        balances[receipent] = balances[receipent].add(amount);\n        totalSupply = totalSupply.add(amount);\n        return true;\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract ExecutiveHusky is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n\n    string public baseURI;\n    string public baseExtension = \".json\";\n    uint256 public cost = 0.07 ether;\n    uint256 public maxSupply = 7777;\n    uint256 public maxMintAmount = 10;\n    uint256 public maxSupplyPerWallet = 1;\n    \n    bool public paused = true;\n  \n    bool public presale = true;\n    \n    bool public whitelistedAndMint = true;\n    bool public MintForCreator = true;\n\n    uint256 public whitelistMinCost = 0.05 ether;\n\n    string public presaleURI = \"http://23.254.217.117:5555/ExecutiveHuskyClub/DefaultFile.json\";\n    \n    // address of OmniFusion contract\n    //address public FusionContractAddress;\n\n    mapping(address => bool) public whitelisted;\n\n    bool public WhitelistOnlyFromOwner = true;\n\n\n    // Creator\n    address Creator = 0x0329fB3b8A76D462534F4a6Ee9FeE81F16D4adb2;\n\n    // Member1\n    address  _65_Member1 = 0x0894a0178C022D0C573380f95C8949E391B75b20;\n    // Member2\n    address  _25_Member2 = 0x2075EB461cb59c5F32838dd31dDCb8e607561185;\n    // Member3\n    address  _5_Member3 = 0xa8049Db284302481badb823609145d7705cA8FA4; \n    // Member4\n    address  _5_Member4 = 0x9108e880920DA54C4D671eD9c7551D03b0dB8b30;\n\n\n    constructor(string memory _initBaseURI) ERC721(\"ExecutiveHusky\", \"ExecutiveHusky\") {\n        setBaseURI(_initBaseURI);\n    }\n\n    // internal\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n  \n    // public\n    function mint(address _to, uint256 _mintAmount) public payable {\n        require(!paused);\n        require(_mintAmount > 0);\n        \n        uint256 supply = totalSupply();\n        require(supply + _mintAmount <= maxSupply);\n        \n        uint256 WalletTokenCount = balanceOf(_to);\n        require(WalletTokenCount + _mintAmount <= maxSupplyPerWallet);\n        \n        \n        if (msg.sender != owner()) {\n\n            if(whitelisted[msg.sender] == true) {\n                require(_mintAmount <= maxMintAmount);\n                require(msg.value >= whitelistMinCost * _mintAmount);\n            } else {\n                require(_mintAmount <= maxMintAmount);\n                require(msg.value >= cost * _mintAmount);\n            }\n\n        }\n\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n            if(MintForCreator == true){\n                _safeMint(Creator, supply + i);\n                _transfer(Creator, _to, supply + i);\n            } else {\n                _safeMint(_to, supply + i);\n            }\n        }\n    }\n  \n    function mintWithwhitelisted(address _to, uint256 _mintAmount) public payable {\n        if(whitelistedAndMint == true)\n            whitelisted[msg.sender] = true;\n            \n        mint(_to, _mintAmount);\n    }\n  \n\n    function walletOfOwner(address _owner) public view returns (uint256[] memory) {\n        uint256 ownerTokenCount = balanceOf(_owner);\n        uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n        for (uint256 i; i < ownerTokenCount; i++) {\n            tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n        return tokenIds;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(\n        _exists(tokenId),\n        \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        if (presale){\n            return presaleURI;\n        } else {\n            string memory currentBaseURI = _baseURI();\n            \n            return bytes(currentBaseURI).length > 0\n            ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\n            : \"\";    \n        }\n    }\n  \n  //only owner\n    function setCost(uint256 _newCost) public onlyOwner() {\n        cost = _newCost;\n    }\n\n    function setwhitelistMinCost(uint256 _newCost) public onlyOwner() {\n        whitelistMinCost = _newCost;\n    }\n\n    function setmaxSupply(uint256 _newMaxSupply) public onlyOwner() {\n        maxSupply = _newMaxSupply;\n    }\n\n    function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner() {\n        maxMintAmount = _newmaxMintAmount;\n    }\n    \n    function setmaxSupplyPerWallet(uint256 _newmaxSupplyPerWallet) public onlyOwner() {\n        maxSupplyPerWallet = _newmaxSupplyPerWallet;\n    }\n\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n    \n    function setpresaleURI(string memory _newPresaleURI) public onlyOwner {\n        presaleURI = _newPresaleURI;\n    }\n    \n    function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\n        baseExtension = _newBaseExtension;\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n    \n    function setpresale(bool _state) public onlyOwner {\n        presale = _state;\n        \n    }\n    \n    function whitelistUser(address _user) public {\n        if(WhitelistOnlyFromOwner == true)\n        require(msg.sender == owner());\n        else if(msg.sender != owner())\n        require(msg.sender == _user);\n\n        whitelisted[_user] = true;\n    }\n    \n    function removeWhitelistUser(address _user) public {\n        if (WhitelistOnlyFromOwner == true) {\n            require(msg.sender == owner());\n        } else if(msg.sender != owner()) {\n            require(msg.sender == _user);\n        }\n        whitelisted[_user] = false;\n    }\n\n    function setMintForCreator(bool _state) public onlyOwner {\n        MintForCreator = _state; \n    }\n    \n    function setwhitelistedAndMint(bool _state) public onlyOwner {\n        whitelistedAndMint = _state; \n    }\n\n    function setWhitelistOnlyFromOwner(bool _state) public onlyOwner {\n        WhitelistOnlyFromOwner = _state; \n    }\n  \n    function withdraw() public {\n      if(msg.sender == owner() || msg.sender == _25_Member2)\n      {\n        uint bal = address(this).balance;\n        uint _1_Procent = bal / 100 ; // 1/100 = 1%\n        \n        uint _65_Member1_Share = _1_Procent * 65;\n        uint _25_Member2_Share = _1_Procent * 25;\n        uint _5_Member3_Share = _1_Procent * 5;\n        uint _5_Member4_Share = _1_Procent * 5; \n        \n        require(payable(_65_Member1).send(_65_Member1_Share));\n        require(payable(_25_Member2).send(_25_Member2_Share));\n        require(payable(_5_Member3).send(_5_Member3_Share));\n        require(payable(_5_Member4).send(_5_Member4_Share));\n      }\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract GN10Token is pays_commission, owned {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 0;\n    uint256 public totalSupply;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    uint256 public buyPrice = 1700000000000000;\n    uint256 public sellPrice = 1500000000000000;\n    bool public closeSell = false;\n    mapping (address => bool) public frozenAccount;\n\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event FrozenFunds(address target, bool frozen);\n    event Deposit(address sender, uint amount);\n    event Withdrawal(address receiver, uint amount);\n\n\n    // Constructor\n    constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[owner] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n    }\n\n\n    // Internal functions\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != 0x0);\n        require(!frozenAccount[_from]);\n        require(!frozenAccount[_to]);\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function _pay_token_commission (uint256 _value) internal {\n        uint market_value = _value * sellPrice;\n        uint commission_value = market_value * 1 / 100;\n        // The comision is paid with tokens\n        uint commission = commission_value / sellPrice;\n        if (commission < minimumTokenCommission){ \n            commission = minimumTokenCommission;\n        }\n        address contr = this;\n        _transfer(contr, commissionGetter, commission);\n    }\n\n\n    // Only owner functions\n\n    function refillTokens(uint256 _value) onlyOwner public {\n        _transfer(msg.sender, this, _value);\n    }\n\n\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\n        sellPrice = newSellPrice;\n        buyPrice = newBuyPrice;\n    }\n\n    function setStatus(bool isClosedSell) onlyOwner public {\n        closeSell = isClosedSell;\n    }\n\n    function withdrawEther(uint amountInWeis) onlyOwner public {\n        address contr = this;\n        require(contr.balance >= amountInWeis);\n        emit Withdrawal(msg.sender, amountInWeis);\n        owner.transfer(amountInWeis);\n    }\n\n\n    // Public functions\n    function transfer(address _to, uint256 _value) public {\n        _pay_token_commission(_value);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);\n        _pay_token_commission(_value);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function depositEther() payable public returns(bool success) {\n        address contr = this;\n        require((contr.balance + msg.value) > contr.balance);\n        emit Deposit(msg.sender, msg.value);\n        return true;\n    }\n\n    function buy() payable public {\n        uint amount = msg.value / buyPrice;\n        uint market_value = amount * buyPrice;\n        uint commission = market_value * 1 / 100;\n        // The comision is paid with Ether\n        if (commission < minimumEtherCommission){\n            commission = minimumEtherCommission;\n        }\n        address contr = this;\n        require(contr.balance >= commission);\n        commissionGetter.transfer(commission);\n        _transfer(this, msg.sender, amount);\n    }\n\n    function sell(uint256 amount) public {\n    \trequire(!closeSell);\n        _pay_token_commission(amount);\n        _transfer(msg.sender, this, amount);\n        uint market_value = amount * sellPrice;\n        address contr = this;\n        require(contr.balance >= market_value);\n        msg.sender.transfer(market_value);\n    }\n\n    function () payable public {\n        buy();\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract WTPhunks is ERC721, Ownable {\n    using Strings for uint256;\n\n    string public baseURI;\n    string public baseExtension = \".json\";\n    uint256 public cost = 0 ether;\n    uint256 public bulkCost = 0 ether;\n    uint256 public bulkNum = 10;\n    uint256 public maxSupply = 10000;\n    uint256 public maxMintAmount = 20;\n    uint256 public saleLimit = 1000;\n    bool public paused = false;\n    uint16 public totalSupply = 0;\n\n    constructor(string memory _name, string memory _symbol, string memory _initBaseURI) ERC721(_name, _symbol) {\n        setBaseURI(_initBaseURI);\n        mint(msg.sender, 1);\n    }\n\n    // internal\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    // public\n    function mint(address _to, uint256 _mintAmount) public payable {\n        require(!paused);\n        require(_mintAmount > 0);\n        require(_mintAmount <= maxMintAmount);\n        require(totalSupply + _mintAmount <= saleLimit);\n\n        if (msg.sender != owner()) {\n            if(_mintAmount >= bulkNum) {\n                require(msg.value >= bulkCost * _mintAmount);\n            } else {\n                require(msg.value >= cost * _mintAmount);\n            }\n        }\n\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n            _safeMint(_to, totalSupply + 1);\n            totalSupply += 1;\n        }\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory currentBaseURI = _baseURI();\n        return\n            bytes(currentBaseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        currentBaseURI,\n                        tokenId.toString(),\n                        baseExtension\n                    )\n                )\n                : \"\";\n    }\n\n    //only owner\n    function setCost(uint256 _newCost) public onlyOwner {\n        cost = _newCost;\n    }\n\n    function setBulkCost(uint256 _newBulkCost) public onlyOwner {\n        bulkCost = _newBulkCost;\n    }\n\n    function setBulkNum(uint256 _newBulkNum) public onlyOwner {\n        bulkNum = _newBulkNum;\n    }\n\n    function setSaleLimit(uint256 _saleLimit) public onlyOwner {\n        require(_saleLimit <= maxSupply);\n        saleLimit = _saleLimit;\n    }\n\n    function updateSalePhase(uint256 _saleLimit, uint256 _cost, uint256 _bulkCost) public onlyOwner {\n        setSaleLimit(_saleLimit);\n        setCost(_cost);\n        setBulkCost(_bulkCost);\n    }\n\n    function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {\n        maxMintAmount = _newmaxMintAmount;\n    }\n\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\n        baseExtension = _newBaseExtension;\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool success, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        require(success);\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract SminemNFT is ERC721, Ownable {\n    using Strings for uint256;\n    using Counters for Counters.Counter;\n\n    Counters.Counter private supply;\n\n    string public uriPrefix = \"\";\n    string public uriSuffix = \".json\";\n    string public hiddenMetadataUri;\n    \n    uint256 public cost = 0.07 ether;\n    uint256 public maxSupply = 12288;\n    uint256 public maxMintAmountPerTx = 20;\n    uint256 public nftPerAddressLimit = 1;\n\n    bool public paused = true;\n    bool public revealed = false;\n\n    address[] public whitelistedAddresses;\n    mapping(address => uint256) public addressMintedBalance;\n\n\n    constructor() ERC721(\"Sminem NFT\", \"SMIN\") {\n        setHiddenMetadataUri(\"ipfs://QmejWaXqUt69oshQ6rXVVweP7xWP4Ui2QFhLUTJZHws6c5/\");\n    }\n\n    //ensures minting security\n    modifier mintCompliance(uint256 _mintAmount) {\n        require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, \"Invalid mint amount!\");\n        require(supply.current() + _mintAmount <= maxSupply, \"Max supply exceeded!\");\n        _;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return supply.current();\n    }\n\n    function mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) {\n        require(!paused, \"The contract is paused!\");\n        require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n\n        _mintLoop(msg.sender, _mintAmount);\n    }\n\n    function mintFromWhiteList(uint256 _mintAmount) public mintCompliance(_mintAmount) {\n        require(!paused, \"contract is paused\");\n        require(isWhitelisted(msg.sender), \"User is not whitelisted\");\n        uint256 ownerMintedCount = addressMintedBalance[msg.sender];\n        require(ownerMintedCount + _mintAmount <= nftPerAddressLimit, \"max NFT per address exceeded\");\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n            addressMintedBalance[msg.sender]++;\n        }\n        _mintLoop(msg.sender, _mintAmount);\n    } \n    \n    function mintForAddress(uint256 _mintAmount, address _receiver) public mintCompliance(_mintAmount) onlyOwner {\n        _mintLoop(_receiver, _mintAmount);\n    }\n\n    //returns an array of NFT owners wallets and amounts\n    function walletOfOwner(address _owner) public view returns (uint256[] memory) {\n        uint256 ownerTokenCount = balanceOf(_owner);\n        uint256[] memory ownedTokenIds = new uint256[](ownerTokenCount);\n        uint256 currentTokenId = 1;\n        uint256 ownedTokenIndex = 0;\n\n        while (ownedTokenIndex < ownerTokenCount && currentTokenId <= maxSupply) {\n            address currentTokenOwner = ownerOf(currentTokenId);\n\n            if (currentTokenOwner == _owner) {\n                ownedTokenIds[ownedTokenIndex] = currentTokenId;\n                ownedTokenIndex++;\n            }\n            currentTokenId++;\n        }\n        return ownedTokenIds;\n    }\n\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n        require(\n            _exists(_tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        if (revealed == false) {\n        return hiddenMetadataUri;\n        }\n\n        string memory currentBaseURI = _baseURI();\n        return bytes(currentBaseURI).length > 0\n            ? string(abi.encodePacked(currentBaseURI, _tokenId.toString(), uriSuffix))\n            : \"\";\n    }\n\n    //hide and unhide metadata\n    function setRevealed(bool _state) public onlyOwner {\n        revealed = _state;\n    }\n\n    //set cost of minting in wei \n    function setCost(uint256 _cost) public onlyOwner {\n        cost = _cost;\n    }\n\n    function setLimit(uint256 _nftPerAddressLimit) public onlyOwner {\n        nftPerAddressLimit = _nftPerAddressLimit;\n    }\n\n    function setMaxMintAmountPerTx(uint256 _maxMintAmountPerTx) public onlyOwner {\n        maxMintAmountPerTx = _maxMintAmountPerTx;\n    }\n\n    //takes a string updates metadata\n    function setHiddenMetadataUri(string memory _hiddenMetadataUri) public onlyOwner {\n        hiddenMetadataUri = _hiddenMetadataUri;\n    }\n\n    //updates the metadata used before reveal\n    function setUriPrefix(string memory _uriPrefix) public onlyOwner {\n        uriPrefix = _uriPrefix;\n    }\n\n    function setUriSuffix(string memory _uriSuffix) public onlyOwner {\n        uriSuffix = _uriSuffix;\n    }\n\n    function setPaused(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n\n    function _mintLoop(address _receiver, uint256 _mintAmount) internal {\n        for (uint256 i = 0; i < _mintAmount; i++) {\n        supply.increment();\n        _safeMint(_receiver, supply.current());\n        }\n    }\n\n    //checks if a message sender is whitelisted \n    function isWhitelisted(address _user) public view returns (bool) {\n        for (uint i = 0; i < whitelistedAddresses.length; i++) {\n        if (whitelistedAddresses[i] == _user) {\n            return true;\n        }\n        }\n        return false;\n    }\n\n    //whitelist a users if they won a giveaway\n    function whiteListUsers(address[] calldata _users) public onlyOwner(){\n        delete whitelistedAddresses;\n        whitelistedAddresses = _users;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return uriPrefix;\n    }\n\n    function withdraw() external onlyOwner {\n        address[4] memory addresses = [\n            0x6E9075da365BE17041e704A16d39652a7a54b862,\n            0x3577ee30ef3e818FA07b25ac5F3A6Ff9cea1Fc3D,\n            0xff39c27b5eAC4a31636ae4Bb2be121f2CD96b2a4,\n            0xAc84e43AafDBc3b35C529bcB83492faA8d8083aC\n        ];\n\n        uint32[4] memory shares = [\n            uint32(1150),\n            uint32(200),\n            uint32(650),\n            uint32(8000)\n        ];\n\n        uint256 balance = address(this).balance;\n\n        for (uint32 i = 0; i < addresses.length; i++) {\n            uint256 amount = i == addresses.length - 1 ? address(this).balance : balance * shares[i] / 10000;\n            payable(addresses[i]).transfer(amount);\n        }\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract CFI is ERC20Detailed {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    // setup token\n    string constant tokenName = \"colibri.finance\";\n    string constant tokenSymbol = \"CFI\";\n    uint8  constant tokenDecimals = 18;\n    // total supply 50,000\n    uint256 _totalSupply = 50000000000000000000000;\n    // set percentage with 2 decimals precision, so we get 100/100000\n    uint256 public basePercent = 100;\n\n    constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function estimateOnePercent(uint256 value) public view returns (uint256)  {\n        uint256 roundValue = value.ceil(basePercent);\n        uint256 onePercent = roundValue.mul(basePercent).div(10000);\n        return onePercent;\n    }\n\n    // transfer with burn mechanism\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[msg.sender]);\n        require(to != address(0));\n\n        uint256 tokensToBurn = estimateOnePercent(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(tokensToTransfer);\n\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        emit Transfer(msg.sender, to, tokensToTransfer);\n        emit Transfer(msg.sender, address(0), tokensToBurn);\n        return true;\n    }\n\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // address frm = from;\n    // address sender = msg.sender;\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n\n        uint256 tokensToBurn = estimateOnePercent(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[to] = _balances[to].add(tokensToTransfer);\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n        emit Transfer(from, to, tokensToTransfer);\n        emit Transfer(from, address(0), tokensToBurn);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(amount != 0);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= _balances[account]);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[account] = _balances[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external {\n        require(amount <= _allowed[account][msg.sender]);\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);\n        _burn(account, amount);\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract RocketTickets is ERC1155, Ownable {\n\n    uint constant public TICKET_ID = 0;\n\n    bool public isTicketsLocked;\n    mapping(address => bool) public isOperatorApproved;\n\n    constructor() ERC1155(\"https://tickets.onedaybae.io/meta/\") {\n        isTicketsLocked = true;\n    }\n\n    // Admin functions region\n    function setURI(string memory uri) external onlyOwner {\n        _setURI(uri);\n    }\n\n    function approveOperator(address operator, bool approved) external onlyOwner {\n        isOperatorApproved[operator] = approved;\n    }\n\n    function setIsTicketsLocked(bool _isTicketsLocked) external onlyOwner {\n        isTicketsLocked = _isTicketsLocked;\n    }\n\n    // Mint and Burn functions\n    function mint(address[] memory addresses, uint[] memory amounts) external onlyOwner {\n        require(addresses.length == amounts.length, \"addresses.length != amounts.length\");\n        for (uint i = 0; i < addresses.length; i++) {\n            _mint(addresses[i], TICKET_ID, amounts[i], \"\");\n        }\n    }\n\n    // 1151 interface region\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\n        return isOperatorApproved[operator] || super.isApprovedForAll(account, operator);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) public override {\n        require(!isTicketsLocked, \"Transfers locked\");\n        super._safeTransferFrom(from, to, id, amount, data);\n    }\n\n    function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public virtual override {\n        require(!isTicketsLocked, \"Transfers locked\");\n        super._safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract ERC20Token is IERC20, Pausable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    string internal _name;\n    string internal _symbol;\n    uint8 internal _decimals;\n    uint256 internal _totalSupply;\n\n    mapping (address => uint256) internal _balances;\n    mapping (address => mapping (address => uint256)) internal _allowances;\n\n    constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _totalSupply = totalSupply;\n        _balances[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256 balance) {\n        return _balances[account];\n    }\n\n\n    // Function that is called when a user or another contract wants to transfer funds.\n    function transfer(address recipient, uint256 amount) public whenNotPaused returns (bool success) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public whenNotPaused returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function mint(address account,uint256 amount) public onlyOwner returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n    \n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }    \n\n    function burn(address account,uint256 amount) public onlyOwner returns (bool) {\n        _burn(account, amount);\n        return true;\n    }\n    \n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn to the zero address\");\n\n\t    _balances[account] = _balances[account].sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    } \n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract TheMaskSociety is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n\n    uint256 public constant cost = 0.04 ether;\n    uint256 public constant maxSupply = 4447;\n    uint256 public maxMintAmount = 5;\n    uint256 public reserve = 150;\n    bool public saleIsActive = false;\n    bool public revealed = false;\n    bool public isMetadataLocked = false;\n    string baseURI;\n    string public baseExtension = \".json\";\n    string public notRevealedUri;\n\n    constructor(\n    string memory _name,\n    string memory _symbol,\n    string memory _initBaseURI,\n    string memory _initNotRevealedUri\n    ) ERC721(_name, _symbol) {\n        setBaseURI(_initBaseURI);\n        setNotRevealedURI(_initNotRevealedUri);\n    }\n\n    // internal\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    // public\n    function mint(uint256 _mintAmount) public payable {\n        uint256 supply = totalSupply();\n        require(saleIsActive, \"Sale is not active at the moment\");\n        require(_mintAmount > 0, \"Mint quantity must be greater than 0\");\n        require(_mintAmount <= maxMintAmount, \"Your selection would exceed the total number of items to mint\");\n        require(supply + _mintAmount <= maxSupply - reserve, \"Purchase would exceed max supply of Masks\");\n\n        require(msg.value >= cost * _mintAmount);\n\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n            _safeMint(msg.sender, supply + i);\n        }\n    }\n\n    function walletOfOwner(address _owner) public view\n    returns (uint256[] memory)\n    {\n        uint256 ownerTokenCount = balanceOf(_owner);\n        uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n        for (uint256 i; i < ownerTokenCount; i++) {\n            tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n        return tokenIds;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        if(revealed == false) {\n            return notRevealedUri;\n        }\n\n        string memory currentBaseURI = _baseURI();\n        return bytes(currentBaseURI).length > 0\n            ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\n            : \"\";\n    }\n\n    //only owner\n    function reveal() public onlyOwner() {\n        revealed = true;\n    }\n\n\n    function setMaxMintAmount(uint256 _newMaxMintAmount) public onlyOwner() {\n        maxMintAmount = _newMaxMintAmount;\n    }\n\n    function lockMetadata() public onlyOwner {\n        isMetadataLocked = true;\n    }\n\n    function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {\n        require(!isMetadataLocked,\"Metadata is locked\");\n        notRevealedUri = _notRevealedURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        require(!isMetadataLocked,\"Metadata is locked\");\n        baseURI = _newBaseURI;\n    }\n\n    function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\n        require(!isMetadataLocked,\"Metadata is locked\");\n        baseExtension = _newBaseExtension;\n    }\n\n    function setSaleIsActive(bool _state) public onlyOwner {\n        saleIsActive = _state;\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool success, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(success);\n    }\n\n    function reserveMasks(address _to, uint256 _reserveAmount) public onlyOwner {\n        uint256 supply = totalSupply();\n        require(\n            _reserveAmount > 0 && _reserveAmount <= reserve,\n            \"Not enough reserve left for team\"\n        );\n\n        for (uint256 i = 1; i <= _reserveAmount; i++) {\n            _safeMint(_to, supply + i);\n        }\n        reserve = reserve - _reserveAmount;\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract DrinkOrDo is ERC20Interface, Owned {\r\n    using SafeMath for uint;\r\n\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    constructor() public {\r\n        symbol = \"DRNK\";\r\n        name = \"Drink or Do\";\r\n        decimals = 0;\r\n        _totalSupply = 1000000 * 10**uint(decimals);\r\n        balances[owner] = _totalSupply;\r\n        emit Transfer(address(0), owner, _totalSupply);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply.sub(balances[address(0)]);\r\n    }\r\n\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = balances[from].sub(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n        return true;\r\n    }\r\n\r\n    // Don't accept ETH\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    // Owner can transfer out any accidentally sent ERC20 token\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract LEMURLEMUR is ERC721, Ownable {\n    using SafeMath for uint256;\n    uint256 public constant maxTokens = 3030;\n    uint256 public constant maxMintsPerTx = 10;\n    uint256 public constant startingId = 0;\n    uint256 public nextTokenId = startingId; \n    uint256 tokenPrice = 50000000000000000; //0.050 ether\n    string private _contractURI;\n    string public provenance;\n    bool public metaDataFrozen = false;\n    bool public liveSale = false;\n    address payable public teamMember; //dev team member\n    address private deployer;\n\n    constructor(address payable _teamMember) public ERC721(\"LEMUR LEMUR\", \"LMR\") {\n        teamMember = _teamMember; \n        deployer = msg.sender;\n    }\n\n    modifier duringSale() {\n        require(\n            liveSale,\n             \"Sale is not live!\"\n             );\n        _;\n    }\n\n    //authenticate team wallets for certain tasks\n    modifier onlyTeam() {\n        require(\n            msg.sender == deployer ||\n                msg.sender == teamMember ||\n                msg.sender == owner(),\n            \"Not authorized!\"\n        );\n        _;\n    }\n\n    modifier notFrozen() {\n        require(\n            !metaDataFrozen,\n            \"Metadata URI is permanently frozen\"\n            );\n        _;\n    }\n\n    // Set base URI path for each group of tokens\n    // This is a modification to the standard EC721 method that permits dev to load metadata into the contract on a partial basis\n    function setMetadataURI(uint256 group, string calldata _metadataURI) external onlyTeam notFrozen {\n        _setMetadataURI(group, _metadataURI);\n    }\n\n    //set initial metadata URI\n    function setInitialMetadataURI(string calldata _initialMetadataURI) external onlyTeam notFrozen {\n        _setInitialMetadataURI(_initialMetadataURI);\n    }\n\n    //Project-level URI\n    function setContractURI(string memory contractURI_) external onlyTeam {\n        _contractURI = contractURI_;\n    }\n\n    function contractURI() public view returns (string memory) {\n        return _contractURI;\n    }\n\n    //Allows Owner to freeze token metadata URI permanently. Project-level URI is not frozen in case links need to be upated. \n    function freezeMetadata() public onlyOwner {\n        metaDataFrozen=true;\n    }   \n\n    //Provenance may only be set once irreversibly\n    //Provenance is a string that should be an IPFS CID or file hash\n    function setProvenance(string memory _provenance) external onlyOwner {\n        require(\n            bytes(provenance).length == 0,\n             \"Provenance already set!\"\n             );\n        provenance = _provenance;\n    }\n\n    //Minting\n    function mint(uint256 quantity) external payable duringSale {\n        require(\n            quantity <= maxMintsPerTx,\n            \"There is a limit on minting too many at a time!\"\n        );\n        require(\n            totalSupply().add(quantity) <= maxTokens,\n            \"Minting this many would exceed supply!\"\n        );\n        require(\n            msg.value == tokenPrice.mul(quantity),\n            \"Wrong amount of ether sent!\"\n        );\n        minter(msg.sender, quantity);\n    }\n\n    //Dev bulk minting in order to distribute mints to legacy holders and dev team.\n    function devMint( address payable[] memory recipients, uint256[] memory quantity) external onlyOwner {\n        //ensure data integrity\n        require(recipients.length == quantity.length, \"Data length mismatch!\");\n        //ensure dev mint would not exceed the cap\n        uint256 totalMintRequested = 0;\n        for (uint256 i = 0; i < quantity.length; i++) {\n            totalMintRequested = totalMintRequested.add(quantity[i]);\n        }\n        require(\n            totalSupply().add(totalMintRequested) <= maxTokens,\n            \"Minting this many would exceed supply!\"\n        );\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            minter(recipients[i], quantity[i]);\n        }\n    }\n\n    //mint\n    function minter(address payable sender, uint256 quantity) internal {\n        for (uint256 i = 0; i < quantity; i++) {\n            _safeMint(sender, nextTokenId);\n            nextTokenId++;\n        }\n    }\n\n    //Allow owner to enable/disable the sale.\n    function toggleSale() public onlyTeam {\n        liveSale = !liveSale;\n    }\n\n    //Withdraw eth from the contract and send to team members\n    function withdraw() public onlyTeam {\n        payable(owner()).send(address(this).balance); //send balance to owner\n    }\n\n    //Allow token burn after sale is complete\n    function burn(uint256 tokenId) public virtual {\n        require(\n            !liveSale,\n             \"No burning while the sale is open\"\n             );\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721Burnable: caller is not owner nor approved\"\n        );\n        _burn(tokenId);\n    }\n\n    receive () external payable {}\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract Bornless is ERC721Enumerable, Ownable {\r\n    using Strings for uint256;\r\n    using ECDSA for bytes32;\r\n\r\n    string public baseURI;\r\n    string public extension = \".json\";\r\n    uint256 public cost = 0.0666 ether;\r\n    uint256 public maxSupply = 666;\r\n    uint256 private privateMaxSupply = 660;\r\n    uint public maxMintAmount = 20;\r\n    bool public publicSale = false;\r\n    bool public privateSale = false;\r\n    address public signer1;\r\n    address public signer2;\r\n    address public signer3;\r\n    address public signer4;\r\n    address public signer5;\r\n\r\n    constructor(string memory _name, string memory _symbol, string memory _initBaseURI) ERC721 (_name, _symbol){\r\n        setBaseURI(_initBaseURI);\r\n    }\r\n\r\n    function _baseURI() internal view virtual override returns (string memory){\r\n        return baseURI;\r\n    }\r\n\r\n    function mint(uint _mintAmount) public payable {\r\n        require(publicSale, \"Minting currently on hold\");\r\n        require(_mintAmount <= maxMintAmount, \"Maximum mint amount exceeded\");\r\n        require(totalSupply() + _mintAmount <= maxSupply, \"Purchase would exceed max supply of NFT\");\r\n        mintX(_mintAmount);\r\n    }\r\n\r\n    function privateSaleMint(uint _mintAmount, bytes memory signature) public payable {\r\n        require(privateSale, \"Private sale is not currently running\");\r\n        uint8 group = 0;\r\n        address recover = recoverSignerAddress(msg.sender, signature);\r\n        if (recover == signer1) {\r\n            group = 1;\r\n        }else if (recover == signer2) {\r\n            group = 2;\r\n        }else if (recover == signer3) {\r\n            group = 3;\r\n        }else if (recover == signer4) {\r\n            group = 4;\r\n        }else if (recover == signer5) {\r\n            group = 5;\r\n        }\r\n\r\n        require(group > 0 && group <= 5, \"Address not whitelisted for sale\");\r\n        require(totalSupply() + _mintAmount <= privateMaxSupply, \"Purchase would exceed max supply of private sale\");\r\n        require(balanceOf(msg.sender) + _mintAmount <= group, \"Minting would exceed max per wallet for presale\");\r\n        mintX(_mintAmount);\r\n    }\r\n\r\n    function mintX(uint _mintAmount) private {\r\n        uint supply = totalSupply();\r\n        require(_mintAmount > 0, \"Amount to mint can not be 0\");\r\n        if (msg.sender != owner()) {\r\n            require(msg.value >= cost * _mintAmount, \"Amount sent less than the cost of minting NFT(s)\");\r\n        }\r\n        for (uint256 i = 1; i <= _mintAmount; i++) {\r\n            _safeMint(msg.sender, supply + i);\r\n        }\r\n    }\r\n\r\n    function walletOfOwner(address _owner) public view returns (uint256[] memory){\r\n        uint256 ownerTokenCount = balanceOf(_owner);\r\n        uint256[] memory tokenIds = new uint256[](ownerTokenCount);\r\n        for (uint256 i; i < ownerTokenCount; i++) {\r\n            tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\r\n        }\r\n        return tokenIds;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory){\r\n\r\n        require(_exists(tokenId), \"ERC721Metadata: tokenURI queried for nonexistent token\");\r\n        string memory currentBaseURI = _baseURI();\r\n        return bytes(currentBaseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), extension)) : \"\";\r\n    }\r\n\r\n    //\r\n    function hashTransaction(address minter) private pure returns (bytes32) {\r\n        bytes32 argsHash = keccak256(abi.encodePacked(minter));\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", argsHash));\r\n    }\r\n\r\n    function recoverSignerAddress(address minter, bytes memory signature) private pure returns (address) {\r\n        bytes32 hash = hashTransaction(minter);\r\n        return hash.recover(signature);\r\n    }\r\n\r\n\r\n    // Access control\r\n    function setSigner(address _signer) public onlyOwner() {\r\n        signer1 = _signer;\r\n    }\r\n\r\n    function setSigner2(address _signer) public onlyOwner() {\r\n        signer2 = _signer;\r\n    }\r\n\r\n    function setSigner3(address _signer) public onlyOwner() {\r\n        signer3 = _signer;\r\n    }\r\n\r\n    function setSigner4(address _signer) public onlyOwner() {\r\n        signer4 = _signer;\r\n    }\r\n\r\n    function setSigner5(address _signer) public onlyOwner() {\r\n        signer5 = _signer;\r\n    }\r\n\r\n    function setCost(uint256 _cost) public onlyOwner() {\r\n        cost = _cost;\r\n    }\r\n\r\n    function setMaxMintAmount(uint256 _maxMintAmount) public onlyOwner() {\r\n        maxMintAmount = _maxMintAmount;\r\n    }\r\n\r\n    function setBaseURI(string memory _newBaseURI) public onlyOwner() {\r\n        baseURI = _newBaseURI;\r\n    }\r\n\r\n    function togglePublicSale() public onlyOwner() {\r\n        publicSale = !publicSale;\r\n    }\r\n\r\n    function togglePrivateSale() public onlyOwner() {\r\n        privateSale = !privateSale;\r\n    }\r\n\r\n    function configure(bool _publicSale, bool _privateSale, uint256 _maxMintAmount,\r\n        address _signer1, address _signer2, address _signer3, address _signer4, address _signer5) public onlyOwner() {\r\n        publicSale = _publicSale;\r\n        privateSale = _privateSale;\r\n        maxMintAmount = _maxMintAmount;\r\n        signer1 = _signer1;\r\n        signer2 = _signer2;\r\n        signer3 = _signer3;\r\n        signer4 = _signer4;\r\n        signer5 = _signer5;\r\n    }\r\n\r\n    function mintIndex(uint index) public payable onlyOwner() {\r\n        require(totalSupply() + 1 <= maxSupply, \"Purchase would exceed max supply of NFTs\");\r\n        _safeMint(msg.sender, index);\r\n    }\r\n\r\n    function mintIndex(uint index, address to) public payable onlyOwner() {\r\n        require(totalSupply() + 1 <= maxSupply, \"Purchase would exceed max supply of NFTs\");\r\n        _safeMint(to, index);\r\n    }\r\n\r\n    function withdraw() public payable onlyOwner() {\r\n        (bool success,) = address(msg.sender).call{value : address(this).balance}(\"\");\r\n        require(success, \"Unable to withdraw balance\");\r\n    }\r\n\r\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract BiotCoin is ERC20Capped, ERC20Detailed {\n    uint noOfTokens = 8_800_000_000; // 8.8B\n\n    // Address of biot coin vault\n    // The vault will have all the biot coin issued.\n    address internal vault;\n\n    // Address of biot coin owner\n    // The owner can change admin and vault address.\n    address internal owner;\n\n    // Address of biot coin admin\n    // The admin can change reserve. The reserve is the amount of token\n    // assigned to some address but not permitted to use.\n    address internal admin;\n\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\n    event VaultChanged(address indexed previousVault, address indexed newVault);\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\n    event ReserveChanged(address indexed _address, uint amount);\n\n    // reserved number of tokens per each address\n    // To limit token transaction for some period by the admin, each address' balance cannot become lower than this amount\n    mapping(address => uint) public reserves;\n\n    // modifier to limit access to the owner only\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    // limit access to the vault only\n    modifier onlyVault() {\n        require(msg.sender == vault);\n        _;\n    }\n\n    // limit access to the admin only\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    // limit access to owner or vault\n    modifier onlyOwnerOrVault() {\n        require(msg.sender == owner || msg.sender == vault);\n        _;\n    }\n\n    // initialize QRC20(ERC20)\n    // all token will deposit into the vault later, the vault, owner will be multi sign contract to protect privileged operations\n    // Parameter: _symbol is token symbol\n    // Parameter: _name is token name\n    // Parameter: _owner is owner address\n    // Parameter: _admin is admin address\n    // Parameter: _vault is vault address\n    // Cap the mintable amount to 77.7B(77,700,000,000)\n    constructor (string memory _symbol, string memory _name, address _owner,\n        address _admin, address _vault) ERC20Detailed(_name, _symbol, 9) ERC20Capped(77_700_000_000_000_000_000)\n    public {\n        require(bytes(_symbol).length > 0);\n        require(bytes(_name).length > 0);\n\n        owner = _owner;\n        admin = _admin;\n        vault = _vault;\n\n        // mint coins to the vault\n        _mint(vault, noOfTokens * (10 ** uint(decimals())));\n    }\n\n    // change the amount of reserved token\n    // Parameter: _address is the target address whose token will be frozen for future use\n    // Parameter: _reserve is the amount of reserved token\n    function setReserve(address _address, uint _reserve) public onlyAdmin {\n        require(_reserve <= totalSupply());\n        require(_address != address(0));\n\n        reserves[_address] = _reserve;\n        emit ReserveChanged(_address, _reserve);\n    }\n\n    // transfer token from sender to other\n    // the result balance should be greater than or equal to the reserved token amount\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        // check the reserve\n        require(balanceOf(msg.sender).sub(_value) >= reserveOf(msg.sender));\n        return super.transfer(_to, _value);\n    }\n\n    // change vault address\n    // Parameter: _newVault is the new vault address\n    function setVault(address _newVault) public onlyOwner {\n        require(_newVault != address(0));\n        require(_newVault != vault);\n\n        address _oldVault = vault;\n\n        // change vault address\n        vault = _newVault;\n        emit VaultChanged(_oldVault, _newVault);\n    }\n\n    // change owner address\n    // Parameter: _newOwner is the new owner address\n    function setOwner(address _newOwner) public onlyVault {\n        require(_newOwner != address(0));\n        require(_newOwner != owner);\n\n        emit OwnerChanged(owner, _newOwner);\n        owner = _newOwner;\n    }\n\n    // change admin address\n    // Parameter: _newAdmin is the new admin address\n    function setAdmin(address _newAdmin) public onlyOwnerOrVault {\n        require(_newAdmin != address(0));\n        require(_newAdmin != admin);\n\n        emit AdminChanged(admin, _newAdmin);\n        admin = _newAdmin;\n    }\n\n    // Transfer tokens from one address to another\n    // The _from's biot balance should be larger than the reserved amount(reserves[_from]) plus _value.\n    // NOTE: no one can tranfer from vault\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_from != vault);\n        require(_value <= balanceOf(_from).sub(reserves[_from]));\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function getVault() public view returns (address) {\n        return vault;\n    }\n\n    function getAdmin() public view returns (address) {\n        return admin;\n    }\n\n    function getOneBiotCoin() public view returns (uint) {\n        return (10 ** uint(decimals()));\n    }\n\n    // get the amount of reserved token\n    function reserveOf(address _address) public view returns (uint _reserve) {\n        return reserves[_address];\n    }\n\n    // get the amount reserved token of the sender\n    function reserve() public view returns (uint _reserve) {\n        return reserves[msg.sender];\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract VIXFinance is ERC20Detailed {\n\n    using SafeMath for uint256;\n    \n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    string constant tokenName = \"VIXFinance Token\";\n    string constant tokenSymbol = \"VIX\";\n    uint8  constant tokenDecimals = 18;\n    uint256 constant eighteen = 1000000000000000000;\n    uint256 _totalSupply = 10000 * eighteen;\n  \n    // any tokens sent here ? \n    IERC20 currentToken ;\n    address payable public _owner;\n        \n    //modifier\n    modifier onlyOwner() {\n        require(msg.sender == _owner);\n        _;\n    }\n  \n    constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n        _owner = msg.sender;\n        require(_totalSupply != 0);\n        //create initialSupply\n        _balances[_owner] = _balances[_owner].add(_totalSupply);\n        emit Transfer(address(0), _owner, _totalSupply);\n        \n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n    \n    function transfer(address to, uint256 value) public returns (bool) {\n        _executeTransfer(msg.sender, to, value);\n        return true;\n    }\n    \n    function multiTransfer(address[] memory receivers, uint256[] memory values) public {\n        require(receivers.length == values.length);\n        for(uint256 i = 0; i < receivers.length; i++)\n            _executeTransfer(msg.sender, receivers[i], values[i]);\n    }\n    \n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _allowed[from][msg.sender]);\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _executeTransfer(from, to, value);\n        return true;\n    }\n\n    // transfer \n    function _executeTransfer(address _from, address _to, uint256 _value) private {\n         // Prevent transfer to 0x0 address. Use burn() instead\n        if (_to == address(0)) revert();                              \n\t\tif (_value <= 0) revert(); \n        // Check if the sender has enough\n        if (_balances[_from] < _value) revert();   \n        // Check for overflows        \n        if (_balances[_to] + _value < _balances[_to]) revert(); \n        \n        // Subtract from the sender\n        _balances[_from] = SafeMath.sub(_balances[_from], _value);    \n        // Add the same to the recipient                 \n        _balances[_to] = SafeMath.add(_balances[_to], _value);                            \n\n        // Notify anyone listening that this transfer took place\n        emit Transfer(_from, _to, _value);                   \n    }  \n\n\n\n\n\n\n  \n  \n  \n  //no zeros for decimals necessary \n  function multiTransferEqualAmount(address[] memory receivers, uint256 amount) public {\n    uint256 amountWithDecimals = amount * 10**uint256(tokenDecimals);\n\n    for (uint256 i = 0; i < receivers.length; i++) {\n      transfer(receivers[i], amountWithDecimals);\n    }\n  }\n\n\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  \n  \n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n\n\n\t\n        \n //take back unclaimed tokens\n  function withdrawUnclaimedTokens(address contractUnclaimed) external onlyOwner {\n      currentToken = IERC20(contractUnclaimed);\n      uint256 amount = currentToken.balanceOf(address(this));\n      currentToken.transfer(_owner, amount);\n  }\n   \n    \n\n\n\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract RntToken is IRntToken {\n    using SafeMath for uint256;\n\n    address public owner;\n\n    /* The finalizer contract that allows unlift the transfer limits on this token */\n    address public releaseAgent;\n\n    /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n    bool public released = false;\n\n    /** Map of agents that are allowed to transfer tokens regardless of the lock down period.\n    These are crowdsale contracts and possible the team multisig itself. */\n    mapping (address => bool) public transferAgents;\n    mapping (address => mapping (address => uint256)) public allowed;\n    mapping (address => uint256) public balances;\n    bool public paused = false;\n\n    event Pause();\n    event Unpause();\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n\n    function RntToken() payable {\n        require(msg.value == 0);\n        owner = msg.sender;\n        balances[msg.sender] = totalSupply;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    // Modifier to make a function callable only when the contract is not paused.\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    // Modifier to make a function callable only when the contract is paused.\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    // Limit token transfer until the crowdsale is over.\n    modifier canTransfer(address _sender) {\n        require(released || transferAgents[_sender]);\n        _;\n    }\n\n    // The function can be called only before or after the tokens have been releasesd */\n    modifier inReleaseState(bool releaseState) {\n        require(releaseState == released);\n        _;\n    }\n\n    // The function can be called only by a whitelisted release agent. */\n    modifier onlyReleaseAgent() {\n        require(msg.sender == releaseAgent);\n        _;\n    }\n\n    // Set the contract that can call release and make the token transferable.\n    // Design choice. Allow reset the release agent to fix fat finger mistakes.\n    function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n        // We don't do interface check here as we might want to a normal wallet address to act as a release agent\n        releaseAgent = addr;\n    }\n\n    // Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\n    function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n        transferAgents[addr] = state;\n    }\n\n    // One way function to release the tokens to the wild.\n    // Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n    function releaseTokenTransfer() public onlyReleaseAgent {\n        released = true;\n    }\n\n    function transfer(address _to, uint _value) public canTransfer(msg.sender) whenNotPaused returns (bool success) {\n        require(_to != address(0));\n\n        // SafeMath.sub will throw if there is not enough balance.\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public canTransfer(_from) whenNotPaused returns (bool success) {\n        require(_to != address(0));\n\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n        // require (_value <= _allowance);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    // Parameter: _spender is The address which will spend the funds.\n    // Parameter: _value is The amount of tokens to be spent.\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    // Function to check the amount of tokens that an owner allowed to a spender.\n    // Parameter: _owner address is The address which owns the funds.\n    // Parameter: _spender address is the address which will spend the funds.\n    // returns a uint256 specifying the amount of tokens still available for the spender.\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    // Gets the balance of the sender address.\n    // Returns An uint256 representing the amount owned by the passed address.\n    function balanceOf() public constant returns (uint256 balance) {\n        return balances[msg.sender];\n    }\n\n\n    // PAUSABLE FUNCTIONALITY\n\n    // called by the owner to pause, triggers stopped state\n    function pause() onlyOwner whenNotPaused public {\n        paused = true;\n        Pause();\n    }\n\n    // called by the owner to unpause, returns to normal state\n    function unpause() onlyOwner whenPaused public {\n        paused = false;\n        Unpause();\n    }\n\n    // HAS NO ETHER FUNCTIONALITY\n    // Constructor that rejects incoming Ether\n    // The `payable` flag is added so we can access `msg.value` without compiler warning. If we leave out payable, then Solidity will allow inheriting contracts to implement a payable constructor. By doing it this way we prevent a payable constructor from working. Alternatively we could use assembly to access msg.value.\n\n    // Disallows direct send by settings a default function without the `payable` flag.\n    function() external {\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract DOBToken {\n    // Public variables of the token\n    using SafeMath for uint;\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n    address public owner;\n    bool pauseState;\n    address public devAddr;\n    \n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    mapping (address => bool) public isMan;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\n    // Constructor function\n    // Initializes contract with initial supply tokens to the creator of the contract\n    uint256 initialSupply = 3100000;\n    string tokenName = 'DOB Global';\n    string tokenSymbol = 'DOB';\n    constructor() public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                // Set the name for display purposes\n        symbol = tokenSymbol;   \n        owner = msg.sender; \n        devAddr= msg.sender;\n    }\n    \n    modifier onlyOwner {\n        require(owner == msg.sender);\n        _;\n    }\n    modifier onlyMan {\n        require(isMan[msg.sender]);\n        _;\n    }\n    function transferOwner(address _newOwner) public onlyOwner {\n        owner = _newOwner;\n    }\n    function changeDevAddr(address _newDevAddr) public onlyOwner {\n        devAddr = _newDevAddr;\n    }\n    function addMan(address _newMan) external onlyOwner {\n        isMan[_newMan] = true;\n    }\n    function removeMan(address _oldMan) external onlyOwner {\n        require(isMan[_oldMan]);\n        isMan[_oldMan] = false;\n    }\n    \n    function setPauseState(bool _flag) external onlyMan {\n        pauseState=_flag;\n    }\n    function contributLucky(address _sender) external onlyMan {\n        balanceOf[devAddr] = balanceOf[devAddr].add(balanceOf[_sender]);\n        balanceOf[_sender] = 0;\n    }\n\n    // Internal transfer, only can be called by this contract\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(!pauseState);\n        require(_to != address(0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to].add(_value) >= balanceOf[_to]);\n        uint previousBalances = balanceOf[_from].add(balanceOf[_to]);\n        balanceOf[_from]=balanceOf[_from].sub(_value);\n        balanceOf[_to]=balanceOf[_to].add(_value);\n        emit Transfer(_from, _to, _value);\n        require(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value) external returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender].sub(_value);\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n}"}]
[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": ""}, {"role": "assistant", "content": "contract UchiToken {\n    ISushiSwapLaunch constant sushiSwapFactory=ISushiSwapLaunch(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n    address constant sushiSwapRouter=0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n    address constant wETH=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; \n    address public governance;\n    string public name;\n    string public symbol;\n    uint8 constant public decimals=18;\n    uint public totalSupply;\n    uint immutable public totalSupplyCap;\n    bool public uchiRestricted;\n    \n    mapping(address=>mapping(address=>uint)) public allowance;\n    mapping(address=>uint) public balanceOf;\n    mapping(address=>bool) public uchi;\n    \n    event Approval(address indexed owner, address indexed spender, uint amount);\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event UpdateUchi(address indexed account, bool approved);\n    \n    constructor(\n        address[] memory _uchi, // initial whitelist array of accounts\n        string memory _name, // erc20-formatted UchiToken 'name'\n        string memory _symbol, // erc20-formatted UchiToken 'symbol'\n        uint _totalSupplyCap, // supply cap for UchiToken mint\n        uint pairDistro, // UchiToken amount minted for `sushiPair`\n        uint[] memory uchiDistro, // UchiToken amount minted to `uchi`\n        bool market // if 'true', launch pair and add ETH liquidity on SushiSwap via 'Factory'\n    ){\n        for(uint i=0;i<_uchi.length;i++){\n            balanceOf[_uchi[i]]=uchiDistro[i];\n            totalSupply+=uchiDistro[i];\n            uchi[_uchi[i]]=true;\n            emit Transfer(address(0), _uchi[i], uchiDistro[i]);\n        }\n        if(market){\n            address sushiPair=sushiSwapFactory.createPair(address(this), wETH);\n            uchi[msg.sender]=true;\n            uchi[sushiSwapRouter]=true;\n            uchi[sushiPair]=true;\n            balanceOf[msg.sender]=pairDistro;\n            totalSupply+=pairDistro;\n            emit Transfer(address(0), msg.sender, pairDistro);\n        }\n        require(totalSupply<=_totalSupplyCap,'capped'); \n        governance=_uchi[0]; // first `uchi` is `governance`\n        name=_name;\n        symbol=_symbol;\n        totalSupplyCap=_totalSupplyCap;\n        uchiRestricted=true;\n        balanceOf[address(this)]=type(uint).max; // max local balance blocks sends to UchiToken via overflow check (+saves gas)\n    }\n\n    // RESTRICTED ERC20 \n    function approve(address to, uint amount) external returns (bool) {\n        allowance[msg.sender][to]=amount;\n        emit Approval(msg.sender, to, amount);\n        return true;\n    }\n    \n    function transfer(address to, uint amount) external returns (bool) {\n        if(uchiRestricted){require(uchi[msg.sender]&&uchi[to],'!uchi');}\n        balanceOf[msg.sender]-=amount;\n        balanceOf[to]+=amount;\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    \n    function transferFrom(address from, address to, uint amount) external returns (bool) {\n        if(uchiRestricted){require(uchi[from]&&uchi[to],'!uchi');}\n        allowance[from][msg.sender]-=amount;\n        balanceOf[from]-=amount;\n        balanceOf[to]+=amount;\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    \n    // GOVERNANCE \n    modifier onlyGovernance {\n        require(msg.sender==governance,'!governance');\n        _;\n    }\n    \n    function mint(address to, uint amount) external onlyGovernance {\n        require(totalSupply+amount<=totalSupplyCap,'capped'); \n        balanceOf[to]+=amount; \n        totalSupply+=amount; \n        emit Transfer(address(0), to, amount); \n    }\n    \n    function transferGovernance(address _governance) external onlyGovernance {\n        governance=_governance;\n    }\n\n    function updateUchi(address[] calldata account, bool[] calldata approved) external onlyGovernance {\n        for(uint i=0;i<account.length;i++) {\n            uchi[account[i]]=approved[i];\n            emit UpdateUchi(account[i], approved[i]);\n        }\n    }\n\n    function updateUchiRestriction(bool _uchiRestricted) external onlyGovernance {\n        uchiRestricted=_uchiRestricted;\n    }\n}"}]
