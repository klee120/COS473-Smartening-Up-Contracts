[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "\nGenerate a BLONDCOIN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function BLONDCOIN() public:\n- Constructor \n\n2. function totalSupply() public constant returns (uint):\n- Total supply \n\n3. function balanceOf(address tokenOwner) public constant returns (uint balance):\n- Get the token balance for account tokenOwner \n\n4. function transfer(address to, uint tokens) public returns (bool success):\n- Transfer the balance from token owner's account to to account  Owner's account must have sufficient balance to transfer  0 value transfers are allowed \n\n5. function approve(address spender, uint tokens) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. https:github.comethereumEIPsblobmasterEIPSeip20.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces  \n\n6. function transferFrom(address from, address to, uint tokens) public returns (bool success):\n- Transfer tokens from the 'from' account to the 'to' account  The calling account must already have sufficient tokens approve(...)d for spending from the 'from' account and 'from' account must have sufficient balance to transfer, spender must have sufficient allowance to transfer, and 0 value transfers are allowed.\n\n7. function allowance(address tokenOwner, address spender) public constant returns (uint remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n\n8. function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. The spender contract function receiveApproval(...) is then executed \n\n9. function () public payable:\n- Don't accept ETH \n\n10. function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens \n\n"}, {"role": "assistant", "content": "contract BLONDCOIN is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function BLONDCOIN() public {\r\n        symbol = \"BLO\";\r\n        name = \"BLONDCOIN\";\r\n        decimals = 18;\r\n        _totalSupply = 45000000000000000000000000;\r\n        balances[0xff72c65aa864774aa029114c0f15a44bfc6bc4e0] = _totalSupply;\r\n        Transfer(address(0), 0xff72c65aa864774aa029114c0f15a44bfc6bc4e0, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]

[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."},{"role": "user", "content": "\nGenerate a NFTCheese smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: ERC1155 token for NFT Cheese\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n\n1. function getPrice(uint256 amount) public  view returns (uint256): \n- retrieve price for multiple NFTs\n- Parameter:  amount the amount of NFTs to get price for\n \n2. function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256): \n- get price at position of the NFT token by ID\n- Parameter:  position positiong to check the price at\n \n3. function whitelistMint(uint256 amount) external payable whenNotPaused: \n- purchase NFTs during whitelist mint\n- Parameter:  amount the amount of cards to purchase\n \n4. function publicMint(uint256 amount) external payable whenNotPaused: \n- mint NFTs during public mint\n- Parameter:  amount the amount of tokens to mint\n \n5. function mint(uint256 amount) private: \n- global mint function used in early access and public sale\n- Parameter:  amount the amount of tokens to mint\n \n6. function editWindows(uint256 _publicWindowOpens, uint256 _whitelistWindowOpens) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit windows\n- Parameter:  _publicWindowOpens UNIX timestamp for purchasing public window time\n- Parameter:  _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\n \n7. function editMintSettings(uint256 _priceInc, uint256 _incrementNumber, uint256 _startingPrice) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit mint settings\n- Parameter:  _priceInc how much the price increments\n- Parameter:  _incrementNumber per how many tokens to increase price\n- Parameter:  _startingPrice starting price of the token\n \n8. function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE): \n- adds addresses into a whitelist\n- Parameter:  addresses an array of addresses to add to whitelist\n \n9. function isWhitelisted() external view returns (bool): \n- Return: true or false depending on whether it is whitelisted\n \n10 function uri(uint256 _id) public view override returns (string memory): \n- Return: the metadata uri for a given id\n- Parameter:  _id is the NFT id to return metadata for\n\n\n"}, {"role": "assistant", "content": "contract NFTCheese is AbstractERC1155Factory {\r\n\r\n    uint256 public constant ARTWORK = 0;\r\n    uint256 public _maxSupply = 333;\r\n    uint256 public _reserved = 33;\r\n\r\n    uint8 maxPerTx = 2;\r\n\r\n    uint256 public whitelistWindowOpens = 1644523200;\r\n    uint256 public publicWindowOpens    = 1644609600;\r\n\r\n    uint256 public priceInc = 100000000000000000;\r\n    uint256 public incrementNumber= 50;\r\n    uint256 public startingPrice = 50000000000000000;\r\n\r\n    mapping(address => bool) private whiteList; \r\n    mapping(address => uint256) public purchaseTxs;\r\n\r\n    constructor(\r\n        address[] memory _payees,\r\n        uint256[] memory _shares,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _uri\r\n        ) ERC1155(_uri) PaymentSplitter(_payees, _shares) {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(DEFAULT_ADMIN_ROLE, 0x5DeD00BE946085E7a523803596706593DbF9959b);\r\n        _mint(0x5DeD00BE946085E7a523803596706593DbF9959b, ARTWORK, 33, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice retrieve price for multiple NFTs\r\n    *\r\n    * @param amount the amount of NFTs to get price for\r\n    */\r\n    function getPrice(uint256 amount) public  view returns (uint256){\r\n        uint256 supply = totalSupply(ARTWORK) - _reserved;\r\n        uint totalCost = 0;\r\n        for (uint i = 0; i < amount; i++) {\r\n            totalCost += getCurrentPriceAtPosition(supply + i);\r\n        }\r\n        return totalCost;\r\n    }\r\n\r\n    /**\r\n    * @notice get price at position of the NFT token by ID\r\n    *\r\n    * @param position positiong to check the price at\r\n    */\r\n    function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256){\r\n        uint256 multiplier  = position/incrementNumber;\r\n        uint256 priceIncrease = multiplier * priceInc;\r\n        return priceIncrease + startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice purchase NFTs during whitelist mint\r\n    *\r\n    * @param amount the amount of cards to purchase\r\n    */\r\n    function whitelistMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= whitelistWindowOpens, \"Early access: window closed\");\r\n        require(whiteList[msg.sender], \"Sender not on the whitelist\");\r\n        require(purchaseTxs[msg.sender] + amount <= maxPerTx, \"Wallet mint limit\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice mint NFTs during public mint\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function publicMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= publicWindowOpens, \"Purchase: window closed\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice global mint function used in early access and public sale\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function mint(uint256 amount) private {\r\n        require(amount > 0, \"Need to request at least 1 NFT\");\r\n        require(totalSupply(ARTWORK) + amount <= _maxSupply, \"Exceeds maximum supply\");\r\n        require(msg.value >= getPrice(amount), \"Not enough ETH sent, check price\");\r\n\r\n        purchaseTxs[msg.sender] += amount;\r\n        _mint(msg.sender, ARTWORK, amount, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice edit windows\r\n    *\r\n    * @param _publicWindowOpens UNIX timestamp for purchasing public window time\r\n    * @param _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\r\n    */\r\n    function editWindows(\r\n        uint256 _publicWindowOpens,\r\n        uint256 _whitelistWindowOpens\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        require(\r\n            _publicWindowOpens > _whitelistWindowOpens,\r\n            \"window combination not allowed\"\r\n        );\r\n        publicWindowOpens = _publicWindowOpens;\r\n        whitelistWindowOpens = _whitelistWindowOpens;\r\n    }\r\n\r\n    /**\r\n    * @notice edit mint settings\r\n    *\r\n    * @param _priceInc how much the price increments\r\n    * @param _incrementNumber per how many tokens to increase price\r\n    * @param _startingPrice starting price of the token\r\n    */\r\n    function editMintSettings(\r\n        uint256 _priceInc,\r\n        uint256 _incrementNumber,\r\n        uint256 _startingPrice\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        priceInc = _priceInc;\r\n        incrementNumber = _incrementNumber;\r\n        startingPrice = _startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice adds addresses into a whitelist\r\n    *\r\n    * @param addresses an array of addresses to add to whitelist\r\n    */\r\n    function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            whiteList[addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice returns true or false depending on \r\n    */\r\n    function isWhitelisted() external view  returns (bool) {\r\n        return whiteList[msg.sender];\r\n    }\r\n\r\n    /**\r\n    * @notice returns the metadata uri for a given id\r\n    *\r\n    * @param _id the NFT id to return metadata for\r\n    */\r\n    function uri(uint256 _id) public view override returns (string memory) {\r\n        require(exists(_id), \"URI: nonexistent token\");\r\n\r\n        return string(abi.encodePacked(super.uri(_id), Strings.toString(_id), \".json\"));\r\n    }\r\n}"}]

[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}
{"role": "user", "content": "\nGenerate a svb smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: This Solidity smart contract, named \"svb\", manages a virtual currency called \"SVB\" within the Silver ecosystem. It enables the creation, destruction, and transfer of SVB tokens, while also incorporating features like demurring fees and transfer fees to incentivize certain behaviors and discourage others. The contract is controlled by an owner who has the authority to adjust parameters and manage the currency's lifecycle, including issuing new tokens, destroying existing ones, and ultimately shutting down the contract.\n\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function svb(uint supply):\n- if supply provided is 0, then default assigned\n\n2. function changeDemurringFeeOwner(address addr) onlyOwner:\n\n3. function changeTransferFeeOwner(address addr) onlyOwner:\n\n4. function balanceOf(address addr) constant returns (uint):\n\n5. function chargeDemurringFee(address addr) internal:\n- charge demurring fee for previuos period. fee is not applied to owners\n\n6. function chargeTransferFee(address addr, uint amount) internal returns (uint):\n- fee is not applied to owners\n\n7. function transfer(address to, uint amount) returns (bool):\n\n8. function transferFrom(address from, address to, uint amount) returns (bool):\n\n9. function approve(address spender, uint amount) returns (bool):\n\n10. function allowance(address addr, address spender) constant returns (uint):\n\n11. function setTransferFee(uint32 numinator, uint32 denuminator) onlyOwner:\n\n12. function setDemurringFee(uint32 numinator, uint32 denuminator) onlyOwner:\n\n13. function sell(address to, uint amount) onlyOwner:\n\n14. function issue(uint amount) onlyOwner:\n- issue new coins\n\n15. function destroy(uint amount) onlyOwner:\n- destroy existing coins\n\n16. function kill() onlyOwner:\n- kill contract only if all wallets are empty\n\n17. function () payable:\n- payments ar reverted back\n\n\n"}
{"role": "assistant", "content": "contract svb {\r\n    // totalSupply is zero by default, owner can issue and destroy coins any amount any time\r\n    uint constant totalSupplyDefault = 0;\r\n\r\n    string public constant symbol = \"SVB\";\r\n    string public constant name = \"Silver\";\r\n    uint8 public constant decimals = 5;\r\n    // minimum fee is 0.00001\r\n    uint32 public constant minFee = 1;\r\n    uint32 public constant minTransfer = 10;\r\n\r\n    uint public totalSupply = 0;\r\n\r\n    // transfer fee default = 0.17% (0.0017)\r\n    uint32 public transferFeeNum = 17;\r\n    uint32 public transferFeeDenum = 10000;\r\n\r\n    // demurring fee default = 0,7 % per year\r\n    // 0.007 per year = 0.007 / 365 per day = 0.000019178 per day\r\n    // 0.000019178 / (24*60) per minute = 0.000000013 per minute\r\n    uint32 public demurringFeeNum = 13;\r\n    uint32 public demurringFeeDenum = 1000000000;\r\n\r\n    \r\n    // Owner of this contract\r\n    address public owner;\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n    address public demurringFeeOwner;\r\n    address public transferFeeOwner;\r\n \r\n    // Balances for each account\r\n    mapping(address => uint) balances;\r\n\r\n    // demurring fee deposit payed date for each account\r\n    mapping(address => uint64) timestamps;\r\n \r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint)) allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from , address indexed to , uint256 value);\r\n    event DemurringFee(address indexed to , uint256 value);\r\n    event TransferFee(address indexed to , uint256 value);\r\n\r\n    // if supply provided is 0, then default assigned\r\n    function svb(uint supply) {\r\n        if (supply > 0) {\r\n            totalSupply = supply;\r\n        } else {\r\n            totalSupply = totalSupplyDefault;\r\n        }\r\n        owner = msg.sender;\r\n        demurringFeeOwner = owner;\r\n        transferFeeOwner = owner;\r\n        balances[this] = totalSupply;\r\n    }\r\n\r\n    function changeDemurringFeeOwner(address addr) onlyOwner {\r\n        demurringFeeOwner = addr;\r\n    }\r\n    function changeTransferFeeOwner(address addr) onlyOwner {\r\n        transferFeeOwner = addr;\r\n    }\r\n \r\n    function balanceOf(address addr) constant returns (uint) {\r\n        return balances[addr];\r\n    }\r\n\r\n    // charge demurring fee for previuos period\r\n    // fee is not applied to owners\r\n    function chargeDemurringFee(address addr) internal {\r\n        if (addr != owner && addr != transferFeeOwner && addr != demurringFeeOwner && balances[addr] > 0 && now > timestamps[addr] + 60) {\r\n            var mins = (now - timestamps[addr]) / 60;\r\n            var fee = balances[addr] * mins * demurringFeeNum / demurringFeeDenum;\r\n            if (fee < minFee) {\r\n                fee = minFee;\r\n            } else if (fee > balances[addr]) {\r\n                fee = balances[addr];\r\n            }\r\n\r\n            balances[addr] -= fee;\r\n            balances[demurringFeeOwner] += fee;\r\n            Transfer(addr, demurringFeeOwner, fee);\r\n            DemurringFee(addr, fee);\r\n\r\n            timestamps[addr] = uint64(now);\r\n        }\r\n    }\r\n\r\n    // fee is not applied to owners\r\n    function chargeTransferFee(address addr, uint amount) internal returns (uint) {\r\n        if (addr != owner && addr != transferFeeOwner && addr != demurringFeeOwner && balances[addr] > 0) {\r\n            var fee = amount * transferFeeNum / transferFeeDenum;\r\n            if (fee < minFee) {\r\n                fee = minFee;\r\n            } else if (fee > balances[addr]) {\r\n                fee = balances[addr];\r\n            }\r\n            amount = amount - fee;\r\n\r\n            balances[addr] -= fee;\r\n            balances[transferFeeOwner] += fee;\r\n            Transfer(addr, transferFeeOwner, fee);\r\n            TransferFee(addr, fee);\r\n        }\r\n        return amount;\r\n    }\r\n \r\n    function transfer(address to, uint amount) returns (bool) {\r\n        if (amount >= minTransfer\r\n            && balances[msg.sender] >= amount\r\n            && balances[to] + amount > balances[to]\r\n            ) {\r\n                chargeDemurringFee(msg.sender);\r\n\r\n                if (balances[msg.sender] >= amount) {\r\n                    amount = chargeTransferFee(msg.sender, amount);\r\n\r\n                    // charge recepient with demurring fee\r\n                    if (balances[to] > 0) {\r\n                        chargeDemurringFee(to);\r\n                    } else {\r\n                        timestamps[to] = uint64(now);\r\n                    }\r\n\r\n                    balances[msg.sender] -= amount;\r\n                    balances[to] += amount;\r\n                    Transfer(msg.sender, to, amount);\r\n                }\r\n                return true;\r\n          } else {\r\n              return false;\r\n          }\r\n    }\r\n \r\n    function transferFrom(address from, address to, uint amount) returns (bool) {\r\n        if ( amount >= minTransfer\r\n            && allowed[from][msg.sender] >= amount\r\n            && balances[from] >= amount\r\n            && balances[to] + amount > balances[to]\r\n            ) {\r\n                allowed[from][msg.sender] -= amount;\r\n\r\n                chargeDemurringFee(msg.sender);\r\n\r\n                if (balances[msg.sender] >= amount) {\r\n                    amount = chargeTransferFee(msg.sender, amount);\r\n\r\n                    // charge recepient with demurring fee\r\n                    if (balances[to] > 0) {\r\n                        chargeDemurringFee(to);\r\n                    } else {\r\n                        timestamps[to] = uint64(now);\r\n                    }\r\n\r\n                    balances[msg.sender] -= amount;\r\n                    balances[to] += amount;\r\n                    Transfer(msg.sender, to, amount);\r\n                }\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    function approve(address spender, uint amount) returns (bool) {\r\n        allowed[msg.sender][spender] = amount;\r\n        Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n \r\n    function allowance(address addr, address spender) constant returns (uint) {\r\n        return allowed[addr][spender];\r\n    }\r\n\r\n    function setTransferFee(uint32 numinator, uint32 denuminator) onlyOwner {\r\n        require(denuminator > 0 && numinator < denuminator);\r\n        transferFeeNum = numinator;\r\n        transferFeeDenum = denuminator;\r\n    }\r\n\r\n    function setDemurringFee(uint32 numinator, uint32 denuminator) onlyOwner {\r\n        require(denuminator > 0 && numinator < denuminator);\r\n        demurringFeeNum = numinator;\r\n        demurringFeeDenum = denuminator;\r\n    }\r\n\r\n    function sell(address to, uint amount) onlyOwner {\r\n        require(amount > minTransfer && balances[this] >= amount);\r\n\r\n        // charge recepient with demurring fee\r\n        if (balances[to] > 0) {\r\n            chargeDemurringFee(to);\r\n        } else {\r\n            timestamps[to] = uint64(now);\r\n        }\r\n        balances[this] -= amount;\r\n        balances[to] += amount;\r\n        Transfer(this, to, amount);\r\n    }\r\n\r\n    // issue new coins\r\n    function issue(uint amount) onlyOwner {\r\n         if (totalSupply + amount > totalSupply) {\r\n             totalSupply += amount;\r\n             balances[this] += amount;\r\n         }\r\n    }\r\n\r\n    // destroy existing coins\r\n    function destroy(uint amount) onlyOwner {\r\n          require(amount>0 && balances[this] >= amount);\r\n          balances[this] -= amount;\r\n          totalSupply -= amount;\r\n    }\r\n\r\n    // kill contract only if all wallets are empty\r\n    function kill() onlyOwner {\r\n        require (totalSupply == 0);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    // payments ar reverted back\r\n    function () payable {\r\n        revert();\r\n    }\r\n}"}]

