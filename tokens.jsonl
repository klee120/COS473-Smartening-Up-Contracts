{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a BLONDCOIN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function BLONDCOIN() public:\n- Constructor \n\n2. function totalSupply() public constant returns (uint):\n- Total supply \n\n3. function balanceOf(address tokenOwner) public constant returns (uint balance):\n- Get the token balance for account tokenOwner \n\n4. function transfer(address to, uint tokens) public returns (bool success):\n- Transfer the balance from token owner's account to to account  Owner's account must have sufficient balance to transfer  0 value transfers are allowed \n\n5. function approve(address spender, uint tokens) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. https:github.comethereumEIPsblobmasterEIPSeip20.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces  \n\n6. function transferFrom(address from, address to, uint tokens) public returns (bool success):\n- Transfer tokens from the 'from' account to the 'to' account  The calling account must already have sufficient tokens approve(...)d for spending from the 'from' account and 'from' account must have sufficient balance to transfer, spender must have sufficient allowance to transfer, and 0 value transfers are allowed.\n\n7. function allowance(address tokenOwner, address spender) public constant returns (uint remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n\n8. function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. The spender contract function receiveApproval(...) is then executed \n\n9. function () public payable:\n- Don't accept ETH \n\n10. function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens \n\n"}, {"role": "assistant", "content": "contract BLONDCOIN is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function BLONDCOIN() public {\r\n        symbol = \"BLO\";\r\n        name = \"BLONDCOIN\";\r\n        decimals = 18;\r\n        _totalSupply = 45000000000000000000000000;\r\n        balances[0xff72c65aa864774aa029114c0f15a44bfc6bc4e0] = _totalSupply;\r\n        Transfer(address(0), 0xff72c65aa864774aa029114c0f15a44bfc6bc4e0, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a NFTCheese smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: ERC1155 token for NFT Cheese\n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n\n1. function getPrice(uint256 amount) public  view returns (uint256): \n- retrieve price for multiple NFTs\n- Parameter:  amount the amount of NFTs to get price for\n \n2. function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256): \n- get price at position of the NFT token by ID\n- Parameter:  position positiong to check the price at\n \n3. function whitelistMint(uint256 amount) external payable whenNotPaused: \n- purchase NFTs during whitelist mint\n- Parameter:  amount the amount of cards to purchase\n \n4. function publicMint(uint256 amount) external payable whenNotPaused: \n- mint NFTs during public mint\n- Parameter:  amount the amount of tokens to mint\n \n5. function mint(uint256 amount) private: \n- global mint function used in early access and public sale\n- Parameter:  amount the amount of tokens to mint\n \n6. function editWindows(uint256 _publicWindowOpens, uint256 _whitelistWindowOpens) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit windows\n- Parameter:  _publicWindowOpens UNIX timestamp for purchasing public window time\n- Parameter:  _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\n \n7. function editMintSettings(uint256 _priceInc, uint256 _incrementNumber, uint256 _startingPrice) external onlyRole(DEFAULT_ADMIN_ROLE): \n- edit mint settings\n- Parameter:  _priceInc how much the price increments\n- Parameter:  _incrementNumber per how many tokens to increase price\n- Parameter:  _startingPrice starting price of the token\n \n8. function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE): \n- adds addresses into a whitelist\n- Parameter:  addresses an array of addresses to add to whitelist\n \n9. function isWhitelisted() external view returns (bool): \n- Return: true or false depending on whether it is whitelisted\n \n10 function uri(uint256 _id) public view override returns (string memory): \n- Return: the metadata uri for a given id\n- Parameter:  _id is the NFT id to return metadata for\n\n\n"}, {"role": "assistant", "content": "contract NFTCheese is AbstractERC1155Factory {\r\n\r\n    uint256 public constant ARTWORK = 0;\r\n    uint256 public _maxSupply = 333;\r\n    uint256 public _reserved = 33;\r\n\r\n    uint8 maxPerTx = 2;\r\n\r\n    uint256 public whitelistWindowOpens = 1644523200;\r\n    uint256 public publicWindowOpens    = 1644609600;\r\n\r\n    uint256 public priceInc = 100000000000000000;\r\n    uint256 public incrementNumber= 50;\r\n    uint256 public startingPrice = 50000000000000000;\r\n\r\n    mapping(address => bool) private whiteList; \r\n    mapping(address => uint256) public purchaseTxs;\r\n\r\n    constructor(\r\n        address[] memory _payees,\r\n        uint256[] memory _shares,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _uri\r\n        ) ERC1155(_uri) PaymentSplitter(_payees, _shares) {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(DEFAULT_ADMIN_ROLE, 0x5DeD00BE946085E7a523803596706593DbF9959b);\r\n        _mint(0x5DeD00BE946085E7a523803596706593DbF9959b, ARTWORK, 33, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice retrieve price for multiple NFTs\r\n    *\r\n    * @param amount the amount of NFTs to get price for\r\n    */\r\n    function getPrice(uint256 amount) public  view returns (uint256){\r\n        uint256 supply = totalSupply(ARTWORK) - _reserved;\r\n        uint totalCost = 0;\r\n        for (uint i = 0; i < amount; i++) {\r\n            totalCost += getCurrentPriceAtPosition(supply + i);\r\n        }\r\n        return totalCost;\r\n    }\r\n\r\n    /**\r\n    * @notice get price at position of the NFT token by ID\r\n    *\r\n    * @param position positiong to check the price at\r\n    */\r\n    function getCurrentPriceAtPosition(uint256 position) public  view returns (uint256){\r\n        uint256 multiplier  = position/incrementNumber;\r\n        uint256 priceIncrease = multiplier * priceInc;\r\n        return priceIncrease + startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice purchase NFTs during whitelist mint\r\n    *\r\n    * @param amount the amount of cards to purchase\r\n    */\r\n    function whitelistMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= whitelistWindowOpens, \"Early access: window closed\");\r\n        require(whiteList[msg.sender], \"Sender not on the whitelist\");\r\n        require(purchaseTxs[msg.sender] + amount <= maxPerTx, \"Wallet mint limit\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice mint NFTs during public mint\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function publicMint(uint256 amount) external payable whenNotPaused {\r\n        require(block.timestamp >= publicWindowOpens, \"Purchase: window closed\");\r\n\r\n        mint(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice global mint function used in early access and public sale\r\n    *\r\n    * @param amount the amount of tokens to mint\r\n    */\r\n    function mint(uint256 amount) private {\r\n        require(amount > 0, \"Need to request at least 1 NFT\");\r\n        require(totalSupply(ARTWORK) + amount <= _maxSupply, \"Exceeds maximum supply\");\r\n        require(msg.value >= getPrice(amount), \"Not enough ETH sent, check price\");\r\n\r\n        purchaseTxs[msg.sender] += amount;\r\n        _mint(msg.sender, ARTWORK, amount, \"\");\r\n    }\r\n\r\n    /**\r\n    * @notice edit windows\r\n    *\r\n    * @param _publicWindowOpens UNIX timestamp for purchasing public window time\r\n    * @param _whitelistWindowOpens UNIX timestamp for purchasing whitelist window time\r\n    */\r\n    function editWindows(\r\n        uint256 _publicWindowOpens,\r\n        uint256 _whitelistWindowOpens\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        require(\r\n            _publicWindowOpens > _whitelistWindowOpens,\r\n            \"window combination not allowed\"\r\n        );\r\n        publicWindowOpens = _publicWindowOpens;\r\n        whitelistWindowOpens = _whitelistWindowOpens;\r\n    }\r\n\r\n    /**\r\n    * @notice edit mint settings\r\n    *\r\n    * @param _priceInc how much the price increments\r\n    * @param _incrementNumber per how many tokens to increase price\r\n    * @param _startingPrice starting price of the token\r\n    */\r\n    function editMintSettings(\r\n        uint256 _priceInc,\r\n        uint256 _incrementNumber,\r\n        uint256 _startingPrice\r\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        priceInc = _priceInc;\r\n        incrementNumber = _incrementNumber;\r\n        startingPrice = _startingPrice;\r\n    }\r\n\r\n    /**\r\n    * @notice adds addresses into a whitelist\r\n    *\r\n    * @param addresses an array of addresses to add to whitelist\r\n    */\r\n    function setWhiteList(address[] calldata addresses ) external onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            whiteList[addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice returns true or false depending on \r\n    */\r\n    function isWhitelisted() external view  returns (bool) {\r\n        return whiteList[msg.sender];\r\n    }\r\n\r\n    /**\r\n    * @notice returns the metadata uri for a given id\r\n    *\r\n    * @param _id the NFT id to return metadata for\r\n    */\r\n    function uri(uint256 _id) public view override returns (string memory) {\r\n        require(exists(_id), \"URI: nonexistent token\");\r\n\r\n        return string(abi.encodePacked(super.uri(_id), Strings.toString(_id), \".json\"));\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a svb smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: This Solidity smart contract, named \"svb\", manages a virtual currency called \"SVB\" within the Silver ecosystem. It enables the creation, destruction, and transfer of SVB tokens, while also incorporating features like demurring fees and transfer fees to incentivize certain behaviors and discourage others. The contract is controlled by an owner who has the authority to adjust parameters and manage the currency's lifecycle, including issuing new tokens, destroying existing ones, and ultimately shutting down the contract.\n\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function svb(uint supply):\n- if supply provided is 0, then default assigned\n\n2. function changeDemurringFeeOwner(address addr) onlyOwner:\n\n3. function changeTransferFeeOwner(address addr) onlyOwner:\n\n4. function balanceOf(address addr) constant returns (uint):\n\n5. function chargeDemurringFee(address addr) internal:\n- charge demurring fee for previuos period. fee is not applied to owners\n\n6. function chargeTransferFee(address addr, uint amount) internal returns (uint):\n- fee is not applied to owners\n\n7. function transfer(address to, uint amount) returns (bool):\n\n8. function transferFrom(address from, address to, uint amount) returns (bool):\n\n9. function approve(address spender, uint amount) returns (bool):\n\n10. function allowance(address addr, address spender) constant returns (uint):\n\n11. function setTransferFee(uint32 numinator, uint32 denuminator) onlyOwner:\n\n12. function setDemurringFee(uint32 numinator, uint32 denuminator) onlyOwner:\n\n13. function sell(address to, uint amount) onlyOwner:\n\n14. function issue(uint amount) onlyOwner:\n- issue new coins\n\n15. function destroy(uint amount) onlyOwner:\n- destroy existing coins\n\n16. function kill() onlyOwner:\n- kill contract only if all wallets are empty\n\n17. function () payable:\n- payments ar reverted back\n\n\n"}, {"role": "assistant", "content": "contract svb {\r\n    // totalSupply is zero by default, owner can issue and destroy coins any amount any time\r\n    uint constant totalSupplyDefault = 0;\r\n\r\n    string public constant symbol = \"SVB\";\r\n    string public constant name = \"Silver\";\r\n    uint8 public constant decimals = 5;\r\n    // minimum fee is 0.00001\r\n    uint32 public constant minFee = 1;\r\n    uint32 public constant minTransfer = 10;\r\n\r\n    uint public totalSupply = 0;\r\n\r\n    // transfer fee default = 0.17% (0.0017)\r\n    uint32 public transferFeeNum = 17;\r\n    uint32 public transferFeeDenum = 10000;\r\n\r\n    // demurring fee default = 0,7 % per year\r\n    // 0.007 per year = 0.007 / 365 per day = 0.000019178 per day\r\n    // 0.000019178 / (24*60) per minute = 0.000000013 per minute\r\n    uint32 public demurringFeeNum = 13;\r\n    uint32 public demurringFeeDenum = 1000000000;\r\n\r\n    \r\n    // Owner of this contract\r\n    address public owner;\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n    address public demurringFeeOwner;\r\n    address public transferFeeOwner;\r\n \r\n    // Balances for each account\r\n    mapping(address => uint) balances;\r\n\r\n    // demurring fee deposit payed date for each account\r\n    mapping(address => uint64) timestamps;\r\n \r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint)) allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from , address indexed to , uint256 value);\r\n    event DemurringFee(address indexed to , uint256 value);\r\n    event TransferFee(address indexed to , uint256 value);\r\n\r\n    // if supply provided is 0, then default assigned\r\n    function svb(uint supply) {\r\n        if (supply > 0) {\r\n            totalSupply = supply;\r\n        } else {\r\n            totalSupply = totalSupplyDefault;\r\n        }\r\n        owner = msg.sender;\r\n        demurringFeeOwner = owner;\r\n        transferFeeOwner = owner;\r\n        balances[this] = totalSupply;\r\n    }\r\n\r\n    function changeDemurringFeeOwner(address addr) onlyOwner {\r\n        demurringFeeOwner = addr;\r\n    }\r\n    function changeTransferFeeOwner(address addr) onlyOwner {\r\n        transferFeeOwner = addr;\r\n    }\r\n \r\n    function balanceOf(address addr) constant returns (uint) {\r\n        return balances[addr];\r\n    }\r\n\r\n    // charge demurring fee for previuos period\r\n    // fee is not applied to owners\r\n    function chargeDemurringFee(address addr) internal {\r\n        if (addr != owner && addr != transferFeeOwner && addr != demurringFeeOwner && balances[addr] > 0 && now > timestamps[addr] + 60) {\r\n            var mins = (now - timestamps[addr]) / 60;\r\n            var fee = balances[addr] * mins * demurringFeeNum / demurringFeeDenum;\r\n            if (fee < minFee) {\r\n                fee = minFee;\r\n            } else if (fee > balances[addr]) {\r\n                fee = balances[addr];\r\n            }\r\n\r\n            balances[addr] -= fee;\r\n            balances[demurringFeeOwner] += fee;\r\n            Transfer(addr, demurringFeeOwner, fee);\r\n            DemurringFee(addr, fee);\r\n\r\n            timestamps[addr] = uint64(now);\r\n        }\r\n    }\r\n\r\n    // fee is not applied to owners\r\n    function chargeTransferFee(address addr, uint amount) internal returns (uint) {\r\n        if (addr != owner && addr != transferFeeOwner && addr != demurringFeeOwner && balances[addr] > 0) {\r\n            var fee = amount * transferFeeNum / transferFeeDenum;\r\n            if (fee < minFee) {\r\n                fee = minFee;\r\n            } else if (fee > balances[addr]) {\r\n                fee = balances[addr];\r\n            }\r\n            amount = amount - fee;\r\n\r\n            balances[addr] -= fee;\r\n            balances[transferFeeOwner] += fee;\r\n            Transfer(addr, transferFeeOwner, fee);\r\n            TransferFee(addr, fee);\r\n        }\r\n        return amount;\r\n    }\r\n \r\n    function transfer(address to, uint amount) returns (bool) {\r\n        if (amount >= minTransfer\r\n            && balances[msg.sender] >= amount\r\n            && balances[to] + amount > balances[to]\r\n            ) {\r\n                chargeDemurringFee(msg.sender);\r\n\r\n                if (balances[msg.sender] >= amount) {\r\n                    amount = chargeTransferFee(msg.sender, amount);\r\n\r\n                    // charge recepient with demurring fee\r\n                    if (balances[to] > 0) {\r\n                        chargeDemurringFee(to);\r\n                    } else {\r\n                        timestamps[to] = uint64(now);\r\n                    }\r\n\r\n                    balances[msg.sender] -= amount;\r\n                    balances[to] += amount;\r\n                    Transfer(msg.sender, to, amount);\r\n                }\r\n                return true;\r\n          } else {\r\n              return false;\r\n          }\r\n    }\r\n \r\n    function transferFrom(address from, address to, uint amount) returns (bool) {\r\n        if ( amount >= minTransfer\r\n            && allowed[from][msg.sender] >= amount\r\n            && balances[from] >= amount\r\n            && balances[to] + amount > balances[to]\r\n            ) {\r\n                allowed[from][msg.sender] -= amount;\r\n\r\n                chargeDemurringFee(msg.sender);\r\n\r\n                if (balances[msg.sender] >= amount) {\r\n                    amount = chargeTransferFee(msg.sender, amount);\r\n\r\n                    // charge recepient with demurring fee\r\n                    if (balances[to] > 0) {\r\n                        chargeDemurringFee(to);\r\n                    } else {\r\n                        timestamps[to] = uint64(now);\r\n                    }\r\n\r\n                    balances[msg.sender] -= amount;\r\n                    balances[to] += amount;\r\n                    Transfer(msg.sender, to, amount);\r\n                }\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    function approve(address spender, uint amount) returns (bool) {\r\n        allowed[msg.sender][spender] = amount;\r\n        Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n \r\n    function allowance(address addr, address spender) constant returns (uint) {\r\n        return allowed[addr][spender];\r\n    }\r\n\r\n    function setTransferFee(uint32 numinator, uint32 denuminator) onlyOwner {\r\n        require(denuminator > 0 && numinator < denuminator);\r\n        transferFeeNum = numinator;\r\n        transferFeeDenum = denuminator;\r\n    }\r\n\r\n    function setDemurringFee(uint32 numinator, uint32 denuminator) onlyOwner {\r\n        require(denuminator > 0 && numinator < denuminator);\r\n        demurringFeeNum = numinator;\r\n        demurringFeeDenum = denuminator;\r\n    }\r\n\r\n    function sell(address to, uint amount) onlyOwner {\r\n        require(amount > minTransfer && balances[this] >= amount);\r\n\r\n        // charge recepient with demurring fee\r\n        if (balances[to] > 0) {\r\n            chargeDemurringFee(to);\r\n        } else {\r\n            timestamps[to] = uint64(now);\r\n        }\r\n        balances[this] -= amount;\r\n        balances[to] += amount;\r\n        Transfer(this, to, amount);\r\n    }\r\n\r\n    // issue new coins\r\n    function issue(uint amount) onlyOwner {\r\n         if (totalSupply + amount > totalSupply) {\r\n             totalSupply += amount;\r\n             balances[this] += amount;\r\n         }\r\n    }\r\n\r\n    // destroy existing coins\r\n    function destroy(uint amount) onlyOwner {\r\n          require(amount>0 && balances[this] >= amount);\r\n          balances[this] -= amount;\r\n          totalSupply -= amount;\r\n    }\r\n\r\n    // kill contract only if all wallets are empty\r\n    function kill() onlyOwner {\r\n        require (totalSupply == 0);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    // payments ar reverted back\r\n    function () payable {\r\n        revert();\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a BasicToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: Basic version of StandardToken, with no allowances. \n \nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function transfer(address _to, uint256 _value) returns (bool): \n- transfer token for a specified address\n- Parameter: _to is the address to transfer to.\n- Parameter: _value is the amount to be transferred.\n \n2. function balanceOf(address _owner) constant returns (uint256 balance) : \n- Gets the balance of the specified address.\n- Parameter: _owner is the address to query the the balance of. \n- Return: An uint256 representing the amount owned by the passed address.\n \n3. function transferFrom(address _from, address _to, uint256 _value) returns (bool) : \n- Transfer tokens from one address to another\n- Parameter: _from address is the address which you want to send tokens from\n- Parameter: _to address is the address which you want to transfer to\n- Parameter: _value uint256 the amout of tokens to be transfered\n \n4. function approve(address _spender, uint256 _value) returns (bool) : \n- Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n- Parameter: _spender is the address which will spend the funds.\n- Parameter: _value is the amount of tokens to be spent.\n \n5. function allowance(address _owner, address _spender) constant returns (uint256 remaining) : \n- Function to check the amount of tokens that an owner allowed to a spender.\n- Parameter: _owner address is the address which owns the funds.\n- Parameter: _spender address is the address which will spend the funds.\n- Return: A uint256 specifing the amount of tokens still available for the spender.\n \n6. function Ownable() : \n- The Ownable constructor sets the original `owner` of the contract to the sender account.\n \n7. function transferOwnership(address newOwner) onlyOwner : \n- Allows the current owner to transfer control of the contract to a newOwner.\n- Parameter: newOwner is the address to transfer ownership to.\n \n8. function burn(uint _value) public : \n- Burns a specific amount of tokens.\n- Parameter: _value is the amount of token to be burned.\n"}, {"role": "assistant", "content": "contract BasicToken is ERC20Basic {\r\n    \r\n  using SafeMath for uint256;\r\n \r\n  mapping(address => uint256) balances;\r\n \r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n \r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n \r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate an asktoken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function asktoken() public:\n- Constructor \n\n2. function totalSupply() public constant returns (uint):\n- Total supply \n\n3. function balanceOf(address tokenOwner) public constant returns (uint balance):\n- Get the token balance for account tokenOwner \n\n4. function transfer(address to, uint tokens) public returns (bool success):\n- Transfer the balance from token owner's account to to account. Owner's account must have sufficient balance to transfer. 0 value transfers are allowed.\n\n5. function approve(address spender, uint tokens) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. https:github.comethereumEIPsblobmasterEIPSeip20tokenstandard.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces  \n\n6. function transferFrom(address from, address to, uint tokens) public returns (bool success):\n- Transfer tokens from the \"from\" account to the \"to\" account. The calling account must already have sufficient tokens approve(...)d for spending from the \"from\" account and \"from\" account must have sufficient balance to transfer, spender must have sufficient allowance to transfer, and 0 value transfers are allowed \n\n7. function allowance(address tokenOwner, address spender) public constant returns (uint remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n\n8. function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. The spender contract function receiveApproval(...) is then executed \n\n9. function () public payable:\n- Don't accept ETH \n\n10. function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens \n"}, {"role": "assistant", "content": "contract asktoken is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function asktoken() public {\r\n        symbol = \"ask\";\r\n        name = \"asktoken\";\r\n        decimals = 18;\r\n        _totalSupply = 100000000000000000000000000;\r\n        balances[0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A] = _totalSupply;\r\n        Transfer(address(0), 0xbb9afFb4Ff5e139997b3a006Be73F29f1A1F3C7A, _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a WatermelonBlockToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: The \"WatermelonBlockToken\" smart contract represents an ERC20 token named \"WatermelonBlock tokens\" (WMB). It includes features such as token transfers, allowances, and approvals. Additionally, it implements various token distribution mechanisms, including initial allocations to ICO participants, team members, seed investors, and emergency reserves, with some tokens subject to lockup periods.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n\n1. function balanceOf(address _owner) constant returns (uint balance):\n- What is the balance of a particular account?\n\n2. function allowance(address _owner, address _spender) constant returns (uint remaining):\n- Returns the amount which _spender is still allowed to withdraw from _owner\n\n3. function totalSupply() constant returns (uint totalSupply):\n- Get the total token supply\n\n4. function WatermelonBlockToken(address _icoAddr, address _teamAddr, address _emergencyAddr):\n- Initializes contract\n\n5. function transfer(address _to, uint _value) returns(bool):\n- Send some of your tokens to a given address\n\n6. function transferFrom(address _from, address _to, uint _value) returns(bool):\n- A contract or person attempts to get the tokens of somebody else. This is only allowed if the token holder approved.\n\n7. function approve(address _spender, uint _value) returns (bool): \n- Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n\n"}, {"role": "assistant", "content": "contract WatermelonBlockToken {\r\n    using SafeMath for uint;\r\n\r\n    // Public variables of the token\r\n    string constant public standard = \"ERC20\";\r\n    string constant public name = \"WatermelonBlock tokens\";\r\n    string constant public symbol = \"WMB\";\r\n    uint8 constant public decimals = 6;\r\n\r\n    uint _totalSupply = 400000000e6; // Total supply of 400 million WatermelonBlock tokens\r\n    uint constant public tokensICO = 240000000e6; // 60% token sale\r\n    uint constant public teamReserve = 80000000e6; // 20% team\r\n    uint constant public seedInvestorsReserve = 40000000e6; // 10% seed investors\r\n    uint constant public emergencyReserve = 40000000e6; // 10% emergency\r\n\r\n    address public icoAddr;\r\n    address public teamAddr;\r\n    address public emergencyAddr;\r\n\r\n    uint constant public lockStartTime = 1527811200; // 2018 June 1, Friday, 00:00:00\r\n    bool icoEnded;\r\n\r\n    struct Lockup\r\n    {\r\n        uint lockupTime;\r\n        uint lockupAmount;\r\n    }\r\n    Lockup lockup;\r\n    mapping(address=>Lockup) lockupParticipants;\r\n\r\n    uint[] lockupTeamSum = [80000000e6,70000000e6,60000000e6,50000000e6,40000000e6,30000000e6,20000000e6,10000000e6];\r\n    uint[] lockupTeamDate = [1535760000,1543622400,1551398400,1559347200,1567296000,1575158400,1583020800,1590969600];\r\n\r\n    // Array with all balances\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    // Public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed _owner, address indexed spender, uint value);\r\n    event Burned(uint amount);\r\n\r\n    // What is the balance of a particular account?\r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // Get the total token supply\r\n    function totalSupply() constant returns (uint totalSupply) {\r\n        totalSupply = _totalSupply;\r\n    }\r\n\r\n    // Initializes contract\r\n    function WatermelonBlockToken(address _icoAddr, address _teamAddr, address _emergencyAddr) {\r\n        icoAddr = _icoAddr;\r\n        teamAddr = _teamAddr;\r\n        emergencyAddr = _emergencyAddr;\r\n\r\n        balances[icoAddr] = tokensICO;\r\n        balances[teamAddr] = teamReserve;\r\n\r\n        // seed investors\r\n        address investor_1 = 0xF735e4a0A446ed52332AB891C46661cA4d9FD7b9;\r\n        balances[investor_1] = 20000000e6;\r\n        var lockupTime = lockStartTime.add(1 years);\r\n        lockup = Lockup({lockupTime:lockupTime,lockupAmount:balances[investor_1]});\r\n        lockupParticipants[investor_1] = lockup;\r\n\r\n        address investor_2 = 0x425207D7833737b62E76785A3Ab3f9dEce3953F5;\r\n        balances[investor_2] = 8000000e6;\r\n        lockup = Lockup({lockupTime:lockupTime,lockupAmount:balances[investor_2]});\r\n        lockupParticipants[investor_2] = lockup;\r\n\r\n        var leftover = seedInvestorsReserve.sub(balances[investor_1]).sub(balances[investor_2]);\r\n        balances[emergencyAddr] = emergencyReserve.add(leftover);\r\n    }\r\n\r\n    // Send some of your tokens to a given address\r\n    function transfer(address _to, uint _value) returns(bool) {\r\n        if (lockupParticipants[msg.sender].lockupAmount > 0) {\r\n            if (now < lockupParticipants[msg.sender].lockupTime) {\r\n                require(balances[msg.sender].sub(_value) >= lockupParticipants[msg.sender].lockupAmount);\r\n            }\r\n        }\r\n        if (msg.sender == teamAddr) {\r\n            for (uint i = 0; i < lockupTeamDate.length; i++) {\r\n                if (now < lockupTeamDate[i])\r\n                    require(balances[msg.sender].sub(_value) >= lockupTeamSum[i]);\r\n            }\r\n        }\r\n        balances[msg.sender] = balances[msg.sender].sub(_value); // Subtract from the sender\r\n        balances[_to] = balances[_to].add(_value); // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\r\n        return true;\r\n    }\r\n\t\r\n    // A contract or person attempts to get the tokens of somebody else.\r\n    // This is only allowed if the token holder approved.\r\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\r\n        if (lockupParticipants[_from].lockupAmount > 0) {\r\n            if (now < lockupParticipants[_from].lockupTime) {\r\n                require(balances[_from].sub(_value) >= lockupParticipants[_from].lockupAmount);\r\n            }\r\n        }\r\n        if (_from == teamAddr) {\r\n            for (uint i = 0; i < lockupTeamDate.length; i++) {\r\n                if (now < lockupTeamDate[i])\r\n                    require(balances[_from].sub(_value) >= lockupTeamSum[i]);\r\n            }\r\n        }\r\n        var _allowed = allowed[_from][msg.sender];\r\n        balances[_from] = balances[_from].sub(_value); // Subtract from the sender\r\n        balances[_to] = balances[_to].add(_value); // Add the same to the recipient\r\n        allowed[_from][msg.sender] = _allowed.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\t\r\n    // Approve the passed address to spend the specified amount of tokens\r\n    // on behalf of msg.sender.\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a KriptoPark smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description:  The \"KriptoPark\" smart contract is an ERC20 token contract named \"KriptoPark\" with the symbol \"PARK\". It allows token transfers, approvals, and allowances between Ethereum addresses. Additionally, it includes functionalities to handle approvals for spending tokens and to recover accidentally sent ERC20 tokens by the contract owner.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n\n1. function KriptoPark() public:\n- Constructor \n\n2. function totalSupply() public constant returns (uint):\n- Total supply \n\n3. function balanceOf(address tokenOwner) public constant returns (uint balance):\n- Get the token balance for account tokenOwner \n\n4. function transfer(address to, uint tokens) public returns (bool success):\n- Transfer the balance from token owner's account to to account. Owner's account must have sufficient balance to transfer. 0 value transfers are allowed \n\n5. function approve(address spender, uint tokens) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. https:github.comethereumEIPsblobmasterEIPSeip20tokenstandard.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces  \n\n6. function transferFrom(address from, address to, uint tokens) public returns (bool success):\n- Transfer tokens from the from account to the to account  The calling account must already have sufficient tokens approve(...)d for spending from the from account and  From account must have sufficient balance to transfer  Spender must have sufficient allowance to transfer  0 value transfers are allowed \n7. function allowance(address tokenOwner, address spender) public constant returns (uint remaining):\n- Returns: the amount of tokens approved by the owner that can be transferred to the spender's account \n\n8. function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success):\n- Token owner can approve for spender to transferFrom(...) tokens from the token owner's account. The spender contract function receiveApproval(...) is then executed \n\n9. function () public payable:\n- Don't accept ETH \n\n10. function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success):   Owner can transfer out any accidentally sent ERC20 tokens \n\n\n"}, {"role": "assistant", "content": "contract KriptoPark is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function KriptoPark() public {\r\n        symbol = \"PARK\";\r\n        name = \"KriptoPark\";\r\n        decimals = 18;\r\n        _totalSupply = 100000000000000000000000000;\r\n        balances[0xBCC379700A51bC482DF1AF1034d4431E32F613d2] = _totalSupply; //MEW address here\r\n        Transfer(address(0), 0xBCC379700A51bC482DF1AF1034d4431E32F613d2, _totalSupply);//MEW address here\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a BCBCOIN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: The \"BCBCOIN\" contract is an ERC20 token contract allowing for the creation of a customizable token with functionalities like transferring tokens, approving spending limits for others, and burning tokens irreversibly. It initializes with an initial supply of tokens to the contract creator and supports features such as allowance management and approval notifications through events.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function BCBCOIN(uint256 initialSupply, string tokenName, string tokenSymbol) public: \n- Constructor function. Initializes contract with initial supply tokens to the creator of the contract\n \n2. function _transfer(address _from, address _to, uint _value) internal: \n- Internal transfer, only can be called by this contract\n \n3. function transfer(address _to, uint256 _value) public : \n- Transfer tokens. Send `_value` tokens to `_to` from your account\n- Parameter:  _to is the address of the recipient\n- Parameter:  _value is the amount to send\n \n4. function transferFrom(address _from, address _to, uint256 _value) public returns (bool success): \n- Transfer tokens from other address. Send `_value` tokens to `_to` on behalf of `_from`\n- Parameter:  _from is The address of the sender\n- Parameter:  _to is The address of the recipient\n- Parameter:  _value is the amount to send\n \n5. function approve(address _spender, uint256 _value) public returns (bool success) : \n- Set allowance for other address. Allows `_spender` to spend no more than `_value` tokens on your behalf\n- Parameter:  _spender is the address authorized to spend\n- Parameter:  _value is the max amount they can spend\n \n6. function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) : - Set allowance for other address and notify. Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n- Parameter:  _spender is the address authorized to spend\n- Parameter:  _value is the max amount they can spend\n- Parameter:  _extraData is some extra information to send to the approved contract\n \n7. function burn(uint256 _value) public returns (bool success) :\n- Destroy tokens. Remove `_value` tokens from the system irreversibly\n- Parameter:  _value is the amount of money to burn\n \n8. function burnFrom(address _from, uint256 _value) public returns (bool success) : \n- Destroy tokens from other account. Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n- Parameter:  _from is the address of the sender\n- Parameter:  _value is the amount of money to burn\n \n\n\n\n"}, {"role": "assistant", "content": "contract BCBCOIN {\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    /**\r\n     * Constructor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    function BCBCOIN(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        string tokenSymbol\r\n    ) public {\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` on behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a Standard smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: A smart contract called Standard. An {ERC20} token, including ability for holders to burn (destroy) their tokens, a minter role that allows for token minting (creation), a pauser role that allows to stop all token transfers, and the liquidity protection.This contract uses {AccessControl} to lock permissioned functions using the different roles - head to its documentation for details.  The account that deploys the contract will be granted the minter and pauser roles, as well as the default admin role, which will let it grant both minter and pauser roles to other accounts. The contract will mint 100M with 1 decimals tokens on deploy as a total supply.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function _beforeTokenTransfer(address _from, address _to, uint _amount) internal override:\n\n2. function LPS_isAdmin() internal view override returns(bool):\n\n3. function liquidityProtectionService() internal pure override returns(address):\n\n4. function LPS_balanceOf(address _holder) internal view override returns(uint):\n- Expose balanceOf().\n\n5. function LPS_transfer(address _from, address _to, uint _value) internal override:\n- Expose internal transfer function.\n\n6. function protectionChecker() internal view override returns(bool):\n- How the protection gets disabled.\n\n7. function counterToken() internal pure override returns(address):  \n- This token will be pooled in pair with this\n\n8. function FirstBlockTrap_skip() internal pure override returns(bool):\n- Disable/Enable absolute amount of tokens bought trap. Per address per LiquidityAmountTrap_blocks.\n\n9. function LiquidityAmountTrap_skip() internal pure override returns(bool):  DisableEnable absolute amount of tokens bought trap. Per address per LiquidityAmountTrap_blocks.\n\n10. function LiquidityAmountTrap_blocks() internal pure override returns(uint8):\n\n11. function LiquidityAmountTrap_amount() internal pure override returns(uint128)\n\n12. function LiquidityPercentTrap_skip() internal pure override returns(bool):\n- Disable/Enable percent of remaining liquidity bought trap. Per address per block.\n\n12. function LiquidityPercentTrap_blocks() internal pure override returns(uint8):\n\n13. function LiquidityPercentTrap_percent() internal pure override returns(uint64):\n\n14. function LiquidityActivityTrap_skip() internal pure override returns(bool): \n- DisableEnable number of trades trap. Per block.\n\n15. function LiquidityActivityTrap_blocks() internal pure override returns(uint8):\n\n16. function LiquidityActivityTrap_count() internal pure override returns(uint8):\n\n17. function pause() external:\n- Pauses all token transfers. See {ERC20Pausable} and {Pausable_pause}. Requirements: the caller must have the `PAUSER_ROLE`. \n\n18. function unpause() external:\n- Unpauses all token transfers. See {ERC20Pausable} and {Pausable_unpause}. Requirements: the caller must have the `PAUSER_ROLE`. \n\n19. function burn(uint256 amount) public:\n- Destroys `amount` tokens from the caller. See {ERC20_burn}. Requirements: the caller must have the `BURNER_ROLE`. \n\n20. function burnFrom(address account, uint256 amount) public:\n- Destroys `amount` tokens from `account`, deducting from the caller's  allowance. See {ERC20_burn} and {ERC20allowance}. Requirements: the caller must have allowance for ``accounts``'s tokens of at least  `amount`. the caller must have the `BURNER_ROLE`. \n"}, {"role": "assistant", "content": "contract Standard is ERC20Pausable, AccessControlEnumerable, UsingLiquidityProtectionService {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n    constructor()\n    ERC20(\"Standard\", \"STND\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n        _setupRole(BURNER_ROLE, _msgSender());\n\n        _mint(msg.sender, 100000000 * 1e18);\n    }\n\n    function _beforeTokenTransfer(address _from, address _to, uint _amount) internal override {\n        super._beforeTokenTransfer(_from, _to, _amount);\n        LPS_beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function LPS_isAdmin() internal view override returns(bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n    function liquidityProtectionService() internal pure override returns(address) {\n        return 0xaabAe39230233d4FaFf04111EF08665880BD6dFb; // Replace with the correct address.\n    }\n    // Expose balanceOf().\n    function LPS_balanceOf(address _holder) internal view override returns(uint) {\n        return balanceOf(_holder);\n    }\n    // Expose internal transfer function.\n    function LPS_transfer(address _from, address _to, uint _value) internal override {\n        _transfer(_from, _to, _value);\n    }\n    // All the following overrides are optional, if you want to modify default behavior.\n\n    // How the protection gets disabled.\n    function protectionChecker() internal view override returns(bool) {\n        return ProtectionSwitch_timestamp(1620086399); // Switch off protection on Monday, May 3, 2021 11:59:59 PM.\n        // return ProtectionSwitch_block(13000000); // Switch off protection on block 13000000.\n        //return ProtectionSwitch_manual(); // Switch off protection by calling disableProtection(); from owner. Default.\n    }\n\n    // This token will be pooled in pair with:\n    function counterToken() internal pure override returns(address) {\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH\n    }\n\n    // Disable/Enable FirstBlockTrap\n    function FirstBlockTrap_skip() internal pure override returns(bool) {\n        return false;\n    }\n\n    // Disable/Enable absolute amount of tokens bought trap.\n    // Per address per LiquidityAmountTrap_blocks.\n    function LiquidityAmountTrap_skip() internal pure override returns(bool) {\n        return false;\n    }\n    function LiquidityAmountTrap_blocks() internal pure override returns(uint8) {\n        return 4;\n    }\n    function LiquidityAmountTrap_amount() internal pure override returns(uint128) {\n        return 20000 * 1e18; // Only valid for tokens with 18 decimals.\n    }\n\n    // Disable/Enable percent of remaining liquidity bought trap.\n    // Per address per block.\n    function LiquidityPercentTrap_skip() internal pure override returns(bool) {\n        return false;\n    }\n    function LiquidityPercentTrap_blocks() internal pure override returns(uint8) {\n        return 6;\n    }\n    function LiquidityPercentTrap_percent() internal pure override returns(uint64) {\n        return HUNDRED_PERCENT / 20; // 5%\n    }\n\n    // Disable/Enable number of trades trap.\n    // Per block.\n    function LiquidityActivityTrap_skip() internal pure override returns(bool) {\n        return false;\n    }\n    function LiquidityActivityTrap_blocks() internal pure override returns(uint8) {\n        return 3;\n    }\n    function LiquidityActivityTrap_count() internal pure override returns(uint8) {\n        return 8;\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() external {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"Standard: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() external {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"Standard: must have pauser role to unpause\");\n        _unpause();\n    }\n\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `BURNER_ROLE`.\n     */\n    function burn(uint256 amount) public {\n        require(hasRole(BURNER_ROLE, _msgSender()), \"Standard: must have burner role to burn\");\n\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     * - the caller must have the `BURNER_ROLE`.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        require(hasRole(BURNER_ROLE, _msgSender()), \"Standard: must have burner role to burn\");\n\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        _approve(account, _msgSender(), currentAllowance - amount);\n        _burn(account, amount);\n    }\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a GutterComics smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: The \"GutterComics\" contract is a comprehensive ERC721-based token contract designed for a comic series. It includes features for presale, public sale, free minting, and upgrades, with various checks ensuring secure transactions. Additionally, it supports functionalities like metadata locking, contract ownership management, and interactions with OpenSea's gas-less listings through proxy whitelisting.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function presale(uint256 qty, uint256 gutterCatorRatID) external payable nonReentrant:\n\n2. function publicSale(uint256 qty) external payable nonReentrant:\n\n3. function freeSale(uint256 catID) external nonReentrant:\n- free for gutter cats\n\n4. function upgradeComic(bytes32 hash, bytes memory sig, uint256 firstId, uint256 secondId, uint256 coverType) external nonReentrant:\n\n5. function adminMint(address to, uint256 qty) external onlyOwner:\n- admin mint\n\n6. function mintMultiple(address receiver, uint256 qty) private:\n\n7. function mintToken(address receiver) private:\n\n8. function burnToken(uint256 tokenId) private:\n\n9. function burn(uint256 tokenId) public virtual:\n- burn\n\n10. function setBaseURI(string memory newuri) public onlyOwner:\n\n11. function tokenURI(uint256 _tokenId) public view override returns (string memory):\n\n12. function setContractURI(string memory newuri) public onlyOwner:\n\n13. function contractURI() public view returns (string memory):\n\n14. function setGutterAddresses(address cats, address rats, address pigeons, address dogs) external onlyOwner:\n- sets the gang addresses\n\n15. function setPresaleLive(bool live) external onlyOwner:\n- sets presale live\n\n16. function setSaleLive(bool live) external onlyOwner:\n- sets sale live\n\n17. function setFreeMintLive(bool live) external onlyOwner:\n- sets free mint live\n\n18. function setBurnLive(bool live) external onlyOwner: \n- sets burn live\n\n19. function setUpgradeLive(bool live) external onlyOwner:\n- sets upgrade live\n\n20. function setSaleStopID(uint256 newSaleStopID) external onlyOwner:\n- sets upgrade live\n\n21. function withdraw() public onlyOwner:\n\n22. function reclaimERC20(IERC20 erc20Token) public onlyOwner:\n\n23. function reclaimERC721(IERC721 erc721Token, uint256 id) public onlyOwner:\n\n24. function reclaimERC1155(IERC1155 erc1155Token, uint256 id, uint256 qty) public onlyOwner\n\n25. function isApprovedForAll(address owner, address operator) public view override returns (bool): \n- Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gasless listings. \n\n26. function setProxyRegistry(address _newRegistry) external onlyOwner: \n- sets the opensea proxy\n\n27. function lockMetadata() external onlyOwner:\n- and for the eternity!\n\n28. function setSignerAddress(address newSigner) external onlyOwner:\n- sets signer address\n\n29. function decreaseMaxNormalSupplyID(uint256 newSupplyID) external onlyOwner:\n- decreases max supply\n\n30. function totalSupply() public view returns (uint256):\n\n31. function hashTransaction(uint256 firstId, uint256 secondId, uint256 coverType) private pure returns (bytes32):\n- utils\n\n32. function matchAddresSigner(bytes32 hash, bytes memory signature) private view returns (bool):\n\n33. function exists(uint256 id) external view returns (bool):\n\n"}, {"role": "assistant", "content": "contract GutterComics is ERC721, Ownable, ReentrancyGuard {\n    using Address for address;\n    using Strings for uint256;\n    using ECDSA for bytes32;\n\n    //gasless approvals on opensea\n    address proxyRegistryAddress = 0xa5409ec958C83C3f309868babACA7c86DCB077c1;\n\n    string public _baseURIextended =\n        \"https://comicsapi.guttercatgang.com/metadata/comics/\";\n    string public _contractURI =\n        \"ipfs://Qmf6iFDeNGFcEAdympLTpNZhGyTjtQtTeJ9bbde3f9tKyZ\";\n\n    uint256 public maxNormalSupplyID = 12000;\n    uint256 public saleStopID = 9000;\n    uint256 public pricePerComic = 0.04 ether;\n\n    bool public locked; //metadata lock\n    uint256 public _currentIndex;\n    uint256 private _tokensBurned;\n\n    bool public presaleLive;\n    bool public saleLive;\n    bool public freeMintLive;\n    bool public burnLive;\n\n    address public gutterCatNFTAddress =\n        0xEdB61f74B0d09B2558F1eeb79B247c1F363Ae452;\n    address public gutterRatNFTAddress =\n        0xD7B397eDad16ca8111CA4A3B832d0a5E3ae2438C;\n    address public gutterPigeonNFTAddress =\n        0x950b9476a4de757BB134483029AC4Ec17E739e3A;\n    address public gutterDogNFTAddress =\n        0x6E9DA81ce622fB65ABf6a8d8040e460fF2543Add;\n\n    // upgrade-related settings\n    address private signerAddress;\n    bool public upgradeLive;\n\n    mapping(uint256 => bool) public usedCatIDs; //used cat IDs for free claiming\n    mapping(address => uint256) public purchases;\n\n    event TokenUpgraded(uint256 id, uint256 coverType);\n\n    constructor() ERC721(\"Gutter Comics\", \"GCOM\") {}\n\n    function presale(uint256 qty, uint256 gutterCatorRatID)\n        external\n        payable\n        nonReentrant\n    {\n        require(tx.origin == msg.sender, \"no...\");\n        require(presaleLive, \"presale not live\");\n        require(qty <= 5, \"max 5 per tx\");\n        require(purchases[msg.sender] + qty <= 10, \"limit exceded\");\n\n        require(_currentIndex + qty <= saleStopID, \"out of stock\");\n        require(pricePerComic * qty == msg.value, \"exact amount needed\");\n\n        require(\n            (IERC1155(gutterCatNFTAddress).balanceOf(\n                msg.sender,\n                gutterCatorRatID\n            ) > 0) ||\n                (IERC1155(gutterRatNFTAddress).balanceOf(\n                    msg.sender,\n                    gutterCatorRatID\n                ) > 0) ||\n                (IERC721(gutterPigeonNFTAddress).balanceOf(msg.sender) > 0) ||\n                (IERC721(gutterDogNFTAddress).balanceOf(msg.sender) > 0),\n            \"you have to own a gutter species\"\n        );\n\n        purchases[msg.sender] += qty;\n\n        mintMultiple(msg.sender, qty);\n    }\n\n    function publicSale(uint256 qty) external payable nonReentrant {\n        require(tx.origin == msg.sender, \"no...\");\n        require(saleLive, \"sale not live\");\n        require(qty <= 5, \"max 5 per tx\");\n        require(purchases[msg.sender] + qty <= 10, \"limit exceded\");\n\n        require(_currentIndex + qty <= saleStopID, \"out of stock\");\n        require(pricePerComic * qty == msg.value, \"exact amount needed\");\n\n        purchases[msg.sender] += qty;\n\n        mintMultiple(msg.sender, qty);\n    }\n\n    // free for gutter cats\n    function freeSale(uint256 catID) external nonReentrant {\n        require(tx.origin == msg.sender, \"no...\");\n        require(freeMintLive, \"free mint not live\");\n\n        require(_currentIndex + 1 <= maxNormalSupplyID, \"out of stock\");\n        require(!usedCatIDs[catID], \"you can only mint once with this id\");\n\n        require(\n            IERC1155(gutterCatNFTAddress).balanceOf(msg.sender, catID) > 0,\n            \"you have to own a cat with this id\"\n        );\n\n        usedCatIDs[catID] = true;\n\n        mintToken(msg.sender);\n    }\n\n    function upgradeComic(\n        bytes32 hash,\n        bytes memory sig,\n        uint256 firstId,\n        uint256 secondId,\n        uint256 coverType\n    ) external nonReentrant {\n        require(\n            _currentIndex >= maxNormalSupplyID,\n            \"wrong max supply settings\"\n        );\n        require(upgradeLive, \"upgrade not live\");\n        require(matchAddresSigner(hash, sig), \"no direct mint\");\n        require(\n            hashTransaction(firstId, secondId, coverType) == hash,\n            \"hash check failed\"\n        );\n        require(_exists(firstId) && _exists(secondId), \"tokens don't exist\");\n        require(\n            ownerOf(firstId) == msg.sender && ownerOf(secondId) == msg.sender,\n            \"not the owner\"\n        );\n        require(firstId != secondId, \"same ids\");\n\n        burnToken(firstId);\n        burnToken(secondId);\n\n        mintToken(msg.sender);\n\n        emit TokenUpgraded(_currentIndex, coverType);\n    }\n\n    //admin mint\n    function adminMint(address to, uint256 qty) external onlyOwner {\n        require(_currentIndex + qty <= maxNormalSupplyID, \"out of stock\");\n        mintMultiple(to, qty);\n    }\n\n    function mintMultiple(address receiver, uint256 qty) private {\n        for (uint256 i = 0; i < qty; i++) {\n            mintToken(receiver);\n        }\n    }\n\n    function mintToken(address receiver) private {\n        _currentIndex += 1;\n        _safeMint(receiver, _currentIndex);\n    }\n\n    function burnToken(uint256 tokenId) private {\n        _tokensBurned += 1;\n        _burn(tokenId);\n    }\n\n    //burn\n    function burn(uint256 tokenId) public virtual {\n        require(burnLive, \"burn not live\");\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"caller is not owner nor approved\"\n        );\n        burnToken(tokenId);\n    }\n\n    function setBaseURI(string memory newuri) public onlyOwner {\n        require(!locked, \"locked functions\");\n        _baseURIextended = newuri;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(_tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n        return string(abi.encodePacked(_baseURIextended, _tokenId.toString()));\n    }\n\n    function setContractURI(string memory newuri) public onlyOwner {\n        require(!locked, \"locked functions\");\n        _contractURI = newuri;\n    }\n\n    function contractURI() public view returns (string memory) {\n        return _contractURI;\n    }\n\n    //sets the gang addresses\n    function setGutterAddresses(\n        address cats,\n        address rats,\n        address pigeons,\n        address dogs\n    ) external onlyOwner {\n        gutterCatNFTAddress = cats; //0xEdB61f74B0d09B2558F1eeb79B247c1F363Ae452\n        gutterRatNFTAddress = rats; //0xD7B397eDad16ca8111CA4A3B832d0a5E3ae2438C\n        gutterPigeonNFTAddress = pigeons; //0x950b9476a4de757BB134483029AC4Ec17E739e3A\n        gutterDogNFTAddress = dogs; //0x6e9da81ce622fb65abf6a8d8040e460ff2543add\n    }\n\n    //sets presale live\n    function setPresaleLive(bool live) external onlyOwner {\n        presaleLive = live;\n    }\n\n    //sets sale live\n    function setSaleLive(bool live) external onlyOwner {\n        saleLive = live;\n    }\n\n    //sets free mint live\n    function setFreeMintLive(bool live) external onlyOwner {\n        freeMintLive = live;\n    }\n\n    //sets burn live\n    function setBurnLive(bool live) external onlyOwner {\n        burnLive = live;\n    }\n\n    //sets upgrade live\n    function setUpgradeLive(bool live) external onlyOwner {\n        upgradeLive = live;\n    }\n\n    //sets upgrade live\n    function setSaleStopID(uint256 newSaleStopID) external onlyOwner {\n        require(newSaleStopID <= maxNormalSupplyID, \"invalid id\");\n        saleStopID = newSaleStopID;\n    }\n\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function reclaimERC20(IERC20 erc20Token) public onlyOwner {\n        erc20Token.transfer(msg.sender, erc20Token.balanceOf(address(this)));\n    }\n\n    function reclaimERC721(IERC721 erc721Token, uint256 id) public onlyOwner {\n        erc721Token.safeTransferFrom(address(this), msg.sender, id);\n    }\n\n    function reclaimERC1155(\n        IERC1155 erc1155Token,\n        uint256 id,\n        uint256 qty\n    ) public onlyOwner {\n        erc1155Token.safeTransferFrom(address(this), msg.sender, id, qty, \"\");\n    }\n\n    /**\n     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        // Whitelist OpenSea proxy contract for easy trading.\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n        return super.isApprovedForAll(owner, operator);\n    }\n\n    //sets the opensea proxy\n    function setProxyRegistry(address _newRegistry) external onlyOwner {\n        proxyRegistryAddress = _newRegistry;\n    }\n\n    // and for the eternity!\n    function lockMetadata() external onlyOwner {\n        locked = true;\n    }\n\n    //sets signer address\n    function setSignerAddress(address newSigner) external onlyOwner {\n        signerAddress = newSigner;\n    }\n\n    // decreases max supply\n    function decreaseMaxNormalSupplyID(uint256 newSupplyID) external onlyOwner {\n        require(\n            maxNormalSupplyID > newSupplyID && newSupplyID >= _currentIndex,\n            \"invalid new supply\"\n        );\n        maxNormalSupplyID = newSupplyID;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _currentIndex - _tokensBurned;\n    }\n\n    // utils\n    function hashTransaction(\n        uint256 firstId,\n        uint256 secondId,\n        uint256 coverType\n    ) private pure returns (bytes32) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encodePacked(firstId, secondId, coverType))\n            )\n        );\n        return hash;\n    }\n\n    function matchAddresSigner(bytes32 hash, bytes memory signature)\n        private\n        view\n        returns (bool)\n    {\n        return signerAddress == hash.recover(signature);\n    }\n\n    function exists(uint256 id) external view returns (bool) {\n        return _exists(id);\n    }\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a TempleERC20Token smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\n\nTask Description: The \"TempleERC20Token\" contract is an ERC20 token with additional functionalities such as burning, pausing, and access control. It allows the owner to pause token transfers in emergencies and manage minting permissions by adding or removing minters. Additionally, it ensures that token transfers are paused before execution through the _beforeTokenTransfer function.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function pause() external onlyOwner:\n- For use in emergencies to pause all token transfers \n\n2. function unpause() external onlyOwner:\n- Revert back to normal operations once P0 which caused pause has been triaged and fixed. \n\n3. function mint(address to, uint256 amount) external:\n\n4. function addMinter(address account) external onlyOwner:\n\n5. function removeMinter(address account) external onlyOwner:\n\n6. function _beforeTokenTransfer(address from, address to, uint256 amount) internal whenNotPaused override:\n\n\n"}, {"role": "assistant", "content": "contract TempleERC20Token is ERC20, ERC20Burnable, Pausable, Ownable, AccessControl {\n    bytes32 public constant CAN_MINT = keccak256(\"CAN_MINT\");\n\n    constructor() ERC20(\"Temple\", \"TEMPLE\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner());\n    }\n\n    /**\n     * For use in emergencies to pause all token transfers\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Revert back to normal operations once P0 which caused pause has been\n     * triaged and fixed.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function mint(address to, uint256 amount) external {\n      require(hasRole(CAN_MINT, msg.sender), \"Caller cannot mint\");\n      _mint(to, amount);\n    }\n\n    function addMinter(address account) external onlyOwner {\n        grantRole(CAN_MINT, account);\n    }\n\n    function removeMinter(address account) external onlyOwner {\n        revokeRole(CAN_MINT, account);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a InkeGold smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description:The InkeGold smart contract is an ERC20 token called \"Inke Gold\" (symbol: IKG) with a fixed supply of 45,000 tokens and specialized functionalities for freezing and unfreezing tokens. It allows the CEO to mint and burn tokens, while administrators can freeze tokens for a specified period or until manually unfrozen, preventing the affected accounts from transferring the frozen amount. The contract also provides standard ERC20 functions such as transferring tokens and checking balances, with additional checks to ensure that frozen tokens cannot be transferred until they are unfrozen.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function goldTotalSupply() public constant returns (uint):\n- Total supply\n2. function goldBalanceOf(address tokenOwner) public constant returns (uint balance): \n- Get the token balance for account tokenOwner\n3. function goldTransfer(address to, uint tokens) public whenNotPaused returns (bool success):\n- Transfer the balance from token owner's account to to account Owner's account must have sufficient balance to transfer 0 value transfers are allowed\n4. function mintGold(uint amount) public onlyCEO:\n- Mint Tokens\n5. function burnGold(uint amount) public onlyCEO: \n- Burn Tokens \n6. function goldFreeze(address user, uint amount, uint period) public onlyAdmin: \n- Freeze Tokens \n7. function goldUnFreeze() public whenNotPaused: \n- UnFreeze Tokens \n8. function goldIfFreeze(address user) public view returns:\n- if fromzen tokens, returns amount of tokens that are frozen and time remaining until the tokens are automatically unfrozen\n"}, {"role": "assistant", "content": "contract InkeGold is ERC20Interface, Administration, SafeMath {\r\n    event GoldTransfer(address indexed from, address indexed to, uint tokens);\r\n    \r\n    string public goldSymbol;\r\n    string public goldName;\r\n    uint8 public goldDecimals;\r\n    uint public _goldTotalSupply;\r\n\r\n    mapping(address => uint) goldBalances;\r\n    mapping(address => bool) goldFreezed;\r\n    mapping(address => uint) goldFreezeAmount;\r\n    mapping(address => uint) goldUnlockTime;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        goldSymbol = \"IKG\";\r\n        goldName = \"Inke Gold\";\r\n        goldDecimals = 0;\r\n        _goldTotalSupply = 45000;\r\n        goldBalances[CEOAddress] = _goldTotalSupply;\r\n        emit GoldTransfer(address(0), CEOAddress, _goldTotalSupply);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function goldTotalSupply() public constant returns (uint) {\r\n        return _goldTotalSupply  - goldBalances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function goldBalanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return goldBalances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function goldTransfer(address to, uint tokens) public whenNotPaused returns (bool success) {\r\n        if(goldFreezed[msg.sender] == false){\r\n            goldBalances[msg.sender] = safeSub(goldBalances[msg.sender], tokens);\r\n            goldBalances[to] = safeAdd(goldBalances[to], tokens);\r\n            emit GoldTransfer(msg.sender, to, tokens);\r\n        } else {\r\n            if(goldBalances[msg.sender] > goldFreezeAmount[msg.sender]) {\r\n                require(tokens <= safeSub(goldBalances[msg.sender], goldFreezeAmount[msg.sender]));\r\n                goldBalances[msg.sender] = safeSub(goldBalances[msg.sender], tokens);\r\n                goldBalances[to] = safeAdd(goldBalances[to], tokens);\r\n                emit GoldTransfer(msg.sender, to, tokens);\r\n            }\r\n        }\r\n            \r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Mint Tokens\r\n    // ------------------------------------------------------------------------\r\n    function mintGold(uint amount) public onlyCEO {\r\n        goldBalances[msg.sender] = safeAdd(goldBalances[msg.sender], amount);\r\n        _goldTotalSupply = safeAdd(_goldTotalSupply, amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Burn Tokens\r\n    // ------------------------------------------------------------------------\r\n    function burnGold(uint amount) public onlyCEO {\r\n        goldBalances[msg.sender] = safeSub(goldBalances[msg.sender], amount);\r\n        _goldTotalSupply = safeSub(_goldTotalSupply, amount);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Freeze Tokens\r\n    // ------------------------------------------------------------------------\r\n    function goldFreeze(address user, uint amount, uint period) public onlyAdmin {\r\n        require(goldBalances[user] >= amount);\r\n        goldFreezed[user] = true;\r\n        goldUnlockTime[user] = uint(now) + period;\r\n        goldFreezeAmount[user] = amount;\r\n    }\r\n    \r\n    function _goldFreeze(uint amount) internal {\r\n        require(goldFreezed[msg.sender] == false);\r\n        require(goldBalances[msg.sender] >= amount);\r\n        goldFreezed[msg.sender] = true;\r\n        goldUnlockTime[msg.sender] = uint(-1);\r\n        goldFreezeAmount[msg.sender] = amount;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // UnFreeze Tokens\r\n    // ------------------------------------------------------------------------\r\n    function goldUnFreeze() public whenNotPaused {\r\n        require(goldFreezed[msg.sender] == true);\r\n        require(goldUnlockTime[msg.sender] < uint(now));\r\n        goldFreezed[msg.sender] = false;\r\n        goldFreezeAmount[msg.sender] = 0;\r\n    }\r\n    \r\n    function _goldUnFreeze(uint _amount) internal {\r\n        require(goldFreezed[msg.sender] == true);\r\n        goldUnlockTime[msg.sender] = 0;\r\n        goldFreezed[msg.sender] = false;\r\n        goldFreezeAmount[msg.sender] = safeSub(goldFreezeAmount[msg.sender], _amount);\r\n    }\r\n    \r\n    function goldIfFreeze(address user) public view returns (\r\n        bool check, \r\n        uint amount, \r\n        uint timeLeft\r\n    ) {\r\n        check = goldFreezed[user];\r\n        amount = goldFreezeAmount[user];\r\n        timeLeft = goldUnlockTime[user] - uint(now);\r\n    }\r\n\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a liquidbotToken smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The liquidbotToken smart contract is an ERC20 token named \"Liquidbot Token\" with the symbol \"LQB\" and a decimal precision of 18. It includes functionalities for handling a crowdsale with a start and end date, allowing for token purchases at a fixed rate during this period, and enabling the owner to withdraw Ether, initiate an airdrop, and manage the crowdsale timing. The contract also implements standard ERC20 functions such as transferring tokens, approving token spending, and querying balances and allowances, with additional safety checks and an owner-only withdrawal mechanism for collected Ether post-crowdsale.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function totalSupply() public view override returns (uint256):\n- Total supply \n2. function balanceOf(address tokenOwner) public override view returns (uint256 balance):\n- Get the token balance for account `tokenOwner` \n3. function transfer(address to, uint256 tokens) public override returns (bool success):\n- Transfer the balance from token owner's account to `to` account  Owner's account must have sufficient balance to transfer  0 value transfers are allowed \n4. function approve(address spender, uint256 tokens) public override returns (bool success):\n- Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account https:github.comethereumEIPsblobmasterEIPSeip20tokenstandard.md recommends that there are no checks for the approval doublespend attack as this should be implemented in user interfaces \n5. function transferFrom(address from, address to, uint256 tokens) public override returns (bool success):\n- Transfer `tokens` from the `from` account to the `to` account The calling account must already have sufficient tokens approve(...)d for spending from the `from` account and  From account must have sufficient balance to transfer  Spender must have sufficient allowance to transfer  0 value transfers are allowed \n6. function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining):\n- Returns the amount of tokens approved by the owner that can be transferred to the spender's account \n7. function approveAndCall(address spender, uint256 tokens, bytes memory data) public returns (bool success):\n- Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account. The `spender` contract function `receiveApproval(...)` is then executed \n8. function startCrowdsale() public onlyOwner:\n- Owner only start Crowdsale \n9. function getAirdropTokens() public onlyOwner:\n- Send tokens to owner for airdrop \n10. function withDrawETH(uint256 amount) public onlyOwner tokensaleEnded:\n- Owner only withdraw ETH \n11. function withDrawETHToAddress(address payable destinationAddress, uint256 amount) public onlyOwner tokensaleEnded:\n- Owner only withdraw ETH to address \n12. function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success):\n- Owner can transfer out any accidentally sent ERC20 tokens\n"}, {"role": "assistant", "content": "contract liquidbotToken is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public name;\r\n    uint8 public decimals;\r\n    uint256 public _totalSupply;\r\n    uint256 public startDate;\r\n    uint256 public endDate;\r\n    bool public airdropTokensWithdrawn = false;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() {\r\n        symbol = \"LQB\";\r\n        name = \"Liquidbot Token\";\r\n        decimals = 18;\r\n        startDate = block.timestamp + 20 weeks;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint256 tokens)\r\n        public\r\n        override\r\n        returns (bool success)\r\n    {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces\r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint256 tokens)\r\n        public\r\n        override\r\n        returns (bool success)\r\n    {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    //\r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the `from` account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokens\r\n    ) public override returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256 remaining)\r\n    {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account. The `spender` contract function\r\n    // `receiveApproval(...)` is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(\r\n        address spender,\r\n        uint256 tokens,\r\n        bytes memory data\r\n    ) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(\r\n            msg.sender,\r\n            tokens,\r\n            address(0),\r\n            data\r\n        );\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // handles contributions\r\n    // ------------------------------------------------------------------------\r\n    receive() external payable {\r\n        require(block.timestamp >= startDate && block.timestamp <= endDate);\r\n        uint256 tokens = safeMul(msg.value, 40);\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);\r\n        _totalSupply = safeAdd(_totalSupply, tokens);\r\n        emit Transfer(address(0), msg.sender, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner only start Crowdsale\r\n    // ------------------------------------------------------------------------\r\n    function startCrowdsale() public onlyOwner {\r\n        startDate = block.timestamp;\r\n        endDate = block.timestamp + 6 weeks;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Send tokens to owner for airdrop\r\n    // ------------------------------------------------------------------------\r\n    function getAirdropTokens() public onlyOwner {\r\n        require(block.timestamp >= startDate && block.timestamp <= endDate);\r\n        require(!airdropTokensWithdrawn);\r\n        uint256 tokens = 5000000000000000000000;\r\n        balances[owner] = safeAdd(balances[owner], tokens);\r\n        _totalSupply = safeAdd(_totalSupply, tokens);\r\n        emit Transfer(address(0), owner, tokens);\r\n        airdropTokensWithdrawn = true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner only withdraw ETH\r\n    // ------------------------------------------------------------------------\r\n    function withDrawETH(uint256 amount) public onlyOwner tokensaleEnded {\r\n        owner.transfer(amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner only withdraw ETH to address\r\n    // ------------------------------------------------------------------------\r\n    function withDrawETHToAddress(address payable destinationAddress, uint256 amount) public onlyOwner tokensaleEnded {\r\n        destinationAddress.transfer(amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint256 tokens)\r\n        public\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    modifier tokensaleEnded {\r\n        require(block.timestamp > endDate);\r\n        _;\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a BluzelleStakingRewards smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The BluzelleStakingRewards smart contract is an ERC20 token with a detailed implementation that includes a deflationary mechanism where a percentage of each transaction is burned, reducing the total supply over time. It provides standard ERC20 functionalities such as transferring tokens, approving token spending, and querying balances and allowances, with additional functions for burning tokens both by the token holder and by an approved spender. The contract also includes a method to calculate the burn amount for a given transaction value, ensuring that a fixed percentage of the transaction value is removed from circulation with each transfer.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function totalSupply() public view returns(uint256):\n- Return: Total number of tokens in circulation\n2. function balanceOf(address owner) public view returns(uint256):\n- Return: Balance owned by `owner`\n3. function allowance(address owner, address spender) public view returns(uint256):\n- Return: Amount of tokens that `spender` is allowed to spend on behalf of `owner`\n4. function findBurnAmount(uint256 value) public view returns(uint256):\n- Calculates the amount of tokens to be burned based on the transaction value and the base burn percentage.\n5. function transfer(address to, uint256 value) public returns(bool):\n- Transfers `value` tokens from the caller's account to the `to` account, with a portion of the tokens being burned in the process\n6. function approve(address spender, uint256 value) public returns(bool):\n- Approves `spender` to spend up to `value` tokens on behalf of the caller.\n7. function transferFrom(address from, address to, uint256 value) public returns(bool):\n- Transfers `value` tokens from `from` account to `to` account on behalf of the caller, with a portion of the tokens being burned in the process\n8. function increaseAllowance(address spender, uint256 addedValue) public returns(bool):\n- Increases the allowance granted to `spender` by the caller by `addedValue` tokens\n9. function decreaseAllowance(address spender, uint256 subtractedValue) public returns(bool):\n- Decreases the allowance granted to `spender` by the caller by `subtractedValue` tokens\n10. function _mint(address account, uint256 amount) internal\n- Internal function to mint `amount` tokens to the specified `account`\n11. function burn(uint256 amount) external\n- Allows the caller to burn `amount` of their own tokens, reducing the total supply\n12. function _burn(address account, uint256 amount) internal\n- Internal function to burn `amount` tokens from the specified `account`, reducing the total supply\n13. function burnFrom(address account, uint256 amount) external\n- Allows a spender to burn `amount` of tokens from `account`'s balance, given sufficient allowance\n"}, {"role": "assistant", "content": "contract BluzelleStakingRewards is ERC20Detailed {\r\n\r\n    using SafeMath for uint256; \r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply = 11000e18;\r\n\r\n\r\n    uint256 public basePercent = 320;\r\n\r\n    constructor() public ERC20Detailed(\"Bluzelle Staking Rewards\", \"BLSR\", 18) {\r\n        _mint(msg.sender, _totalSupply);\r\n    }\r\n\r\n    /// @return Total number of tokens in circulation\r\n    function totalSupply() public view returns(uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    function balanceOf(address owner) public view returns(uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns(uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n\r\n    function findBurnAmount(uint256 value) public view returns(uint256) {\r\n  \r\n        if (value == 1) {\r\n            return 0;\r\n        }\r\n        uint256 roundValue = value.ceil(basePercent);\r\n        //Gas optimized\r\n        uint256 burnAmount = roundValue.mul(100).div(32000);\r\n        return burnAmount;\r\n    }\r\n\r\n\r\n    function transfer(address to, uint256 value) public returns(bool) {\r\n        require(to != address(0));\r\n\r\n        uint256 tokensToBurn = findBurnAmount(value);\r\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\r\n\r\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n        _balances[to] = _balances[to].add(tokensToTransfer);\r\n\r\n        _totalSupply = _totalSupply.sub(tokensToBurn);\r\n\r\n        emit Transfer(msg.sender, to, tokensToTransfer);\r\n        emit Transfer(msg.sender, address(0), tokensToBurn);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address spender, uint256 value) public returns(bool) {\r\n        require(spender != address(0));\r\n        _allowances[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns(bool) {\r\n        require(value <= _allowances[from][msg.sender]);\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n\r\n        uint256 tokensToBurn = findBurnAmount(value);\r\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\r\n\r\n        _balances[to] = _balances[to].add(tokensToTransfer);\r\n        _totalSupply = _totalSupply.sub(tokensToBurn);\r\n\r\n        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\r\n\r\n        emit Transfer(from, to, tokensToTransfer);\r\n        emit Transfer(from, address(0), tokensToBurn);\r\n\r\n        return true;\r\n    }\r\n\r\n  \r\n    function increaseAllowance(address spender, uint256 addedValue) public returns(bool) {\r\n        require(spender != address(0));\r\n        _allowances[msg.sender][spender] = (_allowances[msg.sender][spender].add(addedValue));\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns(bool) {\r\n        require(spender != address(0));\r\n        _allowances[msg.sender][spender] = (_allowances[msg.sender][spender].sub(subtractedValue));\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(amount != 0);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function burn(uint256 amount) external {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(amount != 0);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[account] = _balances[account].sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) external {\r\n        require(amount <= _allowances[account][msg.sender]);\r\n        _allowances[account][msg.sender] = _allowances[account][msg.sender].sub(amount);\r\n        _burn(account, amount);\r\n    }\r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The GlassesLoot smart contract is an ERC721 token representing glasses-themed collectibles with a fixed maximum supply and a sale mechanism. It allows the owner to set prices, toggle the sale state, reserve tokens for giveaways, and withdraw funds, while users can mint new tokens during an active sale, paying a specified ETH price per token. A portion of the mint proceeds is allocated to a community wallet, and the contract includes safeguards against reentrancy attacks during token minting.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function withdraw() public onlyOwner:\n- Allows the owner to withdraw a portion of the contract's balance, allocated to the developer and community wallet based on predefined budgets.\n2. function calculateWithdraw(uint256 budget, uint256 proposal) private pure returns (uint256)\n- Calculates the withdrawal amount based on the available budget and the proposed amount, ensuring it doesn't exceed the budget.\n3. function _withdraw(address _address, uint256 _amount) private\n- Internal function to transfer `_amount` of Ether to the specified `_address`.\n4. function setGlassesPrice(uint256 _glassesPrice) public onlyOwner\n- Allows the owner to set the price for minting a Glasses Loot token.\n5. function setProvenanceHash(string memory provenanceHash) public onlyOwner\n- Allows the owner to set the provenance hash for the Glasses Loot collection.\n6. function setBaseURI(string memory baseURI) public onlyOwner\n- Allows the owner to set the base URI for the token metadata.\n7. function flipSaleState() public onlyOwner\n- Toggles the active state of the token sale, allowing or disallowing minting.\n8. function reserveGlassesLoot(address _to, uint256 _reserveAmount) public onlyOwner\n- Allows the owner to reserve a specific amount of Glasses Loot tokens for a specified address.\n9. function mintGlassesLoot(uint numberOfTokens) public payable reentryLock\n- Allows users to mint a specified number of Glasses Loot tokens during an active sale, subject to limits and price requirements.\n10. function tokensOfOwner(address _owner) external view returns(uint256[] memory)\n- Returns an array of token IDs owned by the specified address.\n"}, {"role": "assistant", "content": "contract GlassesLoot is ERC721, Ownable, nonReentrant {\r\n\r\n    string public GLASSES_PROVENANCE = \"\"; // IPFS URL WILL BE ADDED WHEN Glasses Loot from Space are sold out\r\n\t\r\n    uint256 public glassesPrice = 100000000000000000; // 0.1 ETH  75% of Mint goes back to the CommunityWallet!  20% of Royalties will go to the Community Wallet as well!\r\n\r\n    uint public constant maxGlassesPurchase = 20;\r\n\r\n    uint256 public constant MAX_GLASSES = 10000;\r\n\t\r\n\tuint256 public budgetDev1 = 10000 ether; \r\n    uint256 public budgetCommunityWallet = 10000 ether; \r\n\r\n    bool public saleIsActive = false;\r\n\t\r\n\taddress private constant DEV1 = 0xb9Ac0254e09AfB0C18CBF21B6a2a490FB608e738;\r\n    address private constant CommunityWallet = 0x7ccAfc2707E88B5C9929a844d074a06eb1555DD7;\r\n    \r\n    // mapping(uint => string) public glassesNames;\r\n    \r\n    // Reserve Glasses for team - Giveaways/Prizes etc\r\n\tuint public constant MAX_GLASSESRESERVE = 400;\t// total team reserves allowed for Giveaways, Admins, Mods, Team\r\n    uint public GlassesReserve = MAX_GLASSESRESERVE;\t// counter for team reserves remaining \r\n    \r\n    constructor() ERC721(\"Glasses Loot\", \"GLOOT\") {     }\r\n    //TEAM Withdraw\r\n\t\r\n\tfunction withdraw() public onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"Insufficent balance\");\r\n        uint256 witdrawAmount = calculateWithdraw(budgetDev1,(balance * 25) / 100);\r\n        if (witdrawAmount>0){\r\n            budgetDev1 -= witdrawAmount;\r\n            _withdraw(DEV1, witdrawAmount);\r\n        }\r\n        witdrawAmount = calculateWithdraw(budgetCommunityWallet,(balance * 75) / 100);\r\n        if (witdrawAmount>0){\r\n            budgetCommunityWallet -= witdrawAmount;\r\n            _withdraw(CommunityWallet, witdrawAmount);\r\n        }\r\n      \r\n    }\r\n\r\n    function calculateWithdraw(uint256 budget, uint256 proposal) private pure returns (uint256){\r\n        if (proposal>budget){\r\n            return budget;\r\n        } else{\r\n            return proposal;\r\n        }\r\n    }\r\n    \r\n    function _withdraw(address _address, uint256 _amount) private {\r\n        (bool success, ) = _address.call{ value: _amount }(\"\");\r\n        require(success, \"Failed to widthdraw Ether\");\r\n    }\r\n    \r\n    \r\n\r\n\t\r\n\tfunction setGlassesPrice(uint256 _glassesPrice) public onlyOwner {\r\n        glassesPrice = _glassesPrice;\r\n    }\r\n\t\r\n\t\r\n    function setProvenanceHash(string memory provenanceHash) public onlyOwner {\r\n        GLASSES_PROVENANCE = provenanceHash;\r\n    }\r\n\r\n    function setBaseURI(string memory baseURI) public onlyOwner {\r\n        _setBaseURI(baseURI);\r\n    }\r\n\r\n\r\n    function flipSaleState() public onlyOwner {\r\n        saleIsActive = !saleIsActive;\r\n    }\r\n    \r\n    \r\n    function reserveGlassesLoot(address _to, uint256 _reserveAmount) public onlyOwner {        \r\n        uint reserveMint = MAX_GLASSESRESERVE - GlassesReserve; \r\n        require(_reserveAmount > 0 && _reserveAmount < GlassesReserve + 1, \"Not enough reserve left to fulfill amount\");\r\n        for (uint i = 0; i < _reserveAmount; i++) {\r\n            _safeMint(_to, reserveMint + i);\r\n        }\r\n        GlassesReserve = GlassesReserve - _reserveAmount;\r\n    }\r\n\r\n\r\n    function mintGlassesLoot(uint numberOfTokens) public payable reentryLock {\r\n        require(saleIsActive, \"Sale must be active to mint GlassesLoot\");\r\n        require(numberOfTokens > 0 && numberOfTokens < maxGlassesPurchase + 1, \"Can only mint 20 Glasses at a time\");\r\n        require(totalSupply() + numberOfTokens < MAX_GLASSES - GlassesReserve + 1, \"Purchase would exceed max supply of GlassesLoot\");\r\n        require(msg.value >= glassesPrice * numberOfTokens, \"Ether value sent is not correct\");\r\n        \r\n        for(uint i = 0; i < numberOfTokens; i++) {\r\n            uint mintIndex = totalSupply() + GlassesReserve; // start minting after reserved tokenIds\r\n            if (totalSupply() < MAX_GLASSES) {\r\n                _safeMint(msg.sender, mintIndex);\r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n    function tokensOfOwner(address _owner) external view returns(uint256[] memory ) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 index;\r\n            for (index = 0; index < tokenCount; index++) {\r\n                result[index] = tokenOfOwnerByIndex(_owner, index);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\t\r\n    \r\n}"}]}
{"messages":[{"role": "system", "content": "You are the greatest Smart contract Ethereum developer in the world. You have never messed up and always write the best and most complicated yet functioning Solidity contracts."}, {"role": "user", "content": "Generate a ALCOIN smart contract using Solidity 0.4.17. Fill in all the functions using the function signatures and accomplish the following requirements:\nTask Description: The ALCOIN smart contract represents a basic implementation of a cryptocurrency token called \"LATINO AMERICA COIN\" with the symbol \"ALC\" and a decimal precision of 3. It initializes with a total supply of 500 billion tokens, all of which are initially assigned to the contract creator. The contract includes a basic transfer function that allows token holders to send tokens to other addresses, with checks for sufficient balance and overflow protection, and an unnamed function to prevent accidental sending of ether to the contract.\n\nThe contract must have the following constraint: The contract is gas-efficient and include security checks to prevent common vulnerabilities (e.g., reentrancy, overflow/underflow).\n\nHere are the key functions that you must fully implement so that they are functioning:\n1. function ALCOIN():\n- Initializes contract with initial supply tokens to the creator of the contract \n2. function transfer(address _to, uint256 _value):  \n- Send coins \n3. function() :\n- This unnamed function is called whenever someone tries to send ether to it \n"}, {"role": "assistant", "content": "contract ALCOIN {\r\n    /* Public variables of the token */\r\n    string public standard = 'Token 0.1';\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public initialSupply;\r\n    uint256 public totalSupply;\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  \r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function ALCOIN() {\r\n\r\n         initialSupply = 500000000000;\r\n        name = \"LATINO AMERICA COIN\";\r\n        decimals = 3;\r\n        symbol = \"ALC\";\r\n        \r\n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\r\n        totalSupply = initialSupply;                        // Update total supply\r\n                                   \r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n      \r\n    }\r\n\r\n    /* This unnamed function is called whenever someone tries to send ether to it */\r\n    function () {\r\n        throw;     // Prevents accidental sending of ether\r\n    }\r\n}"}]}
