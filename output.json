["pragma solidity ^0.4.17;\n\ncontract Bitfex_Token is ERC20, MinterRole {\n    uint8 private _decimals;\n    string private _name;\n    string private _symbol;\n\n    mapping(address => bool) private _minters;\n\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    // Get the token balance for account `tokenOwner`\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balanceOf(tokenOwner);\n    }\n\n    // Transfer the balance from token owner's account to `to` account\n    function transfer(address to, uint tokens) public returns (bool success) {\n        return transferFrom(to, tokens);\n    }\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens` from the token owner's account\n    function approve(address spender, uint tokens) public returns (bool success) {\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _minters[spender] = true;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // Transfer `tokens` from the `from` account to the `to` account\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        require(from != address(0), \"ERC20: transfer from or to the zero address\");\n        require(to != address(0), \"ERC20: transfer to or from the zero address\");\n        require(_balances[from] >= tokens, \"ERC20: transfer amount exceeds balance\");\n        require(allowance(from, msg.sender) >= tokens, \"ERC20: transfer amount exceeds allowance\");\n        require(_minters[msg.sender], \"ERC20: sender does not have minter role\");\n        require(_balances[to] + tokens >= _balances[to]);\n        \n        _balances[from] -= tokens;\n        _balances[to] += tokens;\n        _allowed[from][msg.sender] -= tokens;\n        _mint(from, tokens);\n        return true;\n    }\n\n    // Destroy tokens for `account`\n    function burn(address account, uint tokens) public returns (bool success) {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= tokens, \"ERC20: burn amount exceeds balance\");\n        \n        _balances[account] -= tokens;\n        _totalSupply -= tokens;\n        emit Transfer(account, address(0), tokens);\n        return true;\n    }\n\n    // Destroy tokens from other account and approve `spender` to transferFrom(...) `tokens` from the token owner's account\n    function burnFrom(address account, uint tokens) public returns (bool success) {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(_balances[account] >= tokens, \"ERC20: burn amount exceeds balance\");\n        require(_allowed[account][msg.sender] >= tokens, \"ERC20: transfer amount exceeds allowance\");\n        \n        _balances[account] -= tokens;\n        _allowed[account][msg.sender] -= tokens;\n        _totalSupply -= tokens;\n        emit Transfer(account, address(0), tokens);\n        return true;\n    }\n}\n", "pragma solidity ^0.4.17;\n\ncontract Legends_of_Crypto is ERC20Detailed {\n    using SafeMath for uint256;\n    string public constant name = \"Legends of Crypto\";\n    string public constant symbol = \"LOCG\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply = 150e18;\n    address payable private owner;\n    \n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowed;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor () public {\n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n\n    function findOnePercentb() public view returns (uint256) {\n        uint256 _ts = totalSupply;\n        uint256 _onePercent = _ts.div(100);\n        return _onePercent;\n    }\n\n    function burn(uint256 _amount) public {\n        require(_amount <= balances[msg.sender]);\n        \n        totalSupply = totalSupply.sub(_amount);\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        emit Transfer(msg.sender, address(0), _amount);\n    }\n    \n    function burnFrom(address _from, uint256 _amount) public {\n        require(_amount <= balances[_from]);\n        require(_amount <= allowed[_from][msg.sender]);\n\n        totalSupply = totalSupply.sub(_amount);\n        balances[_from] = balances[_from].sub(_amount);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n        emit Transfer(_from, address(0), _amount);\n    }\n    \n    function multiTransfer(address[] calldata _to, uint256[] calldata _value) public {\n        for (uint i = 0; i < _to.length; i++) {\n            transfer(_to[i], _value[i]);\n        }\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract GrouchyTigerCubs is ERC721, ERC721Enumerable, ERC721Burnable {\n    uint256 public cost = 0.05 ether;\n    string private _baseURIextended;\n\n    bytes32 public constant PROVENANCE = keccak256(\"PROVENANCE\"));\n\n    uint256 public _tokenIdCounter;\n\n    constructor() ERC721(\"Grouchy Tiger Cubs\", \"GTC\") {}\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }\n\n    function setCost(uint256 _newCost) public onlyOwner {\n        cost = _newCost;\n    }\n\n    function setBaseURI(string memory __newBaseURI) public onlyOwner {\n        _baseURIextended = __newBaseURI;\n    }\n\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function setTokenURI(uint256 tokenId, string memory _tokenURI) public onlyOwner {\n        _setTokenURI(tokenId, _tokenURI);\n    }\n\n    function setProvenance() public onlyOwner {\n        (bool success, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        return tokenOfOwnerByIndex(owner, index);\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n        string memory currentBaseURI = _baseURI();\n        return bytes(currentBaseURI).length > 0\n            ? string(abi.encodePacked(currentBaseURI, tokenId.toString()))\n            : \"\";\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract ANTIHYPE is ERC20Detailed {\n    using SafeMath for uint256;\n    \n    string public name;\n    string public symbol;\n    uint8  public decimals;\n    uint256 public totalSupply;\n\n    address public owner;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    constructor() public {\n        name = \"ANTIHYPE Token\";\n        symbol = \"ANTIHYPE\";\n        decimals = 18;\n        owner = msg.sender;\n        totalSupply = 10000 * 10 ** uint(decimals); \n    }\n\n    function _executeTransfer(address _from, address _to, uint256 _value) internal {\n        require(_from != address(0));\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= balances[address(this)]);\n        \n        balances[_from] = (balances[_from]).sub(_value);\n        balances[_to] = (balances[_to]).add(_value);\n        emit Transfer(_from, _to, _value);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n    \n    function approve(address _spender, uint256 _value) public returns (bool) {\n        require(_spender != address(0));\n        \n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        \n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n        \n        _executeTransfer(msg.sender, _to, _value);\n        \n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_from != address(0));\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        \n        _executeTransfer(_from, _to, _value);\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_value);\n        balances[_from] = (balances[_from]).sub(_value);\n        balances[_to] = (balances[_to]).add(_value);\n        emit Transfer(_from, _to, _value);\n        \n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\n        require(_spender != address(0);\n        \n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender]).add(_addedValue);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        \n        return true;\n    }\n\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\n        require(_spender != address(0);\n        \n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender]).sub(_subtractedValue);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        \n        return true;\n    }\n\n    function withdrawUnclaimedTokens(address _tokenAddress) public onlyOwner returns (bool) {\n        require(_tokenAddress != address(0), \"ERC20: transfer to the zero address\");\n        \n        uint256 _contractBalance = IERC20(_tokenAddress).balanceOf(address(this));\n        require(_contractBalance > 0, \"ERC20: contract has no tokens\");\n        \n        IERC20(_tokenAddress).transfer(owner, _contractBalance);\n        return true;\n    }\n\n    function setOwner(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract DCREDITY is ERC20Detailed {\n    using SafeMath for uint256;\n    address public owner;\n    mapping (address => uint256) public freezeOf;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    uint256 public totalSupply = 10000000000e18;\n    uint8 public decimals = 18;\n    string public name;\n    string public symbol;\n    \n    constructor (string memory _name, string memory _symbol) public {\n        name = _name;\n        symbol = _symbol;\n        \n        owner = msg.sender;\n        \n        balanceOf[msg.sender] = totalSupply;\n    }\n    \n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n    \n    function () external payable {\n        revert();\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return totalSupply;\n    }\n    \n    function balanceOf(address _owner) public view returns (uint256) {\n        return balanceOf[_owner];\n    }\n    \n    function freeze(address _owner) public onlyOwner {\n        freezeOf[_owner] = balanceOf[_owner];\n        balanceOf[_owner] = 0;\n    }\n    \n    function unfreeze(address _owner) public onlyOwner {\n        balanceOf[_owner] = balanceOf[_owner].add(freezeOf[_owner]);\n        freezeOf[_owner] = 0;\n    }\n    \n    function isFrozen(address _owner) public view returns (bool) {\n        return freezeOf[_owner] > 0;\n    }\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balanceOf[msg.sender] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        \n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        \n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_from != address(0));\n        require(_to != address(0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        require(allowance[_from][msg.sender] >= _value);\n        \n        balanceOf[_from] = balanceOf[_from].sub(_value);\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        \n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function approve(address _spender, uint256 _value) public returns (bool) {\n        require(_spender != address(0));\n        \n        allowance[msg.sender][_spender] = _value;\n        \n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_from != address(0));\n        require(_to != address(0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        require(allowance[_from][msg.sender] >= _value);\n        \n        balanceOf[_from] = balanceOf[_from].sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n        \n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowance[_owner][_spender];\n    }\n    \n    function freeze(address _owner) public onlyOwner {\n        freezeOf[_owner] = balanceOf[_owner];\n        balanceOf[_owner] = balanceOf[_owner].sub(freezeOf[_owner]);\n    }\n    \n    function unfreeze(address _owner) public onlyOwner {\n        freezeOf[_owner] = 0;\n        balanceOf[_owner] = balanceOf[_owner].add(freezeOf[_owner]);\n    }\n    \n    function burn(uint256 _value) public onlyOwner {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract DegenerateDachshunds is ERC721, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    string public DEGENERATE_DACHSHUNDS_PROVENANCE = \"0x7F3B1BB1e1A1e3BF5cb4cD7\";\n    string public BaseURI;\n\n    uint256 public constant MAX_SUPPLY = 10000;\n    uint256 public constant MAX_PER_MINT = 20;\n    uint256 public price = 0.01 ether;\n    bool public saleIsActive = false;\n\n    constructor() ERC721(\"DegenerateDachshunds\", \"DEGENERATE DACHSHUNDS\") {}\n\n    function reserveNfts(address to, uint256 numberOfDachshunds) public onlyOwner {\n        uint256 supply = totalSupply();\n        require(supply + numberOfDachshunds <= MAX_SUPPLY, \"Purchase would exceed maximum supply of Dachshunds\");\n        for (uint256 i = 0; i < numberOfDachshunds; i++) {\n            _mintSingleNft(to);\n        }\n    }\n\n    function mintNft(uint256 numberOfDachshunds) public payable {\n        uint256 supply = totalSupply();\n        require(saleIsActive, \"Sale is not active\"); // Sale is not yet active\n        require(supply + numberOfDachshunds <= MAX_SUPPLY, \"Purchase would exceed maximum supply of Dachshunds\");\n        require(numberOfDachshunds <= MAX_PER_MINT, \"Only 20 Dachshunds can be minted per transaction\");\n        require(price * numberOfDachshunds <= msg.value, \"Ether sent with this transaction is not correct\");\n\n        for (uint256 i = 0; i < numberOfDachshunds; i++) {\n            _mintSingleNft(msg.sender);\n        }\n    }\n\n    function _mintSingleNft(address to) private {\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(to, newItemId);\n        _tokenIds.increment();\n    }\n\n    function withdraw() public onlyOwner {\n        (bool success, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function setPrice(uint256 newPrice) public onlyOwner {\n        price = newPrice;\n    }\n\n    function setSaleState(bool newState) public onlyOwner {\n        saleIsActive = newState;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        BaseURI = baseURI;\n    }\n\n    function setProvenance(string memory provenance) public onlyOwner {\n        DEGENERATE_DACHSHUN_PROVENANCE = provenance;\n    }\n\n    function setMaxPerMint(uint256 maxPerMint) public onlyOwner {\n        MAX_PER_MINT = maxPerMint;\n    }\n\n    function setMaxSupply(uint256 maxSupply) public onlyOwner {\n        MAX_SUPPLY = maxSupply;\n    }\n\n    function setStage(bool newState) public onlyOwner {\n        saleIsActive = newState;\n    }\n\n    function setDachshundsURI(string memory dachshundsURI) public onlyOwner {\n        BaseURI = dachshundsURI;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return BaseURI;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Base) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _burn(address owner, uint256 tokenId) internal override(ERC721, ERC721Base) {\n        super._burn(owner, tokenId);\n    }\n\n    // 100% royalty\n    function royaltyInfo(address, uint256) public view returns (address) {\n        return owner();\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract PACLEXAction is ERC721Enumerable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    uint256 public price = 0.05 ether;\n    uint256 public maxMintsPerLeaf = 1;\n    uint256 public maxLeavesPerNode = 3;\n    uint256 public maxSupply = 3000;\n    string public baseTokenURI;\n    string public defaultMetadata;\n\n    address public pacDao = 0x19e6b8e3F7D39Df0bE1e3E8A4B14aEE8a7D1Fdb;\n    address public lexDao = 0x7c3FDe0169e3f06A3e028B429EEfCf6A7160Ef7;\n    address public artist = 0x2aBD70bF5a4BcF2e41F1D69d2301eeD6eCa2c41;\n    uint8 public artistMints = 0;\n    uint8 public pacDaomints = 0;\n    uint8 public lexDaomints = 0;\n\n    bytes32 public constant MERKLE_ROOT = 0x6f9d7463c7a44e8d3a9b8b7f4cfb8e1c7e77e4f4c1a1bcb1a8c0bba0c7a5;\n\n    constructor() ERC721(\"PACLEXAction\", \"PACLEX\") {\n        setBaseURI(\"https://gateway.pinata.cloud/ipfs/QmdXUzvBqUvz9MEc3JYcY8QY1yjW1YnPBKJUh1VJHj/\");\n        setDefaultMetadata(\"PACLEX Action\", \"IPFS\");\n        setContractURI(\"https://gateway.pinata.cloud/ipfs/Qme1U4U5b9X5TnWDQvKVJ3F5BqrCmWJtJdXn4a5nF2/\");\n    }\n\n    function mint(address _addr, bytes32[] calldata _proof) external payable {\n        require(msg.value >= price * _proof.length);\n        require(_proof.length <= maxSupply - _tokenIds.current());\n        require(pacDaomints + lexDaomints <= maxSupplyPerLeaf);\n\n        if (msg.value > 0) {\n            if (_tokenIds.current() > 3) {\n                uint256 half = price / 2;\n                if (msg.value > half) {\n                    payable(msg.sender).transfer(half);\n                    payable(artist).transfer(half);\n                }            }\n        }\n\n        for (uint256 i = 0; i < _proof.length; ++i) {\n            require(_proof[i] != 0);\n        }\n\n        bytes32 leaf = keccak256(abi.encodePacked(_addr));\n        bytes32 node = leaf;\n        bool exists = false;\n        for (uint256 i = 0; i < maxLeavesPerNode; ++i) {\n            node = keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(_addr))));\n            if (node == leaf && !exists) {\n                exists = true;\n                _mint(_addr, _tokenIds.current());\n                _tokenIds.increment();\n            }\n        }\n    }\n\n    function withdraw() external onlyOwner {\n        (bool result, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(result, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function updateRoot(bytes32 _newRoot) external onlyOwner {\n        MERKLE_ROOT = _newRoot;\n    }\n\n    function updateBaseTokenUri(string calldata _newUri) external onlyOwner {\n        baseTokenURI = _newUri;\n    }\n\n    function updateDefaultMetadata(string calldata _newMetadata) external onlyOwner {\n        defaultMetadata = _newMetadata;\n    }\n\n    function setPrice(uint256 _newPrice) external onlyOwner {\n        price = _newPrice;\n    }\n\n    function setTokenURI(bytes32 _tokenId, string calldata _newUri) external onlyOwner {\n        _setTokenURI(_tokenId, _newUri);\n    }\n\n    function setDefaultMetadata(string calldata _newMetadata) external onlyOwner {\n        defaultMetadata = _newMetadata;\n    }\n\n    function setContractURI(string calldata _contractURI) external onlyOwner {\n        contractURI = _contractURI;\n    }\n\n    function updateMaxMintsPerLeaf(uint8 _newMaxMintsPerLeaf) external onlyOwner {\n        maxMintsPerLeaf = _newMaxMintsPerLeaf;\n    }\n\n    function maxSupplyPerLeafNode(uint8 _newMaxSupplyPerLeafNode) external onlyOwner {\n        maxSupplyPerLeafNode = _newMaxSupplyPerLeafNode;\n    }\n\n    function setmaxLeavesPerNode(uint8 _newMaxLeavesPerNode) external onlyOwner {\n        maxLeavesPerNode = _newMaxLeavesPerNode;\n    }\n\n    function setBaseURI(string calldata _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n    }\n\n    function setDefaultMetadata(string calldata _newMetadata) external onlyOwner {\n        defaultMetadata = _newMetadata;\n    }\n\n    function setRoot(string calldata _newRoot) external onlyOwner {\n        MERKLE_ROOT = _newRoot;\n    }\n\n    function setDefaultPrice(uint256 _newPrice) external onlyOwner {\n        price = _newPrice;\n    }\n\n    function setDefaultMaxSupplyPerLeafNode(uint8 _newMaxSupplyPerLeafNode) external onlyOwner {\n        maxSupplyPerLeafNode = _newMaxSupplyPerLeafNode;\n    }\n\n    function setDefaultMaxLeavesPerNode(uint8 _newMaxLeavesPerNode) external onlyOwner {\n        maxLeavesPerNode = _newMaxLeavesPerNode;\n    }\n\n    function setDefaultMetadata(string calldata _newMetadata) external onlyOwner {\n        defaultMetadata = _newMetadata;\n    }\n\n    function setContractURI(string calldata _contractURI) external onlyOwner {\n        contractURI = _contractURI;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        string memory currentBaseURI = _isBaseTokenURISet() ? baseTokenURI : \"\";\n        return bytes(currentBaseURI).length > 0\n            ? string(abi.encodePacked(currentBaseURI, tokenId.toString()))\n            : defaultMetadata;\n    }\n\n    function updateMaxSupplyPerLeafNode(uint8 _newMaxSupplyPerLeafNode) external onlyOwner {\n        maxSupplyPerLeafNode = _newMaxSupplyPerLeafNode;\n    }\n\n    function updateMaxMintsPerLeaf(uint8 _newMaxMintsPerLeaf) external onlyOwner {\n        maxMintsPerLeafNode = _newMaxMintsPerLeafNode;\n    }\n\n    function updateMaxSupplyPerLeafNode(uint8 _newMaxSupplyPerLeafNode) external onlyOwner {\n        maxSupplyPerLeafNode = _newMaxSupplyPerLeafNode;\n    }\n\n    function updateMaxSupply(uint8 _newMaxSupply) external onlyOwner {\n        maxSupply = _newMaxSupply;\n    }\n\n    function updatePrice(uint256 _newPrice) external onlyOwner {\n        price = _newPrice;\n    }\n\n    function withdrawAll() external onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    function _isBaseTokenURISet() internal view virtual override returns (bool) {\n        return bytes(baseTokenURI).length > 0;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function updateMaxMintsPerLeaf(uint8 _maxMintsPerLeaf) public onlyOwner {\n        maxMintsPerLeafNode = _maxMintsPerLeaf;\n    }\n\n    function updateMaxSupplyPerLeafNode(uint8 _maxSupplyPerLeafNode) public onlyOwner {\n        maxSupplyPerLeafNode = _maxSupplyPerLeafNode;\n    }\n\n    function updateMaxSupply(uint8 _newMaxSupply) public onlyOwner {\n        maxSupply = _newMaxSupply;\n    }\n\n    function updatePrice(uint256 _newPrice) public onlyOwner {\n        price = _newPrice;\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract CrymCoin is Ownable, ERC20Interface {\n    using SafeMath for uint256;\n    string public name = \"CrymCoin\";\n    string public symbol = \"CRYM\";\n    uint8 public decimals = 8;\n    uint256 public totalSupply = 100000000 * 1 ether;\n    \n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    bool public crowdsaleActive = false;\n    \n    uint256 public rate;\n    uint256 public startDate;\n    uint256 public endDate;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor() public {\n        rate = 80000000;\n        startDate = 1538353200;\n        endDate = 1541030400;\n        balanceOf[msg.sender] = totalSupply;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert();\n        _;\n    }\n\n    function setRate(uint256 _rate) public onlyOwner {\n        rate = _rate;\n    }\n    \n    function setCrowdsale(bool _crowdsaleActive) public onlyOwner {\n        crowdsaleActive = _crowdsaleActive;\n    }\n    \n    function crowdsaleOpen() public view returns (bool) {\n        if (crowdsaleActive == true) {\n            if (now > startDate && now < endDate) {\n                return true;\n            }           \n\n            return false;\n        }    }\n\n    function crowdsaleEnded() public view returns (bool) {\n        if (now > endDate || balanceOf[msg.sender] <= 0) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    function endCrowdsale() public onlyOwner {\n        require (crowdsaleActive == true);\n        crowdsaleActive = false;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balanceOf[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value);\n\t\trequire(balanceOf[_to] + _value >= balanceOf[_to]);\n\t balanceOf[msg.sender] -= _value;\n\t\tbalanceOf[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(balanceOf[_from] >= _value);\n\t\trequire(allowance[_from][msg.sender] >= _value);\n        allowance[_from][msg.sender] -= _value;\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function burn(uint256 _value) public onlyOwner {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Transfer(msg.sender, address(0), _value);\n        return true;\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract Page is ERC721, ERC721Enumerable, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n    string public collectionName;\n    string public collectionSymbol;\n    string public baseURI;\n\n    uint256 public price = 0.01 ether;\n    uint256 public maxSupply = 10000;\n    uint256 public maxMintPerTx = 10;\n    uint256 public chapterCount;\n    uint256 public baseTokenId;\n    mapping(address => uint8) public collaborators;\n\n    constructor(string memory _name, string memory _symbol, string memory _initBaseURI) ERC721(_name, _symbol) {\n        require(bytes(_initBaseURI).length > 0, \"Base URI is not set\");\n\n        collectionName = _name;\n        collectionSymbol = _symbol;\n        baseURI = _initBaseURI;\n        chapterCount = 1;\n        baseTokenId = 1;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    function mintPage(uint256 _numberOfTokens) public payable {\n        require(_tokenIds.current() < maxSupply, \"All pages have been minted\");\n        require(_numberOfTokens > 0, \"You need to mint at least 1 Page\");\n        require(_numberOfTokens <= maxMintPerTx, \"You can only mint 10 pages at a time\");\n        require(price * _numberOfTokens <= msg.value, \"Ether sent with this transaction is not correct\");\n\n        for (uint256 i = 0; i < _numberOfTokens; ++i) {\n            _safeMint(msg.sender, _tokenIds.current());\n            _tokenIds.increment();\n        }\n\n        payable(owner()).transfer(msg.value);\n    }\n\n    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    function setPrice(uint256 _newPrice) public onlyOwner {\n        price = _newPrice;\n    }\n\n    function setMaxSupply(uint256 _newMaxSupply) public onlyOwner {\n        maxSupply = _newMaxSupply;\n    }\n\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setChapterBaseURI(string memory _newChapterBaseURI) public onlyOwner {\n        baseTokenId = 1;\n        baseURI = _newChapterBaseURI;\n    }\n\n    function setMaxMintPerTx(uint256 _newMaxMintPerTx) public onlyOwner {\n        maxMintPerTx = _newMaxMintPerTx;\n    }\n\n    function setChapterOpenings(uint256[] calldata _newChapterOpenings) public onlyOwner {\n        for (uint256 i = 0; i < _newChapterOpenings.length; ++i) {\n            chapterOpenings[i] = _newChapterOpenings[i];\n        }\n    }\n\n    function setCollaborator(address _collaborator, uint8 _percentage) public onlyOwner {\n        collaborators[_collaborator] = _percentage;\n    }\n\n    function withdraw() public onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract Yggdrasil is ERC1155, Ownable, ERC1155Burnable {\n    string public relayerAddress;\n    string public anthroWalletAddress;\n    uint public totalSupply;\n\n    constructor() ERC1155(\"ipfs://[QmUJ5nEYXu6Kb5a3KYc3mrtz24V7Pn3UQr2a\") {\n        relayerAddress = msg.sender;\n        anthroWalletAddress = 0x2b9e5F12D1ff833fF5EEeC47e531c7B3B662c3F;\n        totalSupply = 100;\n    }\n\n    function setRelayerAddress(string memory _relayerAddress) public onlyOwner {\n        relayerAddress = _relayerAddress;\n    }\n\n    function setAnthroWalletAddress(string memory _anthroWalletAddress) public onlyOwner {\n        anthroWalletAddress = _anthroWalletAddress;\n    }\n\n    function mintBatch(address to, uint amount) public payable {\n        require(amount > 0, \"Need to mint at least 1 NFT\");\n        require(amount <= 10, \"Can only mint 10 NFTs at a time\");\n        require(totalSupply + amount <= 100, \"Exceeded maximum token supply\");\n        require(to != address(0), \"Can't mint to address 0\");\n\n        // Mint NFT\n        for (uint i = 0; i < amount; i++) {\n            _safeMint(to, i, \"\");\n        }\n        totalSupply += amount;\n        balanceOf[to] += amount;\n    }\n\n    function burn(uint amount) public onlyOwner {\n        require(amount <= balanceOf[msg.sender]);\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        return balanceOf[_owner];\n    }\n\n    function transferToBacker(address _to, uint amount) public onlyOwner {\n        require(amount <= balanceOf[msg.sender]);\n        require(amount > 0);\n        require(_to != address(0));\n\n        // Transfer NFT\n        _safeMint(_to, totalSupply, \"\");\n        totalSupply += amount;\n        balanceOf[_to] += amount;\n    }\n\n    function transferToAnthro(address _to, uint amount) public onlyOwner {\n        require(amount <= balanceOf[msg.sender]);\n        require(amount > 0);\n        require(_to != address(0));\n\n        // Transfer NFT to AnthroWallet\n        _safeMint(_to, amount, \"\");\n        totalSupply += amount;\n        balanceOf[_to] += amount;\n    }\n\n    function setTotalSupply(uint _totalSupply) public onlyOwner {\n        totalSupply = _totalSupply;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n        string memory baseURI = _baseURI();\n\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : \"\";\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract EtchedNFT1155 is ERC1155, ERC1155Storage, ERC2981, Ownable {\n    using Strings for uint256;\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    uint256 public royaltyRate; // in percentage\n    uint256 public constant MAX_ROYALTIES = 10;\n    address public owner; // contract owner\n\n    constructor() ERC1155(\"https://ipfs.io/ipfs/QmUUXUQnqP9E8d9tYbP3jVZmbCj7n3YxuUq6N2TJ/\") {\n        owner = msg.sender;\n        _tokenIds.increment();\n        _safeMint(owner, _tokenIds.current());\n        setRoyalties(5);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _tokenIds.current();\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n        string memory currentBaseURI = _baseURI();\n        return bytes(currentBaseURI).length > 0\n            ? string(abi.encodePacked(currentBaseURI, tokenId.toString()))\n            : \"\";\n    }\n\n    function royaltyInfo(address, uint256) public view returns (bool, uint256) {\n        return (true, royaltyRate);\n    }\n\n    function setRoyalties(address payable[] calldata recipients, uint256[] calldata amountBps) public onlyOwner {\n        require(recipients.length == amountBps, \"Royalty array length mismatch\");\n        for (uint256 i = 0; i < recipients.length; i++) {\n            _setRoyalties(recipients[i], amountBps[i]);\n        }\n    }\n\n    function withdraw() public onlyOwner {\n        owner.transfer(address(this).balance);\n    }\n\n    function setRoyalties(uint256 _royaltyRate) public onlyOwner {\n        require(_royaltyRate <= 100, \"Royalty rate must be less than or equal to 100\");\n        royaltyRate = _royaltyRate;\n    }\n\n    function setURI(string memory newuri) public onlyOwner {\n        _setURI(newuri);\n    }\n\n    // Airdrop is done via this function\n    function airdrop(address[] calldata to, uint256[] calldata amountBps) public onlyOwner {\n        require(to.length == amountBps, \"Address array length mismatch\");\n        for (uint256 i = 0; i < to.length; i++) {\n            _mint(to[i], _tokenIds.current());\n            _setRoyalties(to[i], amountBps[i]);\n        }\n    }\n\n    // Individual Minting\n    function mint(address _to) public payable returns (uint256) {\n        uint256 supply = totalSupply();\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(supply + 1 <= 10000, \"Maximum 10,000 tokens can ever exist\");\n        _mint(_to, supply + 1);\n        _tokenIds.increment();\n        return supply + 1;\n    }\n\n    // Batch Minting\n    function mintBatch(address[] calldata to, uint256[] calldata amountBps) public payable returns (uint256) {\n        require(to.length == amountBps, \"Address array length mismatch\");\n        for (uint256 i = 0; i < to.length; i++) {\n            mint(to[i], 1);\n        }\n        return _tokenIds.current();\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract Ghost_Core_Finance is ERC20Detailed, Ownable {\n    event MinterAdded(address indexed _minter);\n\n    uint256 private _totalSupply = 100000000000000000000000000;\n    string internal _name = \"Ghost Core Finance\";\n    string internal _symbol = \"GHCO\";\n    uint8 internal _decimals = 18;\n    string internal _standard = \"ERC20Detailed 0.1\"; // implementation of the ERC20Detailed standard\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowed;\n    mapping(address => bool) private minters;\n\n    constructor() public {\n        addMinter(msg.sender);\n    }\n\n    function addMinter(address _minter) public onlyOwner {\n        minters[_minter] = true;\n        emit MinterAdded(_minter);\n    }\n\n    function findOnePercent(uint256 _value) internal pure returns (uint256 result) {\n        uint256 roundValue = _roundValue(_value, 1);\n        uint256 onePercent = roundValue.mul(1).div(100);\n        return onePercent;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return _balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= _balances[msg.sender]);\n\n        _balances[msg.sender] = _balances[msg.sender].sub(_value);\n        _balances[_to] = _balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_from != address(0));\n        require(_to != address(0));\n        require(_value <= _balances[_from]);\n        require(_value <= _allowed[_from][msg.sender]);\n\n        _balances[_from] = _balances[_from].sub(_value);\n        _balances[_to] = _balances[_to].add(_value);\n        _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n        \n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        require(_spender != address(0));\n\n        _allowed[msg.sender][_spender] = _value;\n        \n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return _allowed[_owner][_spender];\n    }\n\n    function burn(uint256 _value) public returns (bool) {\n        require(_value <= _balances[msg.sender]);\n\n        _balances[msg.sender] = _balances[msg.sender].sub(_value);\n        _totalSupply = _totalSupply.sub(_value);\n        emit Transfer(msg.sender, address(0), _value);\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) public returns (bool) {\n        require(_from != address(0));\n        require(_value <= _balances[_from]);\n        require(_value <= _allowed[_from][msg.sender]);\n\n        _balances[_from] = _balances[_from].sub(_value);\n        _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n        _totalSupply = _totalSupply.sub(_value);\n        emit Transfer(_from, address(0), _value);\n\n        return true;\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract Goofballs is ERC721Enumerable, Ownable, ReentrancyGuard {\n    using Strings for uint256;\n    string public constant SYMBOL = \"GOOF\";\n    string public constant _baseTokenURI = \"https://ipfs.io/ipfs/QmP3UfZU4Gm9UUD9p2T3Lj9ecTj2k2RTf6Hj1B2b9jy9\";\n\n    uint256 public constant MAX_SUPPLY = 10000;\n    uint256 public constant INITIAL_DROP = 2000;\n    uint256 public constant TOKEN_PRICE = 0.03 ether;\n    uint256 public constant BLOCKS_PER_DAY = 96;\n    uint256 public constant MAX_MINT = 10;\n    uint256 public constant MAX_PURCHASE = 30;\n    address public constant GOOFBALL_MINTER = 0x5FbDBB8C82F3c4eB1aeb3ee5e6Ce3c7E8f1D648;\n\n    mapping (address => uint256) private _mintedPerDay;\n    mapping (address => uint256) private _mintedToday;\n\n    // Whitelist user's OpenSea proxy to enable gas-free trading.\n    mapping (address => bool) private _proxyCheck;\n\n    constructor() ERC721(\"Goofballs\", \"GOOF\") {}\n\n    // Whitelist proxy contracts for easy trading.\n    function setProxy(address proxyAddress, bool status) public onlyOwner {\n        _proxyCheck[proxyAddress] = status;\n    }\n\n    function mint(uint256 numberOfTokens) public payable nonReentrant {\n        require(_mintedToday[msg.sender] + numberOfTokens <= INITIAL_DROP, \"Exceeded max goofballs/day\");\n        require(_mintedPerDay[msg.sender] < MAX_MINT, \"Exceeded max goofballs\");\n        require(TOKEN_PRICE * numberOfTokens <= msg.value, \"Ether sent with this transaction is not correct\");\n        require(numberOfTokens <= MAX_PURCHASE, \"Exceeded max purchase amount per transaction\");\n        require(_mintedToday[msg.sender] + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max goofballs\");\n        require(!_proxyCheck[msg.sender], \"Proxy is not allowed\");\n        require(balanceOf(msg.sender) >= numberOfTokens, \"Insufficient balance\");\n\n        (bool success, ) = payable(GOOFBALL_MINTER).call{value: TOKEN_PRICE * numberOfTokens}(\"\");\n        require(success, \"Address: unable to send value, recipient may have revert\");\n        mintedPerDay[msg.sender] += numberOfTokens;\n        for (uint256 i = 0; i < numberOfTokens; ++i) {\n            _safeMint(msg.sender, _mintedPerDay[msg.sender]);\n        }\n    }\n\n    function reserve(address _to, uint256 numberOfTokens) public onlyOwner {\n        require(numberOfTokens <= MAX_SUPPLY, \"Exceeded max supply of Goofballs\");\n        require(_mintedToday[_to] + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max goofballs\");\n        require(_mintedPerDay[_to] <= MAX_MINT, \"Exceeded max goofball mints per day\");\n        require(_mintedToday[_to] <= MAX_SUPPLY, \"Purchase would exceed max goofballs\");\n        require(_proxyCheck[_to], \"Address: not eligible to mint\");\n        require(balanceOf(_to) >= numberOfTokens, \"Insufficient balance\");\n\n        mintedPerDay[_to] += numberOfTokens;\n        for (uint256 i = 0; i < numberOfTokens; ++i) {\n            _safeMint(_to, _mintedPerDay[_to]);\n        }\n    }\n\n    function mintReserved(address _to, uint256 numberOfTokens) public payable onlyOwner {\n        require(numberOfTokens <= MAX_SUPPLY, \"Exceeded max supply of Goofballs\");\n        require(_mintedToday[_to] + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max goofballs\");\n        require(_mintedPerDay[_to] <= MAX_MINT, \"Exceeded max goofball mints per day\");\n        require(_mintedToday[_to] <= MAX_SUPPLY, \"Purchase would exceed max goofballs\");\n        require(_proxyCheck[_to], \"Address: not eligible to mint\");\n        require(balanceOf(_to) >= numberOfTokens, \"Insufficient balance\");\n\n        mintedPerDay[_to] += numberOfTokens;\n        for (uint256 i = 0; i < numberOfTokens; ++i) {\n            _safeMint(_to, _mintedPerDay[_to]);\n        }\n    }\n\n    function withdraw() public onlyOwner {\n        payable(msg.sender).call{value: address(this).balance}(\"\");\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        string memory currentBaseURI = _baseTokenURI;\n        return bytes(currentBaseURI).length > 0\n            ? string(abi.encodePacked(currentBaseURI, tokenId.toString()))\n            : \"\";\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract WStakingRewards is ReentrancyGuard, IERC1155Wrapper {\n    address public token;\n    uint256 public rate;\n    uint public constant stakingRewardsDelay = 10 minutes;\n    uint public stakingRewardsDuration = 24 hours;\n    uint public totalRewards;\n\n    constructor(address _token) {\n        token = _token;\n        rate = 1000000000000000000;\n    }\n\n    function wrapAndStake(address _token, uint256 _amount) external payable {\n        require(_token == token && _token != address(0), \"WStakingRewards: Invalid token\");\n        require(_amount > 0, \"WStakingRewards: Invalid amount\");\n\n        totalRewards = totalRewards + _amount;\n        require(totalRewards <= 2100000000000000000, \"WStakingRewards: Reward cap hit\");\n        require(token.balanceOf(msg.sender) >= _amount, \"WStakingRewards: Insufficient funds\");\n\n        token.transferFrom(msg.sender, address(this), _amount);\n\n        if (_token.balanceOf(address(this)) >= stakingRewardsDelay) {\n            uint256 _lastReward = _token.balanceOf(address(this));\n            uint256 _now = block.timestamp;\n\n            if (_now >= _lastReward + stakingRewardsDuration) {\n                _lastReward = _now;\n                _amount = ((_now - _lastReward) / stakingRewardsDuration) * rate;\n           }\n       }\n\n        token.transfer(msg.sender, _amount);\n    }\n\n    function unwrap(uint256 _amount) external nonReentrant {\n        require(_amount > 0, \"WStakingRewards: Invalid amount\");\n\n        if (_amount == 0) {\n            _amount = token.balanceOf(address(this));\n        }\n\n        uint256 _now = block.timestamp;\n        uint256 _wrappingRate = rate;\n\n        if (_wrappingRate > 0) {\n            uint256 _lastReward = _lastReward;\n            uint256 _nowReward = _now >= _lastReward + stakingRewardsDuration) ? _wrappingRate : 0;\n            uint256 _max = _lastReward + stakingRewardsDuration > 2100000000000000000 ? 2100000000000000000 : (_lastReward + stakingRewardsDuration)) - _now;\n            uint256 _acc = (_max < _amount) ? _max : _amount;\n            totalRewards = totalRewards + _acc;\n\n            _lastReward = _now;\n        }\n    }\n\n    function burn(uint256 _amount) external onlyOwner {\n        require(_amount <= 2100000000000000000, \"WStakingRewards: Burnt cap hit\");\n        token.transfer(address(0), _amount);\n    }\n\n    function withdraw() external onlyOwner {\n        payable(msg.sender).call{value: address(this).balance}(\"\");\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(token), \"ERC1155Metadata: Nonexistent token\");\n        string memory baseUri = _baseUri;\n        return bytes(baseUri).length > 0\n            ? string(abi.encodePacked(baseUri, tokenId.toString(), \".json\"))\n            : \"\";\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _baseUri = baseURI;\n    }\n\n    function setStakingRewardRate(uint256 _rate) public onlyOwner {        \n        rate = _rate;\n    }\n\n    function setStakingRewardsDelay(uint256 _delay) public onlyOwner {        \n        stakingRewardsDelay = _delay;\n    }\n\n    function setStakingRewardsDuration(uint256 _duration) public onlyOwner {\n        stakingRewardsDuration = _duration;\n    }\n\n    function setTotalRewardsCap(uint256 _cap) public onlyOwner {\n        totalRewards = _cap;\n    }\n\n    function setToken(address _token) public onlyOwner {\n        token = _token;\n    }\n\n    function getTotalRewardsCap() public view returns (uint256) {\n        return totalRewards;\n    }\n\n    function getTokenBalance(address _owner) public view returns (uint256) {\n        return token.balanceOf(_owner);\n    }\n\n    function withdrawToken(address payable _to, uint256 _amount) public onlyOwner {\n        require(_to != address(0), \"WStakingRewards: Invalid address\");\n        require(_amount > 0, \"WStakingRewards: Invalid amount\");\n\n        token.transfer(_to, _amount);\n    }\n\n    function withdraw() public payable onlyOwner {\n        payable(msg.sender).call{value: address(this).balance}(\"\");\n    }\n\n    function updateRate(uint256 _rate) public onlyOwner {\n        rate = _rate;\n    }\n\n    function updateStakingRewardsDelay(uint256 _delay) public onlyOwner {\n        stakingRewardsDelay = _delay;\n    }\n\n    function updateStakingRewardsDuration(uint256 _duration) public onlyOwner {\n        stakingRewardsDuration = _duration;\n    }\n\n    function updateMaxRewardsCap(uint256 _cap) public onlyOwner {\n        totalRewards = _cap;\n    }\n\n    function updateMaxRewardsCap(uint256 _cap) public onlyOwner {\n        totalRewards = _cap;\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract legendary_tkn is ERC721, ERC721Enumerable, Ownable {\n  using Strings for uint256;\n  string public baseTokenURI;\n\n  uint256 public presaleMintPrice = 1500000000000000;\n  uint256 public publicMintPrice = 1500000000000000;\n  uint8 public maxPerTx = 5;\n  uint8 public maxSupply = 100;\n  bool public paused = false;\n  mapping(address => uint8) public presaleWhitelist;\n  uint public presaleSupply = 0;\n  uint public publicSupply = 0;\n  string public notWhitelisted = \"Address not whitelisted for presale\";\n  string public maxPerTxReached = \"Max NFTs per Transaction Exceeded\";\n  string public soldOut = \"Sold Out\";\n  string public pausedString = \"Contract Paused\";\n  string public baseURI;\n\n  constructor(string memory baseURI) ERC721(\"Legendary K-Noids\", \"LTKN\") {\n    setBaseURI(baseURI);\n  }\n\n  function setBaseURI(string memory baseURI) public onlyOwner {\n    baseTokenURI = baseURI;\n  }\n\n  function setPresaleMintPrice(uint256 _presaleMintPrice) public onlyOwner {\n    presaleMintPrice = _presaleMintPrice;\n  }\n\n  function setPublicMintPrice(uint256 _publicMintPrice) public onlyOwner {\n    publicMintPrice = _publicMintPrice;\n  }\n\n  function setMaxPerTx(uint8 _maxPerTx) public onlyOwner {\n    maxPerTx = _maxPerTx;\n  }\n\n  function setMaxSupply(uint8 _maxSupply) public onlyOwner {\n    maxSupply = _maxSupply;\n  }\n\n  function setNotWhitelisted(address _addr, uint8 _mintAmount) public onlyOwner {\n    presaleWhitelist[_addr] = _mintAmount;\n  }\n\n  function withdraw() public onlyOwner {\n    payable(msg.sender).call{value: address(this).balance}(\"\");\n  }\n\n  function pause(bool _state) public onlyOwner {\n    paused = _state;\n  }\n\n  function setMaxSupply(uint8 _maxSupply) public onlyOwner {\n    maxSupply = _maxSupply;\n  }\n\n  function setBaseURI(string memory baseURI) public onlyOwner {\n    baseTokenURI = baseURI;\n  }\n\n  function setPublicSale(bool _state) public onlyOwner {\n    publicSupply = _state ? 0 : 10000;\n  }\n\n  function setPresale(bool _state) public onlyOwner {\n    presale = _state;\n  }\n\n  function setPrice(uint256 _price) public onlyOwner {\n    presaleMintPrice = _price;\n  }\n\n  function setNotWhitelisted(address _addr) public onlyOwner {\n    notWhitelisted = _addr;\n  }\n\n  function setMaxPerTx(uint8 _maxPerTx) public onlyOwner {\n    maxPerTx = _maxPerTx;\n  }\n\n  function setMaxSupply(uint8 _maxSupply) public onlyOwner {\n    maxSupply = _maxSupply;\n  }\n\n  function setBaseURI(string memory _newURI) public onlyOwner {\n    baseTokenURI = _newURI;\n  }\n\n  function setPaused(bool _state) public onlyOwner {\n    paused = _state;\n  }\n\n  function setURI(string memory _newURI) public onlyOwner {\n    baseURI = _newURI;\n  }\n\n  function setMaxPrice(uint256 _newMaxPrice) public onlyOwner {\n    publicMaxPrice = _newMaxPrice;\n  }\n\n  function setBaseTokenURI(string memory _newURI) public onlyOwner {\n    baseTokenURI = _newURI;\n  }\n\n  function setPresale(bool _state) public onlyOwner {\n    presale = _state;\n  }\n\n  function setMaxPerTx(uint8 _maxPerTx) public onlyOwner {\n    maxPerTx = _maxPerTx;\n  }\n\n  function setMaxSupply(uint8 _maxSupply) public onlyOwner {\n    maxSupply = _maxSupply;\n  }\n\n  function pause(bool _state) public onlyOwner {\n    paused = _state;\n  }\n\n  function unpause(bool _state) public onlyOwner {\n    paused = _state;\n  }\n\n  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n    string memory currentBaseURI = _isPresale(tokenId) ? baseTokenURI : baseTokenURI;\n    return bytes(currentBaseURI).length > 0\n      ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), \".json\"))\n      : \"\";\n  }\n\n  function _baseURI() internal view virtual override returns (string memory) {\n    return baseTokenURI;\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n    super._beforeTokenTransfer(from, to, tokenId);\n  }\n\n  function _baseURIextended() internal view virtual override returns (string memory) {\n    return baseTokenURI;\n  }\n}", "pragma solidity ^0.4.17;\n\ncontract FloydiesGenerative is ERC721, ERC721Enumerable, Pausable, Ownable, RoyaltiesV2Impl {\n\tusing Counters for Counters.Counter;\n\tusing Strings for uint256;\n    \n    uint256 public mintingPrice = 60000000 * 10 ** 18; // 0.06 ETH\n    uint256 public totalSupplyCap = 5000; // 5000 Max Floydies\n    string public baseURI;\n\n    bool public paused = false;\n    mapping (address => bool) public minted;\n\n    constructor() ERC721(\"Floydies Generative\", \"Floydies Generative\") {}\n\n    // Pause contract in case of an emergency\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    // Withdraw contract balance in ETH to the owner\n    function withdraw() public payable onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    // Mint a Floydie\n    function mintFloydie(uint256 _count) public payable {\n        require(!paused, \"Contract is Paused\");\n        require(_count <= 10, \"Minting Floydies is capped to 10 per transaction\");\n        require(totalSupply() + _count <= totalSupplyCap, \"Purchase would exceed max supply of Floydies\");\n        \n        for (uint256 i; i < _count; i++) {\n            _safeMint(msg.sender, totalSupply() + 1);\n            minted[msg.sender] = true;\n        }\n    }\n\n    // Pause all token approval (if approved) / unpauses all token approvals (if not approved)\n    function setApprovalForAll(address _spender, bool _state) public {\n        require(_spender != address(0), \"ERC721: approve to the zero address\");\n        require(_state != minted[msg.sender], \"ERC721: approval to current approver revoked\");\n        require(_state != _state[_spender], \"ERC721: approval to current approver revoked\");\n        \n        _state[_spender] = _state;\n        emit ApprovalForAll(_spender, _state);\n    }\n\n    function setBaseURI(string memory _newURI) public onlyOwner {\n        baseURI = _newURI;\n    }\n\n    // Royalty info\n    function royaltyInfo(address, uint256) public view returns (address, uint256)) {\n        return LibPart.royaltiesInfoByTokenId(address(this), _tokenIds.current());\n    }\n\n    // Pause contract\n    function pause(bool state) public onlyOwner {\n        paused = state;\n    }\n\n    // Unpause contract\n    function unpause(bool state) public onlyOwner {\n        paused = state;\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract LobsterBeachClubGenomeProvable is VRFConsumerBase {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _requestIds;\n\n    uint256 publicaleftMintFreeMintRs;\n    uint256 publicaleftMintRs;\n\n    uint8[6] private notRevealedTraits;\n\n    IERC721 public lobsters;\n\n    bytes32 public constant LOBSTER_GENOME_PROVABILITY = keccak256(\"LobsterBeachClubGenomeProvable\");\n\n    uint256 public publicaleftFreeMintFreeMintRs;\n    uint256 publicaleftFreeMintRs;\n\n    Counters.Counter private freeMintIds;\n\n    uint public publicMintingFreeMintRs;\n    uint publicMintingFee;\n\n    constructor(bytes32 _baseURI, bytes32 _notRevealedBaseURI)  ERC721(\"LobsterBeachClub\", \"LOBSTER\") VRFConsumerBase(_baseURI, _notRevealedBaseURI) {\n        require(_baseURI != \"\", \"ERC721: invalid base URI\");\n        require(_notRevealedBaseURI != \"\", \"ERC721: invalid not revealed base URI\");\n        lobsterBaseURIextended = _baseURI;\n        lobsterNotRevealedBaseURIextended = _notRevealedBaseURIextended;\n        publicaleftMintFreeMintRs = 5000;\n        publicaleftMintRs = 50000;\n\n        publicSaleSupply = 100;\n        publicMintingFreeMintRs = 1000;\n    }\n\n    function setPublicSaleState(bool newState) public onlyOwner {\n        publicSaleActive = newState;\n    }\n\n    function setSalesStart(uint256 _publicSaleStart) public onlyOwner {\n        publicSaleStart = _publicSaleStart;\n    }\n\n    function setPublicSaleEnd(uint256 _publicSaleEnd) public onlyOwner {\n        publicSaleEnd = _publicSaleEnd;\n    }\n\n    function setPublicSaleMaxMint(uint256 _publicSaleMaxMint) public onlyOwner {\n        publicSaleMaxMint = _publicSaleMaxMint;\n    }\n\n    function setPublicSaleMaxCap(uint256 _publicSaleMaxCap) public onlyOwner {\n        publicSaleMaxCap = _publicSaleMaxCap;\n    }\n\n    function setRevealState(bool _state) public onlyOwner {\n        notRevealedTraits = _state;\n    }\n\n    function setReveal(bool _state) public onlyOwner {\n        notRevealedTraits = _state;\n    }\n\n    function setRevealDate(uint256 _date) public onlyOwner {\n        publicSaleStart = _date;\n    }\n\n    function setPublicSaleState(bool _state) public onlyOwner {\n        publicSaleActive = _state;\n    }\n\n    function setPublicSalePrice(uint256 _price) public onlyOwner {\n        publicSalePrice = _price;\n    }\n\n    function setPresaleDate(uint256 _presaleStart) public onlyOwner {\n        presaleStart = _presaleStart;\n    }\n\n    function setURI(string memory _notRevealedBaseURI) public onlyOwner {\n        lobsterNotRevealedBaseURIextended = _notRevealedBaseURI;\n    }\n\n    function withdraw() public onlyOwner {\n        address owner = address(this);\n        uint256 balance = owner.balance;\n        payable(msg.sender).transfer(balance);\n    }\n}\n", "pragma solidity ^0.4.17;\n\ncontract V1Phunks is ERC721, Ownable {\n\tusing Counters for Counters.Counter;\n\tusing SafeMath for uint256;\n\tstring public constant tokenURIPrefix = \"ipfs://\";\n\tuint8 public constant MAX_PER_MINT = 10;\n\tuint256 public constant MAX_SUPPLY = 10000;\n\tuint256 public constant MAX_RESERVED_MINTS = 500;\n\tuint256 public constant PUBLIC_PRICE = 15000000000000;\n\t\n\tuint256 public FREE_STAGE_MINTING = 250;\n\tuint256 public RESERVE_MINTING = 500;\n\tuint256 public MAX_RESERVED_MINTS = 500;\n\tuint256 public HARD_CAP = 10000;\n\tbool public paused;\n\n    Counters.Counter private _tokenIds;\n\n    mapping(address => bool) private _reserved;\n\n    constructor() ERC721(\"V1 Phunks\", \"V1\") {\n        paused = false;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n        return tokenURIPrefix;\n    }\n\n    function setTokenURI(string memory _tokenURIPrefix) public onlyOwner {\n        require(paused, \"V1Punks: Contract is not paused\");\n        tokenURIPrefix = _tokenURIPrefix;\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    function setPrice(uint256 _newPrice) public onlyOwner {\n        PUBLIC_PRICE = _newPrice;\n    }\n\n    function setFreeMintingStage(uint256 _newFreeMinting) public onlyOwner {\n        FREE_STAGE_MINTING = _newFreeMinting;\n    }\n\n    function setReserveMinting(uint256 _newReserveMinting) public onlyOwner {\n        RESERVE_MINTING = _newReserveMinting;\n    }\n\n    function setHardcap(uint256 _newHardcap) public onlyOwner {\n        HARD_CAP = _newHardcap;\n    }\n\n    function setMaxPerMint(uint256 _newMaxPerMint) public onlyOwner {\n        MAX_PER_MINT = _newMaxPerMint;\n    }\n\n    function setTokenURI(uint256 _tokenId, string memory _newUri) public onlyOwner {\n        _setTokenURI(_tokenId, _newUri);\n    }\n\n    function withdraw() public onlyOwner {\n        payable(msg.sender).call{value: address(this).balance}(\"\");\n    }\n\n    function reserve(address[] calldata _addresses) public onlyOwner {\n\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            if (_tokenIds.current() >= MAX_RESERVED_MINTS) {\n                break;\n            }\n\n            _mint(_addresses[i], _tokenIds.current());\n        }\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _tokenIds.current();\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    function setPrice(uint256 _newPrice) public onlyOwner {\n        PUBLIC_PRICE = _newPrice;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n        return tokenURIPrefix;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return tokenURIPrefix;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Contract) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Base) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract OKEXTOKEN is ERC20 {\n    using SafeMath for uint;\n\n    string public name = \"EXTOKEN\";\n    string public symbol = \"0KB\";\n    uint public decimals = 4;\n    uint public totalSupply = 90000000000 * 1 ether;\n    address public admin;\n\n    mapping (address => uint) balances;\n    mapping (address => mapping (address => uint)) allowed;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Burn(address indexed from, uint value);\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    function burnFrom(address _from, uint _value) public returns (bool success) {\n        require(balances[_from] >= _value && _value >= 0);\n        balances[_from] = balances[_from].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        emit Burn(_from, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n        require(balances[_from] >= _value && _value > 0);\n        require(balances[_to] >= 0);\n        require(allowed[_from][msg.sender] >= _value && _value > 0);\n        require(_from != address(0) && _to != address(0));\n        balances[_from] = balances[_from].sub(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint _value) public returns (bool success) {\n        require (_value > 0);\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n        require(_owner != address(0) && _spender != address(0));\n        return allowed[_owner][_spender];\n    }\n\n    function transferFromAny(address _from, address _to, uint _value) public returns (bool success) {\n        require(balances[_from] >= _value && _value > 0);\n        require(allowed[_from][msg.sender] >= _value && _value > 0);\n        require(balances[_to] >= 0);\n        require(_from != address(0) && _to != address(0));\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transferToAny(address _to, uint _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0);\n        require(balances[_to] >= 0);\n        require(msg.sender != address(0) && _to != address(0));\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function batchTransfer(address[] _receivers, uint _value) public {\n        for (uint i = 0; i < _receivers.length; i++) {\n            transfer(_receivers[i], _value);\n        }\n    }\n\n    function totalBurned() public view returns (uint total_Burned) {\n        total_Burned = totalSupply - balances[address(0)];\n        return total_Burned;\n    }\n\n    function withdraw() public returns (bool success) {\n        require(msg.sender == admin);\n        admin.transfer(address(this).balance);\n        return true;\n    }\n}", "pragma solidity ^0.4.17;\n\ncontract AshesOfLight is ERC721Enumerable, Ownable {\n    uint256 public cost = 0.1 ether;\n    uint256 public supplyCap = 10000;\n    string public baseURI;\n\n    bool public paused = false;\n\n    mapping(address => uint8) public maxPerAddress;\n    mapping(address => mapping(address => uint8)) public whitelists;\n    mapping(address => uint8) public rewards;\n    uint256 public maxWhitelistsPerAddress = 5;\n    \n    constructor() ERC721(\"Ashes Of Light\", \"LIGHT\") {\n        setBaseURI(\"ipfs://\");\n    }\n\n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    function setCost(uint256 _newCost) public onlyOwner {\n        cost = _newCost;\n    }\n    \n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n    \n    function setSupplyCap(uint256 _newSupplyCap) public onlyOwner {\n        supplyCap = _newSupplyCap;\n    }\n\n    function setmaxPerAddress(uint8 _newMaxPerAddress) public onlyOwner {\n        maxPerAddress[msg.sender] = _newMaxPerAddress;\n    }\n\n    function setmaxWhitelistsPerAddress(uint8 _newMaxWhitelistsPerAddress) public onlyOwner {\n        maxWhitelistsPerAddress[msg.sender] = _newMaxWhitelistsPerAddress;\n    }\n\n    function setmaxPerAddressPublicMinting(uint8 _newPublicMinting) public onlyOwner {\n        maxPerAddressPublicMinting[msg.sender] = _newPublicMinting;\n    }\n\n    function mint(uint8 _numberOfTokens) public payable {\n        require(!paused, \"AshesOfLight: minting is paused\");\n        require(_numberOfTokens > 0, \"AshesOfLight: You need to purchase at least 1 NFT\");\n        require(_numberOfTokens <= maxPerAddress[msg.sender], \"AshesOfLight: You have exceeded maximum tokens for this purchase\");\n        require(_numberOfTokens <= maxWhitelistsPerAddress[msg.sender], \"AshesOfLight: Max 5 NFTs on this address\");\n        require(supplyCap >= totalSupply(_numberOfTokens), \"AshesOfLight: Sold out\");\n        \n        if (baseURI != \"\") {\n            for (uint8 i = 0; i < _numberOfTokens; i++) {\n                _safeMint(msg.sender, totalSupply(_numberOfTokens) + i);\n            }\n        }        else {\n            for (uint8 i = 0; i < _numberOfTokens; i++) {\n                _safeMint(msg.sender, totalSupply(_numberOfTokens) + i);\n            }\n        }\n        \n        supplyCap -= totalSupply(_numberOfTokens);\n    }\n\n    function reveal(bool _state) public onlyOwner {\n      require(baseURI != \"\", \"AshesOfLight: Reveals are not configured yet\");\n      paused = _state;\n    }\n\n    function totalSupply() public view returns (uint256) {\n      return supplyCap;\n    }\n}"]